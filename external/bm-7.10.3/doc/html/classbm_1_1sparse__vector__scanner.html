<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>BitMagic-C++: bm::sparse_vector_scanner&lt; SV &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">BitMagic-C++
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacebm.html">bm</a></li><li class="navelem"><a class="el" href="classbm_1_1sparse__vector__scanner.html">sparse_vector_scanner</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle"><div class="title">bm::sparse_vector_scanner&lt; SV &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__bmagic.html">BitMagic Library</a> &raquo; <a class="el" href="group__svector.html">Sparse and compressed vectors</a> &raquo; <a class="el" href="group__svalgo.html">Sparse vector algorithms</a> &#124; <a class="el" href="group__bmagic.html">BitMagic Library</a> &raquo; <a class="el" href="group__bvector.html">bvector&lt;&gt; container</a> &raquo; <a class="el" href="group__setalgo.html">bvector&lt;&gt; algorithms</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>algorithms for <a class="el" href="classbm_1_1sparse__vector.html" title="succinct sparse vector with runtime compression using bit-slicing / transposition method">sparse_vector</a> scan/search  
 <a href="classbm_1_1sparse__vector__scanner.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="bmsparsevec__algo_8h_source.html">bmsparsevec_algo.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1sparse__vector__scanner_1_1pipeline.html">pipeline</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pipeline to run multiple searches against a particular SV faster using cache optimizations.  <a href="classbm_1_1sparse__vector__scanner_1_1pipeline.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a2610acb19f7d9127c681d584ecf9e9ea"><td class="memItemLeft" align="right" valign="top"><a id="a2610acb19f7d9127c681d584ecf9e9ea"></a>
typedef SV::bvector_type&#160;</td><td class="memItemRight" valign="bottom"><b>bvector_type</b></td></tr>
<tr class="separator:a2610acb19f7d9127c681d584ecf9e9ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7774b8f39faf83fe4668f76c376e6a9"><td class="memItemLeft" align="right" valign="top"><a id="ae7774b8f39faf83fe4668f76c376e6a9"></a>
typedef const <a class="el" href="classbm_1_1sparse__vector__scanner.html#a2610acb19f7d9127c681d584ecf9e9ea">bvector_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>bvector_type_const_ptr</b></td></tr>
<tr class="separator:ae7774b8f39faf83fe4668f76c376e6a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a607d9a0a3aaac3e60ac5719e55962b1c"><td class="memItemLeft" align="right" valign="top"><a id="a607d9a0a3aaac3e60ac5719e55962b1c"></a>
typedef <a class="el" href="classbm_1_1sparse__vector__scanner.html#a2610acb19f7d9127c681d584ecf9e9ea">bvector_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>bvector_type_ptr</b></td></tr>
<tr class="separator:a607d9a0a3aaac3e60ac5719e55962b1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3890a7946df47e738cd7e3496b78f767"><td class="memItemLeft" align="right" valign="top"><a id="a3890a7946df47e738cd7e3496b78f767"></a>
typedef SV::value_type&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b></td></tr>
<tr class="separator:a3890a7946df47e738cd7e3496b78f767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5856b08009c13a4683c8fc4566bdf89c"><td class="memItemLeft" align="right" valign="top"><a id="a5856b08009c13a4683c8fc4566bdf89c"></a>
typedef SV::size_type&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b></td></tr>
<tr class="separator:a5856b08009c13a4683c8fc4566bdf89c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a440260db6e476e16e71dda438e18b187"><td class="memItemLeft" align="right" valign="top"><a id="a440260db6e476e16e71dda438e18b187"></a>
typedef <a class="el" href="classbm_1_1bvector.html#ad1dbe63690fd5cd2b1e064795d3f1b6c">bvector_type::allocator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>allocator_type</b></td></tr>
<tr class="separator:a440260db6e476e16e71dda438e18b187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2f5ebd37c06d9a8b69d2a26efaac638"><td class="memItemLeft" align="right" valign="top"><a id="aa2f5ebd37c06d9a8b69d2a26efaac638"></a>
typedef allocator_type::allocator_pool_type&#160;</td><td class="memItemRight" valign="bottom"><b>allocator_pool_type</b></td></tr>
<tr class="separator:aa2f5ebd37c06d9a8b69d2a26efaac638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0989298a6073874b28b1834235077fe6"><td class="memItemLeft" align="right" valign="top"><a id="a0989298a6073874b28b1834235077fe6"></a>
typedef <a class="el" href="classbm_1_1aggregator.html">bm::aggregator</a>&lt; <a class="el" href="classbm_1_1sparse__vector__scanner.html#a2610acb19f7d9127c681d584ecf9e9ea">bvector_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>aggregator_type</b></td></tr>
<tr class="separator:a0989298a6073874b28b1834235077fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a653fbc8c97f4699d6879b12ad42f9838"><td class="memItemLeft" align="right" valign="top"><a id="a653fbc8c97f4699d6879b12ad42f9838"></a>
typedef bm::heap_vector&lt; <a class="el" href="classbm_1_1sparse__vector__scanner.html#a3890a7946df47e738cd7e3496b78f767">value_type</a>, typename <a class="el" href="classbm_1_1bvector.html#ad1dbe63690fd5cd2b1e064795d3f1b6c">bvector_type::allocator_type</a>, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>remap_vector_type</b></td></tr>
<tr class="separator:a653fbc8c97f4699d6879b12ad42f9838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2a0a055f6374988b24201a13cb65a74"><td class="memItemLeft" align="right" valign="top"><a id="aa2a0a055f6374988b24201a13cb65a74"></a>
typedef bm::heap_vector&lt; <a class="el" href="classbm_1_1sparse__vector__scanner.html#a2610acb19f7d9127c681d584ecf9e9ea">bvector_type</a> *, <a class="el" href="classbm_1_1sparse__vector__scanner.html#a440260db6e476e16e71dda438e18b187">allocator_type</a>, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>bvect_vector_type</b></td></tr>
<tr class="separator:aa2a0a055f6374988b24201a13cb65a74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46e8b16a28499e1d34bb2e17ba2ec8e7"><td class="memItemLeft" align="right" valign="top"><a id="a46e8b16a28499e1d34bb2e17ba2ec8e7"></a>
typedef <a class="el" href="classbm_1_1aggregator.html#a423f0dfcb535fd51cb94592b1548db58">aggregator_type::bv_count_vector_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>bv_count_vector_type</b></td></tr>
<tr class="separator:a46e8b16a28499e1d34bb2e17ba2ec8e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbc9bc081ef214932b3debb741c51a0d"><td class="memItemLeft" align="right" valign="top">typedef aggregator_type::run_options&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1sparse__vector__scanner.html#afbc9bc081ef214932b3debb741c51a0d">run_options</a></td></tr>
<tr class="memdesc:afbc9bc081ef214932b3debb741c51a0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scanner options to control execution.  <a href="classbm_1_1sparse__vector__scanner.html#afbc9bc081ef214932b3debb741c51a0d">More...</a><br /></td></tr>
<tr class="separator:afbc9bc081ef214932b3debb741c51a0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab002ae65e2357e58f47e544006eef2d2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1sparse__vector__scanner.html#ab002ae65e2357e58f47e544006eef2d2">sparse_vector_scanner</a> ()</td></tr>
<tr class="memdesc:ab002ae65e2357e58f47e544006eef2d2"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="classbm_1_1sparse__vector__scanner.html#ab002ae65e2357e58f47e544006eef2d2">More...</a><br /></td></tr>
<tr class="separator:ab002ae65e2357e58f47e544006eef2d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5bd3464c5c0528ff168649413b5e7ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1sparse__vector__scanner.html#aa5bd3464c5c0528ff168649413b5e7ee">bind</a> (const SV &amp;sv, bool sorted)</td></tr>
<tr class="memdesc:aa5bd3464c5c0528ff168649413b5e7ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">bind sparse vector for all searches  <a href="classbm_1_1sparse__vector__scanner.html#aa5bd3464c5c0528ff168649413b5e7ee">More...</a><br /></td></tr>
<tr class="separator:aa5bd3464c5c0528ff168649413b5e7ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fd8c8e2b6687af8e1dbdd617a7fac08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1sparse__vector__scanner.html#a7fd8c8e2b6687af8e1dbdd617a7fac08">reset_binding</a> () <a class="el" href="bmdef_8h.html#a40d7d3c011d2128b1f0c392127d7d61e">BMNOEXCEPT</a></td></tr>
<tr class="memdesc:a7fd8c8e2b6687af8e1dbdd617a7fac08"><td class="mdescLeft">&#160;</td><td class="mdescRight">reset sparse vector binding  <a href="classbm_1_1sparse__vector__scanner.html#a7fd8c8e2b6687af8e1dbdd617a7fac08">More...</a><br /></td></tr>
<tr class="separator:a7fd8c8e2b6687af8e1dbdd617a7fac08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1113943fa447f96f12cef5755f940acd"><td class="memTemplParams" colspan="2">template&lt;typename SV &gt; </td></tr>
<tr class="memitem:a1113943fa447f96f12cef5755f940acd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbm_1_1sparse__vector__scanner.html#a1113943fa447f96f12cef5755f940acd">find_eq_str</a> (const typename SV::value_type *str, typename SV::size_type &amp;pos)</td></tr>
<tr class="memdesc:a1113943fa447f96f12cef5755f940acd"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="classbm_1_1sparse__vector__scanner.html#a1113943fa447f96f12cef5755f940acd">More...</a><br /></td></tr>
<tr class="separator:a1113943fa447f96f12cef5755f940acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe444fd12188f62889217370bd980b78"><td class="memTemplParams" colspan="2"><a id="abe444fd12188f62889217370bd980b78"></a>
template&lt;typename SV &gt; </td></tr>
<tr class="memitem:abe444fd12188f62889217370bd980b78"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>find_eq_str</b> (const SV &amp;sv, const typename SV::value_type *str, typename SV::size_type &amp;pos)</td></tr>
<tr class="separator:abe444fd12188f62889217370bd980b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a591aeeb28ad76f0de6575178c7722e15"><td class="memTemplParams" colspan="2">template&lt;typename SV &gt; </td></tr>
<tr class="memitem:a591aeeb28ad76f0de6575178c7722e15"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbm_1_1sparse__vector__scanner.html#a591aeeb28ad76f0de6575178c7722e15">find_eq_str</a> (const typename SV::value_type *str, typename <a class="el" href="rscsample05_8cpp.html#a4ca03dfc387c36e69ea916426572acdc">SV::bvector_type</a> &amp;bv_out)</td></tr>
<tr class="memdesc:a591aeeb28ad76f0de6575178c7722e15"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="classbm_1_1sparse__vector__scanner.html#a591aeeb28ad76f0de6575178c7722e15">More...</a><br /></td></tr>
<tr class="separator:a591aeeb28ad76f0de6575178c7722e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67324751c6d58a7aa36a9e12c1b621be"><td class="memTemplParams" colspan="2"><a id="a67324751c6d58a7aa36a9e12c1b621be"></a>
template&lt;typename SV &gt; </td></tr>
<tr class="memitem:a67324751c6d58a7aa36a9e12c1b621be"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>find_eq_str</b> (const SV &amp;sv, const typename SV::value_type *str, typename <a class="el" href="rscsample05_8cpp.html#a4ca03dfc387c36e69ea916426572acdc">SV::bvector_type</a> &amp;bv_out)</td></tr>
<tr class="separator:a67324751c6d58a7aa36a9e12c1b621be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Find in scalar vector</div></td></tr>
<tr class="memitem:a7fe9583056b9b1ff6bb2589ded6612b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1sparse__vector__scanner.html#a7fe9583056b9b1ff6bb2589ded6612b2">find_eq</a> (const SV &amp;sv, <a class="el" href="classbm_1_1sparse__vector__scanner.html#a3890a7946df47e738cd7e3496b78f767">value_type</a> value, <a class="el" href="classbm_1_1sparse__vector__scanner.html#a2610acb19f7d9127c681d584ecf9e9ea">bvector_type</a> &amp;bv_out)</td></tr>
<tr class="memdesc:a7fe9583056b9b1ff6bb2589ded6612b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">find all sparse vector elements EQ to search value  <a href="classbm_1_1sparse__vector__scanner.html#a7fe9583056b9b1ff6bb2589ded6612b2">More...</a><br /></td></tr>
<tr class="separator:a7fe9583056b9b1ff6bb2589ded6612b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5427018a1a713e5146dc97a2997bc9a9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1sparse__vector__scanner.html#a5427018a1a713e5146dc97a2997bc9a9">find_eq</a> (const SV &amp;sv, <a class="el" href="classbm_1_1sparse__vector__scanner.html#a3890a7946df47e738cd7e3496b78f767">value_type</a> value, <a class="el" href="classbm_1_1sparse__vector__scanner.html#a5856b08009c13a4683c8fc4566bdf89c">size_type</a> &amp;pos)</td></tr>
<tr class="memdesc:a5427018a1a713e5146dc97a2997bc9a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">find first sparse vector element  <a href="classbm_1_1sparse__vector__scanner.html#a5427018a1a713e5146dc97a2997bc9a9">More...</a><br /></td></tr>
<tr class="separator:a5427018a1a713e5146dc97a2997bc9a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6ff77cf057f81c1689af3dfd98723b2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1sparse__vector__scanner.html#ab6ff77cf057f81c1689af3dfd98723b2">bfind</a> (const SV &amp;sv, const <a class="el" href="classbm_1_1sparse__vector__scanner.html#a3890a7946df47e738cd7e3496b78f767">value_type</a> val, <a class="el" href="classbm_1_1sparse__vector__scanner.html#a5856b08009c13a4683c8fc4566bdf89c">size_type</a> &amp;pos)</td></tr>
<tr class="memdesc:ab6ff77cf057f81c1689af3dfd98723b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">binary search for position in the sorted sparse vector  <a href="classbm_1_1sparse__vector__scanner.html#ab6ff77cf057f81c1689af3dfd98723b2">More...</a><br /></td></tr>
<tr class="separator:ab6ff77cf057f81c1689af3dfd98723b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36d1b7cb0fa99f7b5a7ac799f0ce398"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1sparse__vector__scanner.html#af36d1b7cb0fa99f7b5a7ac799f0ce398">find_gt</a> (const SV &amp;sv, <a class="el" href="classbm_1_1sparse__vector__scanner.html#a3890a7946df47e738cd7e3496b78f767">value_type</a> val, <a class="el" href="classbm_1_1sparse__vector__scanner.html#a2610acb19f7d9127c681d584ecf9e9ea">bvector_type</a> &amp;bv_out)</td></tr>
<tr class="memdesc:af36d1b7cb0fa99f7b5a7ac799f0ce398"><td class="mdescLeft">&#160;</td><td class="mdescRight">find all elements sparse vector element greater (&gt;) than value  <a href="classbm_1_1sparse__vector__scanner.html#af36d1b7cb0fa99f7b5a7ac799f0ce398">More...</a><br /></td></tr>
<tr class="separator:af36d1b7cb0fa99f7b5a7ac799f0ce398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aead5949c77e69780907bae570f629e69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1sparse__vector__scanner.html#aead5949c77e69780907bae570f629e69">find_ge</a> (const SV &amp;sv, <a class="el" href="classbm_1_1sparse__vector__scanner.html#a3890a7946df47e738cd7e3496b78f767">value_type</a> val, <a class="el" href="classbm_1_1sparse__vector__scanner.html#a2610acb19f7d9127c681d584ecf9e9ea">bvector_type</a> &amp;bv_out)</td></tr>
<tr class="memdesc:aead5949c77e69780907bae570f629e69"><td class="mdescLeft">&#160;</td><td class="mdescRight">find all elements sparse vector element greater or equal (&gt;=) than value  <a href="classbm_1_1sparse__vector__scanner.html#aead5949c77e69780907bae570f629e69">More...</a><br /></td></tr>
<tr class="separator:aead5949c77e69780907bae570f629e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa08de09bbf36b6832c4357e24477cc65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1sparse__vector__scanner.html#aa08de09bbf36b6832c4357e24477cc65">find_lt</a> (const SV &amp;sv, <a class="el" href="classbm_1_1sparse__vector__scanner.html#a3890a7946df47e738cd7e3496b78f767">value_type</a> val, <a class="el" href="classbm_1_1sparse__vector__scanner.html#a2610acb19f7d9127c681d584ecf9e9ea">bvector_type</a> &amp;bv_out)</td></tr>
<tr class="memdesc:aa08de09bbf36b6832c4357e24477cc65"><td class="mdescLeft">&#160;</td><td class="mdescRight">find all elements sparse vector element less (&lt;) than value  <a href="classbm_1_1sparse__vector__scanner.html#aa08de09bbf36b6832c4357e24477cc65">More...</a><br /></td></tr>
<tr class="separator:aa08de09bbf36b6832c4357e24477cc65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec58a1e6d0d8cd4cf161353d427455cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1sparse__vector__scanner.html#aec58a1e6d0d8cd4cf161353d427455cd">find_le</a> (const SV &amp;sv, <a class="el" href="classbm_1_1sparse__vector__scanner.html#a3890a7946df47e738cd7e3496b78f767">value_type</a> val, <a class="el" href="classbm_1_1sparse__vector__scanner.html#a2610acb19f7d9127c681d584ecf9e9ea">bvector_type</a> &amp;bv_out)</td></tr>
<tr class="memdesc:aec58a1e6d0d8cd4cf161353d427455cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">find all elements sparse vector element less or equal (&lt;=) than value  <a href="classbm_1_1sparse__vector__scanner.html#aec58a1e6d0d8cd4cf161353d427455cd">More...</a><br /></td></tr>
<tr class="separator:aec58a1e6d0d8cd4cf161353d427455cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4db5cbc383399b813515f26c8b8df3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1sparse__vector__scanner.html#af4db5cbc383399b813515f26c8b8df3d">find_range</a> (const SV &amp;sv, <a class="el" href="classbm_1_1sparse__vector__scanner.html#a3890a7946df47e738cd7e3496b78f767">value_type</a> from, <a class="el" href="classbm_1_1sparse__vector__scanner.html#a3890a7946df47e738cd7e3496b78f767">value_type</a> to, <a class="el" href="classbm_1_1sparse__vector__scanner.html#a2610acb19f7d9127c681d584ecf9e9ea">bvector_type</a> &amp;bv_out)</td></tr>
<tr class="memdesc:af4db5cbc383399b813515f26c8b8df3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">find all elements sparse vector element in closed range [left..right] interval  <a href="classbm_1_1sparse__vector__scanner.html#af4db5cbc383399b813515f26c8b8df3d">More...</a><br /></td></tr>
<tr class="separator:af4db5cbc383399b813515f26c8b8df3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Find in bit-transposed string vector</h2></td></tr>
<tr class="memitem:aa632f8ed94aff9ed03404a0e105619ef"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1sparse__vector__scanner.html#aa632f8ed94aff9ed03404a0e105619ef">search_algo_params</a> { <a class="el" href="classbm_1_1sparse__vector__scanner.html#aa632f8ed94aff9ed03404a0e105619efa25a923abcc75193bf0adc1fd75dd2673">linear_cutoff1</a> = 16
, <a class="el" href="classbm_1_1sparse__vector__scanner.html#aa632f8ed94aff9ed03404a0e105619efae6b47b4a298c7ca93c979ccd426b343e">linear_cutoff2</a> = 128
 }</td></tr>
<tr class="separator:aa632f8ed94aff9ed03404a0e105619ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a782b794ead9619daef2779d8723f05b7"><td class="memItemLeft" align="right" valign="top"><a id="a782b794ead9619daef2779d8723f05b7"></a>
typedef bm::dynamic_heap_matrix&lt; <a class="el" href="classbm_1_1sparse__vector__scanner.html#a3890a7946df47e738cd7e3496b78f767">value_type</a>, <a class="el" href="classbm_1_1sparse__vector__scanner.html#a440260db6e476e16e71dda438e18b187">allocator_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>heap_matrix_type</b></td></tr>
<tr class="separator:a782b794ead9619daef2779d8723f05b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57562e76705f914b71b8adb83ed234ff"><td class="memItemLeft" align="right" valign="top"><a id="a57562e76705f914b71b8adb83ed234ff"></a>
typedef bm::dynamic_heap_matrix&lt; <a class="el" href="classbm_1_1sparse__vector__scanner.html#a3890a7946df47e738cd7e3496b78f767">value_type</a>, <a class="el" href="classbm_1_1sparse__vector__scanner.html#a440260db6e476e16e71dda438e18b187">allocator_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>matrix_search_buf_type</b></td></tr>
<tr class="separator:a57562e76705f914b71b8adb83ed234ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af972ef486485de3b3a76503e63bf5f1c"><td class="memItemLeft" align="right" valign="top"><a id="af972ef486485de3b3a76503e63bf5f1c"></a>
typedef bm::heap_vector&lt; <a class="el" href="namespacebm.html#a933991b5bb4ce62227584037909e9195">bm::id64_t</a>, typename <a class="el" href="classbm_1_1bvector.html#ad1dbe63690fd5cd2b1e064795d3f1b6c">bvector_type::allocator_type</a>, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>mask_vector_type</b></td></tr>
<tr class="separator:af972ef486485de3b3a76503e63bf5f1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af84dcafdb4ee0eb1673b93bb52c72631"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1sparse__vector__scanner.html#af84dcafdb4ee0eb1673b93bb52c72631">find_eq_str</a> (const SV &amp;sv, const <a class="el" href="classbm_1_1sparse__vector__scanner.html#a3890a7946df47e738cd7e3496b78f767">value_type</a> *str, <a class="el" href="classbm_1_1sparse__vector__scanner.html#a2610acb19f7d9127c681d584ecf9e9ea">bvector_type</a> &amp;bv_out)</td></tr>
<tr class="memdesc:af84dcafdb4ee0eb1673b93bb52c72631"><td class="mdescLeft">&#160;</td><td class="mdescRight">find sparse vector elements (string)  <a href="classbm_1_1sparse__vector__scanner.html#af84dcafdb4ee0eb1673b93bb52c72631">More...</a><br /></td></tr>
<tr class="separator:af84dcafdb4ee0eb1673b93bb52c72631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66a3466fd6b0db61c76fc0bb1c17e962"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1sparse__vector__scanner.html#a66a3466fd6b0db61c76fc0bb1c17e962">find_eq_str</a> (const <a class="el" href="classbm_1_1sparse__vector__scanner.html#a3890a7946df47e738cd7e3496b78f767">value_type</a> *str, <a class="el" href="classbm_1_1sparse__vector__scanner.html#a2610acb19f7d9127c681d584ecf9e9ea">bvector_type</a> &amp;bv_out)</td></tr>
<tr class="memdesc:a66a3466fd6b0db61c76fc0bb1c17e962"><td class="mdescLeft">&#160;</td><td class="mdescRight">find sparse vector elementa (string) in the attached SV  <a href="classbm_1_1sparse__vector__scanner.html#a66a3466fd6b0db61c76fc0bb1c17e962">More...</a><br /></td></tr>
<tr class="separator:a66a3466fd6b0db61c76fc0bb1c17e962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3b0e645f5eb33647a3ccf12f1b01c35"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1sparse__vector__scanner.html#ac3b0e645f5eb33647a3ccf12f1b01c35">find_eq_str</a> (const SV &amp;sv, const <a class="el" href="classbm_1_1sparse__vector__scanner.html#a3890a7946df47e738cd7e3496b78f767">value_type</a> *str, <a class="el" href="classbm_1_1sparse__vector__scanner.html#a5856b08009c13a4683c8fc4566bdf89c">size_type</a> &amp;pos)</td></tr>
<tr class="memdesc:ac3b0e645f5eb33647a3ccf12f1b01c35"><td class="mdescLeft">&#160;</td><td class="mdescRight">find first sparse vector element (string)  <a href="classbm_1_1sparse__vector__scanner.html#ac3b0e645f5eb33647a3ccf12f1b01c35">More...</a><br /></td></tr>
<tr class="separator:ac3b0e645f5eb33647a3ccf12f1b01c35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa8ee597d24dae81bc5e5d88cc3cfd2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1sparse__vector__scanner.html#a1fa8ee597d24dae81bc5e5d88cc3cfd2">find_eq_str</a> (const <a class="el" href="classbm_1_1sparse__vector__scanner.html#a3890a7946df47e738cd7e3496b78f767">value_type</a> *str, <a class="el" href="classbm_1_1sparse__vector__scanner.html#a5856b08009c13a4683c8fc4566bdf89c">size_type</a> &amp;pos)</td></tr>
<tr class="memdesc:a1fa8ee597d24dae81bc5e5d88cc3cfd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">binary find first sparse vector element (string) Sparse vector must be attached (<a class="el" href="classbm_1_1sparse__vector__scanner.html#aa5bd3464c5c0528ff168649413b5e7ee" title="bind sparse vector for all searches">bind()</a>)  <a href="classbm_1_1sparse__vector__scanner.html#a1fa8ee597d24dae81bc5e5d88cc3cfd2">More...</a><br /></td></tr>
<tr class="separator:a1fa8ee597d24dae81bc5e5d88cc3cfd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad19877c3b18ba5054d8e40f2d99f8cef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1sparse__vector__scanner.html#ad19877c3b18ba5054d8e40f2d99f8cef">find_eq_str_prefix</a> (const SV &amp;sv, const <a class="el" href="classbm_1_1sparse__vector__scanner.html#a3890a7946df47e738cd7e3496b78f767">value_type</a> *str, <a class="el" href="classbm_1_1sparse__vector__scanner.html#a2610acb19f7d9127c681d584ecf9e9ea">bvector_type</a> &amp;bv_out)</td></tr>
<tr class="memdesc:ad19877c3b18ba5054d8e40f2d99f8cef"><td class="mdescLeft">&#160;</td><td class="mdescRight">find sparse vector elements with a given prefix (string)  <a href="classbm_1_1sparse__vector__scanner.html#ad19877c3b18ba5054d8e40f2d99f8cef">More...</a><br /></td></tr>
<tr class="separator:ad19877c3b18ba5054d8e40f2d99f8cef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afae57733f1ff13d74563af27337e31fb"><td class="memTemplParams" colspan="2">template&lt;class TPipe &gt; </td></tr>
<tr class="memitem:afae57733f1ff13d74563af27337e31fb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbm_1_1sparse__vector__scanner.html#afae57733f1ff13d74563af27337e31fb">find_eq_str</a> (TPipe &amp;pipe)</td></tr>
<tr class="memdesc:afae57733f1ff13d74563af27337e31fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">find sparse vector elements using search pipeline  <a href="classbm_1_1sparse__vector__scanner.html#afae57733f1ff13d74563af27337e31fb">More...</a><br /></td></tr>
<tr class="separator:afae57733f1ff13d74563af27337e31fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a649e0de499fe7cd3014c63b69c7de092"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1sparse__vector__scanner.html#a649e0de499fe7cd3014c63b69c7de092">bfind_eq_str</a> (const SV &amp;sv, const <a class="el" href="classbm_1_1sparse__vector__scanner.html#a3890a7946df47e738cd7e3496b78f767">value_type</a> *str, <a class="el" href="classbm_1_1sparse__vector__scanner.html#a5856b08009c13a4683c8fc4566bdf89c">size_type</a> &amp;pos)</td></tr>
<tr class="memdesc:a649e0de499fe7cd3014c63b69c7de092"><td class="mdescLeft">&#160;</td><td class="mdescRight">binary find first sparse vector element (string) <br  />
 Sparse vector must be sorted.  <a href="classbm_1_1sparse__vector__scanner.html#a649e0de499fe7cd3014c63b69c7de092">More...</a><br /></td></tr>
<tr class="separator:a649e0de499fe7cd3014c63b69c7de092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcea3d6c5050f0d8a34872ea09830b6b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1sparse__vector__scanner.html#adcea3d6c5050f0d8a34872ea09830b6b">lower_bound_str</a> (const SV &amp;sv, const <a class="el" href="classbm_1_1sparse__vector__scanner.html#a3890a7946df47e738cd7e3496b78f767">value_type</a> *str, <a class="el" href="classbm_1_1sparse__vector__scanner.html#a5856b08009c13a4683c8fc4566bdf89c">size_type</a> &amp;pos)</td></tr>
<tr class="memdesc:adcea3d6c5050f0d8a34872ea09830b6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">lower bound search for an array position  <a href="classbm_1_1sparse__vector__scanner.html#adcea3d6c5050f0d8a34872ea09830b6b">More...</a><br /></td></tr>
<tr class="separator:adcea3d6c5050f0d8a34872ea09830b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a308a2bb116117741b490c0af07803fe0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1sparse__vector__scanner.html#a308a2bb116117741b490c0af07803fe0">bfind_eq_str</a> (const <a class="el" href="classbm_1_1sparse__vector__scanner.html#a3890a7946df47e738cd7e3496b78f767">value_type</a> *str, <a class="el" href="classbm_1_1sparse__vector__scanner.html#a5856b08009c13a4683c8fc4566bdf89c">size_type</a> &amp;pos)</td></tr>
<tr class="memdesc:a308a2bb116117741b490c0af07803fe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">binary find first sparse vector element (string) Sparse vector must be sorted and attached  <a href="classbm_1_1sparse__vector__scanner.html#a308a2bb116117741b490c0af07803fe0">More...</a><br /></td></tr>
<tr class="separator:a308a2bb116117741b490c0af07803fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f64aeebe7d6a3b378dea86f5ecb502c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1sparse__vector__scanner.html#a5f64aeebe7d6a3b378dea86f5ecb502c">find_zero</a> (const SV &amp;sv, <a class="el" href="classbm_1_1sparse__vector__scanner.html#a2610acb19f7d9127c681d584ecf9e9ea">bvector_type</a> &amp;bv_out, bool null_correct=true)</td></tr>
<tr class="memdesc:a5f64aeebe7d6a3b378dea86f5ecb502c"><td class="mdescLeft">&#160;</td><td class="mdescRight">find all sparse vector elements EQ to 0  <a href="classbm_1_1sparse__vector__scanner.html#a5f64aeebe7d6a3b378dea86f5ecb502c">More...</a><br /></td></tr>
<tr class="separator:a5f64aeebe7d6a3b378dea86f5ecb502c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e9639918d1fb60c0f84b098be001049"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1sparse__vector__scanner.html#a9e9639918d1fb60c0f84b098be001049">find_nonzero</a> (const SV &amp;sv, <a class="el" href="classbm_1_1sparse__vector__scanner.html#a2610acb19f7d9127c681d584ecf9e9ea">bvector_type</a> &amp;bv_out)</td></tr>
<tr class="memdesc:a9e9639918d1fb60c0f84b098be001049"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find non-zero elements Output vector is computed as a logical OR (join) of all planes.  <a href="classbm_1_1sparse__vector__scanner.html#a9e9639918d1fb60c0f84b098be001049">More...</a><br /></td></tr>
<tr class="separator:a9e9639918d1fb60c0f84b098be001049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf5b4cb9a5fb20ab482f403f9ee9a3ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1sparse__vector__scanner.html#acf5b4cb9a5fb20ab482f403f9ee9a3ee">find_positive</a> (const SV &amp;sv, <a class="el" href="classbm_1_1sparse__vector__scanner.html#a2610acb19f7d9127c681d584ecf9e9ea">bvector_type</a> &amp;bv_out)</td></tr>
<tr class="memdesc:acf5b4cb9a5fb20ab482f403f9ee9a3ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find positive (greter than zero elements) Output vector is computed as a logical OR (join) of all planes.  <a href="classbm_1_1sparse__vector__scanner.html#acf5b4cb9a5fb20ab482f403f9ee9a3ee">More...</a><br /></td></tr>
<tr class="separator:acf5b4cb9a5fb20ab482f403f9ee9a3ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69e62acaeac6d53bee042d076db2e1e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1sparse__vector__scanner.html#a69e62acaeac6d53bee042d076db2e1e3">invert</a> (const SV &amp;sv, <a class="el" href="classbm_1_1sparse__vector__scanner.html#a2610acb19f7d9127c681d584ecf9e9ea">bvector_type</a> &amp;bv_out)</td></tr>
<tr class="memdesc:a69e62acaeac6d53bee042d076db2e1e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">invert search result ("EQ" to "not EQ")  <a href="classbm_1_1sparse__vector__scanner.html#a69e62acaeac6d53bee042d076db2e1e3">More...</a><br /></td></tr>
<tr class="separator:a69e62acaeac6d53bee042d076db2e1e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2846903f674a6a276942b3ac35207da0"><td class="memTemplParams" colspan="2">template&lt;typename It &gt; </td></tr>
<tr class="memitem:a2846903f674a6a276942b3ac35207da0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbm_1_1sparse__vector__scanner.html#a2846903f674a6a276942b3ac35207da0">find_eq</a> (const SV &amp;sv, It start, It end, <a class="el" href="classbm_1_1sparse__vector__scanner.html#a2610acb19f7d9127c681d584ecf9e9ea">bvector_type</a> &amp;bv_out)</td></tr>
<tr class="memdesc:a2846903f674a6a276942b3ac35207da0"><td class="mdescLeft">&#160;</td><td class="mdescRight">find all values A IN (C, D, E, F)  <a href="classbm_1_1sparse__vector__scanner.html#a2846903f674a6a276942b3ac35207da0">More...</a><br /></td></tr>
<tr class="separator:a2846903f674a6a276942b3ac35207da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e79e776b3e5c9cc3aca005a8511d09f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1sparse__vector__scanner.html#a5e79e776b3e5c9cc3aca005a8511d09f">find_eq_with_nulls_horizontal</a> (const SV &amp;sv, <a class="el" href="classbm_1_1sparse__vector__scanner.html#a3890a7946df47e738cd7e3496b78f767">value_type</a> value, <a class="el" href="classbm_1_1sparse__vector__scanner.html#a2610acb19f7d9127c681d584ecf9e9ea">bvector_type</a> &amp;bv_out)</td></tr>
<tr class="memdesc:a5e79e776b3e5c9cc3aca005a8511d09f"><td class="mdescLeft">&#160;</td><td class="mdescRight">For testing purposes only.  <a href="classbm_1_1sparse__vector__scanner.html#a5e79e776b3e5c9cc3aca005a8511d09f">More...</a><br /></td></tr>
<tr class="separator:a5e79e776b3e5c9cc3aca005a8511d09f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ea82c93f2123f4f8f687ab29cec1490"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1sparse__vector__scanner.html#a6ea82c93f2123f4f8f687ab29cec1490">find_gt_horizontal</a> (const SV &amp;sv, <a class="el" href="classbm_1_1sparse__vector__scanner.html#a3890a7946df47e738cd7e3496b78f767">value_type</a> value, <a class="el" href="classbm_1_1sparse__vector__scanner.html#a2610acb19f7d9127c681d584ecf9e9ea">bvector_type</a> &amp;bv_out, bool null_correct=true)</td></tr>
<tr class="memdesc:a6ea82c93f2123f4f8f687ab29cec1490"><td class="mdescLeft">&#160;</td><td class="mdescRight">For testing purposes only.  <a href="classbm_1_1sparse__vector__scanner.html#a6ea82c93f2123f4f8f687ab29cec1490">More...</a><br /></td></tr>
<tr class="separator:a6ea82c93f2123f4f8f687ab29cec1490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a431a9e5f34464de0700c780a0034c65d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1sparse__vector__scanner.html#a431a9e5f34464de0700c780a0034c65d">correct_nulls</a> (const SV &amp;sv, <a class="el" href="classbm_1_1sparse__vector__scanner.html#a2610acb19f7d9127c681d584ecf9e9ea">bvector_type</a> &amp;bv_out)</td></tr>
<tr class="memdesc:a431a9e5f34464de0700c780a0034c65d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exclude possible NULL values from the result vector.  <a href="classbm_1_1sparse__vector__scanner.html#a431a9e5f34464de0700c780a0034c65d">More...</a><br /></td></tr>
<tr class="separator:a431a9e5f34464de0700c780a0034c65d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcdfc9aabb7e74ffba05a8be5ca3f8fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbm_1_1sparse__vector__scanner.html#aa2f5ebd37c06d9a8b69d2a26efaac638">allocator_pool_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1sparse__vector__scanner.html#afcdfc9aabb7e74ffba05a8be5ca3f8fd">get_bvector_alloc_pool</a> () <a class="el" href="bmdef_8h.html#a40d7d3c011d2128b1f0c392127d7d61e">BMNOEXCEPT</a></td></tr>
<tr class="memdesc:afcdfc9aabb7e74ffba05a8be5ca3f8fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return allocator pool for blocks (Can be used to improve performance of repeated searches with the same scanner)  <a href="classbm_1_1sparse__vector__scanner.html#afcdfc9aabb7e74ffba05a8be5ca3f8fd">More...</a><br /></td></tr>
<tr class="separator:afcdfc9aabb7e74ffba05a8be5ca3f8fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49e339edeaf9b57fa19e10d94f2162b9"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1sparse__vector__scanner.html#a49e339edeaf9b57fa19e10d94f2162b9">remap_tosv</a> (<a class="el" href="classbm_1_1sparse__vector__scanner.html#a653fbc8c97f4699d6879b12ad42f9838">remap_vector_type</a> &amp;remap_vect_target, const <a class="el" href="classbm_1_1sparse__vector__scanner.html#a3890a7946df47e738cd7e3496b78f767">value_type</a> *str, const SV &amp;sv)</td></tr>
<tr class="memdesc:a49e339edeaf9b57fa19e10d94f2162b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remap input value into SV char encodings.  <a href="classbm_1_1sparse__vector__scanner.html#a49e339edeaf9b57fa19e10d94f2162b9">More...</a><br /></td></tr>
<tr class="separator:a49e339edeaf9b57fa19e10d94f2162b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd3aa98485f123d01cfa176f8ce33a2c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1sparse__vector__scanner.html#afd3aa98485f123d01cfa176f8ce33a2c">aggregate_AND_OR_slices</a> (<a class="el" href="classbm_1_1sparse__vector__scanner.html#a2610acb19f7d9127c681d584ecf9e9ea">bvector_type</a> &amp;bv_target, const <a class="el" href="classbm_1_1sparse__vector__scanner.html#a2610acb19f7d9127c681d584ecf9e9ea">bvector_type</a> &amp;bv_mask, const SV &amp;sv, unsigned from, unsigned total_planes)</td></tr>
<tr class="memdesc:afd3aa98485f123d01cfa176f8ce33a2c"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="classbm_1_1sparse__vector__scanner.html#afd3aa98485f123d01cfa176f8ce33a2c">More...</a><br /></td></tr>
<tr class="separator:afd3aa98485f123d01cfa176f8ce33a2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa041f214a89bebea528c8539933fb423"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1sparse__vector__scanner.html#aa041f214a89bebea528c8539933fb423">gt_slice_limit</a> () noexcept</td></tr>
<tr class="memdesc:aa041f214a89bebea528c8539933fb423"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the slice limit for signed/unsigned vector value types.  <a href="classbm_1_1sparse__vector__scanner.html#aa041f214a89bebea528c8539933fb423">More...</a><br /></td></tr>
<tr class="separator:aa041f214a89bebea528c8539933fb423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab09d4397a865dda07bb0e35c42c5df6d"><td class="memTemplParams" colspan="2">template&lt;typename AGG &gt; </td></tr>
<tr class="memitem:ab09d4397a865dda07bb0e35c42c5df6d"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbm_1_1sparse__vector__scanner.html#ab09d4397a865dda07bb0e35c42c5df6d">add_agg_char</a> (AGG &amp;agg, const SV &amp;sv, int octet_idx, <a class="el" href="namespacebm.html#a933991b5bb4ce62227584037909e9195">bm::id64_t</a> planes_mask, unsigned value)</td></tr>
<tr class="memdesc:ab09d4397a865dda07bb0e35c42c5df6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addd char to aggregator (AND-SUB)  <a href="classbm_1_1sparse__vector__scanner.html#ab09d4397a865dda07bb0e35c42c5df6d">More...</a><br /></td></tr>
<tr class="separator:ab09d4397a865dda07bb0e35c42c5df6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9526c0f803b23408420e2eaf8eec10e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1sparse__vector__scanner.html#ae9526c0f803b23408420e2eaf8eec10e">set_search_range</a> (<a class="el" href="classbm_1_1sparse__vector__scanner.html#a5856b08009c13a4683c8fc4566bdf89c">size_type</a> from, <a class="el" href="classbm_1_1sparse__vector__scanner.html#a5856b08009c13a4683c8fc4566bdf89c">size_type</a> to)</td></tr>
<tr class="memdesc:ae9526c0f803b23408420e2eaf8eec10e"><td class="mdescLeft">&#160;</td><td class="mdescRight">set search boundaries (hint for the aggregator)  <a href="classbm_1_1sparse__vector__scanner.html#ae9526c0f803b23408420e2eaf8eec10e">More...</a><br /></td></tr>
<tr class="separator:ae9526c0f803b23408420e2eaf8eec10e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea7e56e787292e325c3f1d68e1e15b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1sparse__vector__scanner.html#acea7e56e787292e325c3f1d68e1e15b6">reset_search_range</a> ()</td></tr>
<tr class="memdesc:acea7e56e787292e325c3f1d68e1e15b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">reset (disable) search range  <a href="classbm_1_1sparse__vector__scanner.html#acea7e56e787292e325c3f1d68e1e15b6">More...</a><br /></td></tr>
<tr class="separator:acea7e56e787292e325c3f1d68e1e15b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4564161d1c4941f94c1cbd15e981377b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1sparse__vector__scanner.html#a4564161d1c4941f94c1cbd15e981377b">find_eq_with_nulls</a> (const SV &amp;sv, <a class="el" href="classbm_1_1sparse__vector__scanner.html#a3890a7946df47e738cd7e3496b78f767">value_type</a> value, <a class="el" href="classbm_1_1sparse__vector__scanner.html#a2610acb19f7d9127c681d584ecf9e9ea">bvector_type</a> &amp;bv_out, <a class="el" href="classbm_1_1sparse__vector__scanner.html#a5856b08009c13a4683c8fc4566bdf89c">size_type</a> search_limit=0)</td></tr>
<tr class="memdesc:a4564161d1c4941f94c1cbd15e981377b"><td class="mdescLeft">&#160;</td><td class="mdescRight">find value (may include NULL indexes)  <a href="classbm_1_1sparse__vector__scanner.html#a4564161d1c4941f94c1cbd15e981377b">More...</a><br /></td></tr>
<tr class="separator:a4564161d1c4941f94c1cbd15e981377b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a584cef9598e42f5c658028c2bf074c2e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1sparse__vector__scanner.html#a584cef9598e42f5c658028c2bf074c2e">find_first_eq</a> (const SV &amp;sv, <a class="el" href="classbm_1_1sparse__vector__scanner.html#a3890a7946df47e738cd7e3496b78f767">value_type</a> value, <a class="el" href="classbm_1_1sparse__vector__scanner.html#a5856b08009c13a4683c8fc4566bdf89c">size_type</a> &amp;idx)</td></tr>
<tr class="memdesc:a584cef9598e42f5c658028c2bf074c2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">find first value (may include NULL indexes)  <a href="classbm_1_1sparse__vector__scanner.html#a584cef9598e42f5c658028c2bf074c2e">More...</a><br /></td></tr>
<tr class="separator:a584cef9598e42f5c658028c2bf074c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e65e170dfd3e3449f80bc32d358e747"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1sparse__vector__scanner.html#a0e65e170dfd3e3449f80bc32d358e747">find_first_eq</a> (const SV &amp;sv, const <a class="el" href="classbm_1_1sparse__vector__scanner.html#a3890a7946df47e738cd7e3496b78f767">value_type</a> *str, <a class="el" href="classbm_1_1sparse__vector__scanner.html#a5856b08009c13a4683c8fc4566bdf89c">size_type</a> &amp;idx, bool remaped)</td></tr>
<tr class="memdesc:a0e65e170dfd3e3449f80bc32d358e747"><td class="mdescLeft">&#160;</td><td class="mdescRight">find first string value (may include NULL indexes)  <a href="classbm_1_1sparse__vector__scanner.html#a0e65e170dfd3e3449f80bc32d358e747">More...</a><br /></td></tr>
<tr class="separator:a0e65e170dfd3e3449f80bc32d358e747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ecfd0fc4a6d8a3c62b086979989df88"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1sparse__vector__scanner.html#a2ecfd0fc4a6d8a3c62b086979989df88">find_eq_str_impl</a> (const SV &amp;sv, const <a class="el" href="classbm_1_1sparse__vector__scanner.html#a3890a7946df47e738cd7e3496b78f767">value_type</a> *str, <a class="el" href="classbm_1_1sparse__vector__scanner.html#a2610acb19f7d9127c681d584ecf9e9ea">bvector_type</a> &amp;bv_out, bool prefix_sub)</td></tr>
<tr class="memdesc:a2ecfd0fc4a6d8a3c62b086979989df88"><td class="mdescLeft">&#160;</td><td class="mdescRight">find EQ str / prefix impl  <a href="classbm_1_1sparse__vector__scanner.html#a2ecfd0fc4a6d8a3c62b086979989df88">More...</a><br /></td></tr>
<tr class="separator:a2ecfd0fc4a6d8a3c62b086979989df88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a454a1aa3b0948b2bec784b27a7a26849"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1sparse__vector__scanner.html#a454a1aa3b0948b2bec784b27a7a26849">prepare_and_sub_aggregator</a> (const SV &amp;sv, <a class="el" href="classbm_1_1sparse__vector__scanner.html#a3890a7946df47e738cd7e3496b78f767">value_type</a> value)</td></tr>
<tr class="memdesc:a454a1aa3b0948b2bec784b27a7a26849"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare aggregator for AND-SUB (EQ) search.  <a href="classbm_1_1sparse__vector__scanner.html#a454a1aa3b0948b2bec784b27a7a26849">More...</a><br /></td></tr>
<tr class="separator:a454a1aa3b0948b2bec784b27a7a26849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aec048117bfa28782bb25bcb7568501"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1sparse__vector__scanner.html#a5aec048117bfa28782bb25bcb7568501">prepare_and_sub_aggregator</a> (const SV &amp;sv, const <a class="el" href="classbm_1_1sparse__vector__scanner.html#a3890a7946df47e738cd7e3496b78f767">value_type</a> *str, unsigned octet_start, bool prefix_sub)</td></tr>
<tr class="memdesc:a5aec048117bfa28782bb25bcb7568501"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare aggregator for AND-SUB (EQ) search (string)  <a href="classbm_1_1sparse__vector__scanner.html#a5aec048117bfa28782bb25bcb7568501">More...</a><br /></td></tr>
<tr class="separator:a5aec048117bfa28782bb25bcb7568501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a861cf8ee190619cecadebd11af7751b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1sparse__vector__scanner.html#a861cf8ee190619cecadebd11af7751b5">decompress</a> (const SV &amp;sv, <a class="el" href="classbm_1_1sparse__vector__scanner.html#a2610acb19f7d9127c681d584ecf9e9ea">bvector_type</a> &amp;bv_out)</td></tr>
<tr class="memdesc:a861cf8ee190619cecadebd11af7751b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rank-Select decompression for RSC vectors.  <a href="classbm_1_1sparse__vector__scanner.html#a861cf8ee190619cecadebd11af7751b5">More...</a><br /></td></tr>
<tr class="separator:a861cf8ee190619cecadebd11af7751b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2cfa4aed0d6a80da6cc2e4fdd65e5df"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1sparse__vector__scanner.html#ae2cfa4aed0d6a80da6cc2e4fdd65e5df">compare_str</a> (const SV &amp;sv, <a class="el" href="classbm_1_1sparse__vector__scanner.html#a5856b08009c13a4683c8fc4566bdf89c">size_type</a> idx, const <a class="el" href="classbm_1_1sparse__vector__scanner.html#a3890a7946df47e738cd7e3496b78f767">value_type</a> *str)</td></tr>
<tr class="memdesc:ae2cfa4aed0d6a80da6cc2e4fdd65e5df"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare sv[idx] with input str  <a href="classbm_1_1sparse__vector__scanner.html#ae2cfa4aed0d6a80da6cc2e4fdd65e5df">More...</a><br /></td></tr>
<tr class="separator:ae2cfa4aed0d6a80da6cc2e4fdd65e5df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f02bb5b11ae61afb6df4adfd3bbf9e5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1sparse__vector__scanner.html#a6f02bb5b11ae61afb6df4adfd3bbf9e5">compare</a> (const SV &amp;sv, <a class="el" href="classbm_1_1sparse__vector__scanner.html#a5856b08009c13a4683c8fc4566bdf89c">size_type</a> idx, const <a class="el" href="classbm_1_1sparse__vector__scanner.html#a3890a7946df47e738cd7e3496b78f767">value_type</a> val) <a class="el" href="bmdef_8h.html#a40d7d3c011d2128b1f0c392127d7d61e">BMNOEXCEPT</a></td></tr>
<tr class="memdesc:a6f02bb5b11ae61afb6df4adfd3bbf9e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare sv[idx] with input value  <a href="classbm_1_1sparse__vector__scanner.html#a6f02bb5b11ae61afb6df4adfd3bbf9e5">More...</a><br /></td></tr>
<tr class="separator:a6f02bb5b11ae61afb6df4adfd3bbf9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af660be5edfcf7e5e37c9fd27beeeea0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1sparse__vector__scanner.html#af660be5edfcf7e5e37c9fd27beeeea0b">aggregate_OR_slices</a> (<a class="el" href="classbm_1_1sparse__vector__scanner.html#a2610acb19f7d9127c681d584ecf9e9ea">bvector_type</a> &amp;bv_target, const SV &amp;sv, unsigned from, unsigned total_planes)</td></tr>
<tr class="memdesc:af660be5edfcf7e5e37c9fd27beeeea0b"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="classbm_1_1sparse__vector__scanner.html#af660be5edfcf7e5e37c9fd27beeeea0b">More...</a><br /></td></tr>
<tr class="separator:af660be5edfcf7e5e37c9fd27beeeea0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c6fd3b4fe1b0da5a7e61478bf0f4c01"><td class="memItemLeft" align="right" valign="top"><a id="a6c6fd3b4fe1b0da5a7e61478bf0f4c01"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>sparse_vector_scanner</b> (const <a class="el" href="classbm_1_1sparse__vector__scanner.html">sparse_vector_scanner</a> &amp;)=delete</td></tr>
<tr class="separator:a6c6fd3b4fe1b0da5a7e61478bf0f4c01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87f7004f0d398a3180a186b95f677f73"><td class="memItemLeft" align="right" valign="top"><a id="a87f7004f0d398a3180a186b95f677f73"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classbm_1_1sparse__vector__scanner.html">sparse_vector_scanner</a> &amp;)=delete</td></tr>
<tr class="separator:a87f7004f0d398a3180a186b95f677f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename SV&gt;<br />
class bm::sparse_vector_scanner&lt; SV &gt;</div><p >algorithms for <a class="el" href="classbm_1_1sparse__vector.html" title="succinct sparse vector with runtime compression using bit-slicing / transposition method">sparse_vector</a> scan/search </p>
<p >Scanner uses properties of bit-vector planes to answer questions like "find all sparse vector elements equivalent to XYZ".</p>
<p >Class uses fast algorithms based on properties of bit-planes. This is NOT a brute force, direct scan, scanner uses search space pruning and cache optimizations to run the search. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="strsvsample02_8cpp-example.html#_a6">strsvsample02.cpp</a>, <a class="el" href="strsvsample06_8cpp-example.html#_a21">strsvsample06.cpp</a>, <a class="el" href="strsvsample07_8cpp-example.html#_a11">strsvsample07.cpp</a>, <a class="el" href="svsample06_8cpp-example.html#_a25">svsample06.cpp</a>, <a class="el" href="svsample07_8cpp-example.html#_a5">svsample07.cpp</a>, <a class="el" href="svsample07a_8cpp-example.html#_a13">svsample07a.cpp</a>, <a class="el" href="svsample10_8cpp-example.html#_a8">svsample10.cpp</a>, <a class="el" href="xsample03_8cpp-example.html#_a39">xsample03.cpp</a>, <a class="el" href="xsample05_8cpp-example.html#_a30">xsample05.cpp</a>, and <a class="el" href="xsample07_8cpp-example.html#_a62">xsample07.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bmsparsevec__algo_8h_source.html#l00499">499</a> of file <a class="el" href="bmsparsevec__algo_8h_source.html">bmsparsevec_algo.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="afbc9bc081ef214932b3debb741c51a0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbc9bc081ef214932b3debb741c51a0d">&#9670;&nbsp;</a></span>run_options</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef aggregator_type::run_options <a class="el" href="classbm_1_1sparse__vector__scanner.html">bm::sparse_vector_scanner</a>&lt; SV &gt;::<a class="el" href="classbm_1_1sparse__vector__scanner.html#afbc9bc081ef214932b3debb741c51a0d">run_options</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scanner options to control execution. </p>

<p class="definition">Definition at line <a class="el" href="bmsparsevec__algo_8h_source.html#l00524">524</a> of file <a class="el" href="bmsparsevec__algo_8h_source.html">bmsparsevec_algo.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="aa632f8ed94aff9ed03404a0e105619ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa632f8ed94aff9ed03404a0e105619ef">&#9670;&nbsp;</a></span>search_algo_params</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SV &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classbm_1_1sparse__vector__scanner.html#aa632f8ed94aff9ed03404a0e105619ef">bm::sparse_vector_scanner::search_algo_params</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa632f8ed94aff9ed03404a0e105619efa25a923abcc75193bf0adc1fd75dd2673"></a>linear_cutoff1&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa632f8ed94aff9ed03404a0e105619efae6b47b4a298c7ca93c979ccd426b343e"></a>linear_cutoff2&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="bmsparsevec__algo_8h_source.html#l01010">1010</a> of file <a class="el" href="bmsparsevec__algo_8h_source.html">bmsparsevec_algo.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab09d4397a865dda07bb0e35c42c5df6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab09d4397a865dda07bb0e35c42c5df6d">&#9670;&nbsp;</a></span>add_agg_char()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SV &gt; </div>
<div class="memtemplate">
template&lt;typename AGG &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classbm_1_1sparse__vector__scanner.html">bm::sparse_vector_scanner</a>&lt; SV &gt;::add_agg_char </td>
          <td>(</td>
          <td class="paramtype">AGG &amp;&#160;</td>
          <td class="paramname"><em>agg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SV &amp;&#160;</td>
          <td class="paramname"><em>sv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>octet_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacebm.html#a933991b5bb4ce62227584037909e9195">bm::id64_t</a>&#160;</td>
          <td class="paramname"><em>planes_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addd char to aggregator (AND-SUB) </p>

<p class="definition">Definition at line <a class="el" href="bmsparsevec__algo_8h_source.html#l01028">1028</a> of file <a class="el" href="bmsparsevec__algo_8h_source.html">bmsparsevec_algo.h</a>.</p>

<p class="reference">References <a class="el" href="bmfunc_8h_source.html#l00752">bm::bitscan()</a>, <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>, and <a class="el" href="bmutil_8h_source.html#l00575">bm::word_bitcount()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bmsparsevec__algo_8h_source.html#l02912">bm::sparse_vector_scanner&lt; SV &gt;::pipeline&lt; Opt &gt;::add()</a>.</p>

</div>
</div>
<a id="afd3aa98485f123d01cfa176f8ce33a2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd3aa98485f123d01cfa176f8ce33a2c">&#9670;&nbsp;</a></span>aggregate_AND_OR_slices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SV &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1sparse__vector__scanner.html">bm::sparse_vector_scanner</a>&lt; SV &gt;::aggregate_AND_OR_slices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbm_1_1sparse__vector__scanner.html#a2610acb19f7d9127c681d584ecf9e9ea">bvector_type</a> &amp;&#160;</td>
          <td class="paramname"><em>bv_target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbm_1_1sparse__vector__scanner.html#a2610acb19f7d9127c681d584ecf9e9ea">bvector_type</a> &amp;&#160;</td>
          <td class="paramname"><em>bv_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SV &amp;&#160;</td>
          <td class="paramname"><em>sv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>total_planes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bmsparsevec__algo_8h_source.html#l02111">2111</a> of file <a class="el" href="bmsparsevec__algo_8h_source.html">bmsparsevec_algo.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>.</p>

</div>
</div>
<a id="af660be5edfcf7e5e37c9fd27beeeea0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af660be5edfcf7e5e37c9fd27beeeea0b">&#9670;&nbsp;</a></span>aggregate_OR_slices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SV &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1sparse__vector__scanner.html">bm::sparse_vector_scanner</a>&lt; SV &gt;::aggregate_OR_slices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbm_1_1sparse__vector__scanner.html#a2610acb19f7d9127c681d584ecf9e9ea">bvector_type</a> &amp;&#160;</td>
          <td class="paramname"><em>bv_target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SV &amp;&#160;</td>
          <td class="paramname"><em>sv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>total_planes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bmsparsevec__algo_8h_source.html#l02092">2092</a> of file <a class="el" href="bmsparsevec__algo_8h_source.html">bmsparsevec_algo.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>.</p>

</div>
</div>
<a id="ab6ff77cf057f81c1689af3dfd98723b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6ff77cf057f81c1689af3dfd98723b2">&#9670;&nbsp;</a></span>bfind()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1sparse__vector__scanner.html">bm::sparse_vector_scanner</a>&lt; SV &gt;::bfind </td>
          <td>(</td>
          <td class="paramtype">const SV &amp;&#160;</td>
          <td class="paramname"><em>sv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbm_1_1sparse__vector__scanner.html#a3890a7946df47e738cd7e3496b78f767">value_type</a>&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename SV::size_type &amp;&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>binary search for position in the sorted sparse vector </p>
<p >Method assumes the sparse array is sorted, if value is found pos returns its index, if not found, pos would contain index where it could be inserted to maintain the order</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>- input sparse vector </td></tr>
    <tr><td class="paramname">val</td><td>- value to search for </td></tr>
    <tr><td class="paramname">pos</td><td>- output sparse vector element index (actual index if found or insertion point if not found)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if value found </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="svsample07_8cpp-example.html#a6">svsample07.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bmsparsevec__algo_8h_source.html#l02460">2460</a> of file <a class="el" href="bmsparsevec__algo_8h_source.html">bmsparsevec_algo.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>.</p>

<p class="reference">Referenced by <a class="el" href="svsample07_8cpp_source.html#l00072">insertion_sort()</a>.</p>

</div>
</div>
<a id="a649e0de499fe7cd3014c63b69c7de092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a649e0de499fe7cd3014c63b69c7de092">&#9670;&nbsp;</a></span>bfind_eq_str() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1sparse__vector__scanner.html">bm::sparse_vector_scanner</a>&lt; SV &gt;::bfind_eq_str </td>
          <td>(</td>
          <td class="paramtype">const SV &amp;&#160;</td>
          <td class="paramname"><em>sv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbm_1_1sparse__vector__scanner.html#a3890a7946df47e738cd7e3496b78f767">value_type</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1sparse__vector__scanner.html#a5856b08009c13a4683c8fc4566bdf89c">size_type</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>binary find first sparse vector element (string) <br  />
 Sparse vector must be sorted. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="xsample05_8cpp-example.html#a33">xsample05.cpp</a>.</dd>
</dl>

<p class="reference">Referenced by <a class="el" href="xsample05_8cpp_source.html#l00318">run_benchmark()</a>.</p>

</div>
</div>
<a id="a308a2bb116117741b490c0af07803fe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a308a2bb116117741b490c0af07803fe0">&#9670;&nbsp;</a></span>bfind_eq_str() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1sparse__vector__scanner.html">bm::sparse_vector_scanner</a>&lt; SV &gt;::bfind_eq_str </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbm_1_1sparse__vector__scanner.html#a3890a7946df47e738cd7e3496b78f767">value_type</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1sparse__vector__scanner.html#a5856b08009c13a4683c8fc4566bdf89c">size_type</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>binary find first sparse vector element (string) Sparse vector must be sorted and attached </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbm_1_1sparse__vector__scanner.html#aa5bd3464c5c0528ff168649413b5e7ee" title="bind sparse vector for all searches">bind</a> </dd></dl>

</div>
</div>
<a id="aa5bd3464c5c0528ff168649413b5e7ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5bd3464c5c0528ff168649413b5e7ee">&#9670;&nbsp;</a></span>bind()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1sparse__vector__scanner.html">bm::sparse_vector_scanner</a>&lt; SV &gt;::bind </td>
          <td>(</td>
          <td class="paramtype">const SV &amp;&#160;</td>
          <td class="paramname"><em>sv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sorted</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>bind sparse vector for all searches </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>- input sparse vector to bind for searches </td></tr>
    <tr><td class="paramname">sorted</td><td>- source index is sorted, build index for binary search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="svsample07a_8cpp-example.html#a14">svsample07a.cpp</a>, and <a class="el" href="xsample05_8cpp-example.html#a32">xsample05.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bmsparsevec__algo_8h_source.html#l01448">1448</a> of file <a class="el" href="bmsparsevec__algo_8h_source.html">bmsparsevec_algo.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>, <a class="el" href="bmconst_8h_source.html#l00081">bm::gap_max_bits</a>, <a class="el" href="bmconst_8h_source.html#l00056">bm::set_block_shift</a>, and <a class="el" href="bmconst_8h_source.html#l00126">bm::sub_block3_size</a>.</p>

<p class="reference">Referenced by <a class="el" href="svsample07a_8cpp_source.html#l00059">main()</a>, and <a class="el" href="xsample05_8cpp_source.html#l00318">run_benchmark()</a>.</p>

</div>
</div>
<a id="a6f02bb5b11ae61afb6df4adfd3bbf9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f02bb5b11ae61afb6df4adfd3bbf9e5">&#9670;&nbsp;</a></span>compare()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SV &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbm_1_1sparse__vector__scanner.html">bm::sparse_vector_scanner</a>&lt; SV &gt;::compare </td>
          <td>(</td>
          <td class="paramtype">const SV &amp;&#160;</td>
          <td class="paramname"><em>sv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1sparse__vector__scanner.html#a5856b08009c13a4683c8fc4566bdf89c">size_type</a>&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbm_1_1sparse__vector__scanner.html#a3890a7946df47e738cd7e3496b78f767">value_type</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compare sv[idx] with input value </p>

<p class="definition">Definition at line <a class="el" href="bmsparsevec__algo_8h_source.html#l02763">2763</a> of file <a class="el" href="bmsparsevec__algo_8h_source.html">bmsparsevec_algo.h</a>.</p>

</div>
</div>
<a id="ae2cfa4aed0d6a80da6cc2e4fdd65e5df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2cfa4aed0d6a80da6cc2e4fdd65e5df">&#9670;&nbsp;</a></span>compare_str()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SV &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbm_1_1sparse__vector__scanner.html">bm::sparse_vector_scanner</a>&lt; SV &gt;::compare_str </td>
          <td>(</td>
          <td class="paramtype">const SV &amp;&#160;</td>
          <td class="paramname"><em>sv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1sparse__vector__scanner.html#a5856b08009c13a4683c8fc4566bdf89c">size_type</a>&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbm_1_1sparse__vector__scanner.html#a3890a7946df47e738cd7e3496b78f767">value_type</a> *&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compare sv[idx] with input str </p>

<p class="definition">Definition at line <a class="el" href="bmsparsevec__algo_8h_source.html#l02714">2714</a> of file <a class="el" href="bmsparsevec__algo_8h_source.html">bmsparsevec_algo.h</a>.</p>

<p class="reference">References <a class="el" href="bmconst_8h_source.html#l00057">bm::set_block_mask</a>, <a class="el" href="bmconst_8h_source.html#l00056">bm::set_block_shift</a>, and <a class="el" href="bmconst_8h_source.html#l00126">bm::sub_block3_size</a>.</p>

</div>
</div>
<a id="a431a9e5f34464de0700c780a0034c65d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a431a9e5f34464de0700c780a0034c65d">&#9670;&nbsp;</a></span>correct_nulls()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1sparse__vector__scanner.html">bm::sparse_vector_scanner</a>&lt; SV &gt;::correct_nulls </td>
          <td>(</td>
          <td class="paramtype">const SV &amp;&#160;</td>
          <td class="paramname"><em>sv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1sparse__vector__scanner.html#a2610acb19f7d9127c681d584ecf9e9ea">bvector_type</a> &amp;&#160;</td>
          <td class="paramname"><em>bv_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exclude possible NULL values from the result vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>- input sparse vector </td></tr>
    <tr><td class="paramname">bv_out</td><td>- output bit-bector of non-zero elements </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bmsparsevec__algo_8h_source.html#l01561">1561</a> of file <a class="el" href="bmsparsevec__algo_8h_source.html">bmsparsevec_algo.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="bmsparsevec__algo_8h_source.html#l00874">bm::sparse_vector_scanner&lt; SV &gt;::find_eq()</a>.</p>

</div>
</div>
<a id="a861cf8ee190619cecadebd11af7751b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a861cf8ee190619cecadebd11af7751b5">&#9670;&nbsp;</a></span>decompress()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SV &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1sparse__vector__scanner.html">bm::sparse_vector_scanner</a>&lt; SV &gt;::decompress </td>
          <td>(</td>
          <td class="paramtype">const SV &amp;&#160;</td>
          <td class="paramname"><em>sv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="rscsample05_8cpp.html#a4ca03dfc387c36e69ea916426572acdc">SV::bvector_type</a> &amp;&#160;</td>
          <td class="paramname"><em>bv_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rank-Select decompression for RSC vectors. </p>

<p class="definition">Definition at line <a class="el" href="bmsparsevec__algo_8h_source.html#l02856">2856</a> of file <a class="el" href="bmsparsevec__algo_8h_source.html">bmsparsevec_algo.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>.</p>

</div>
</div>
<a id="a2846903f674a6a276942b3ac35207da0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2846903f674a6a276942b3ac35207da0">&#9670;&nbsp;</a></span>find_eq() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SV &gt; </div>
<div class="memtemplate">
template&lt;typename It &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1sparse__vector__scanner.html">bm::sparse_vector_scanner</a>&lt; SV &gt;::find_eq </td>
          <td>(</td>
          <td class="paramtype">const SV &amp;&#160;</td>
          <td class="paramname"><em>sv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1sparse__vector__scanner.html#a2610acb19f7d9127c681d584ecf9e9ea">bvector_type</a> &amp;&#160;</td>
          <td class="paramname"><em>bv_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find all values A IN (C, D, E, F) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>- input sparse vector </td></tr>
    <tr><td class="paramname">start</td><td>- start iterator (set to search) </td></tr>
    <tr><td class="paramname">end</td><td>- end iterator (set to search) </td></tr>
    <tr><td class="paramname">bv_out</td><td>- output bit-bector of non-zero elements </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bmsparsevec__algo_8h_source.html#l00874">874</a> of file <a class="el" href="bmsparsevec__algo_8h_source.html">bmsparsevec_algo.h</a>.</p>

<p class="reference">References <a class="el" href="bm_8h_source.html#l00807">bm::bvector&lt; Alloc &gt;::mem_pool_guard::assign_if_not_set()</a>, <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>, <a class="el" href="bmsparsevec__algo_8h_source.html#l01561">bm::sparse_vector_scanner&lt; SV &gt;::correct_nulls()</a>, and <a class="el" href="bmsparsevec__algo_8h_source.html#l01572">bm::sparse_vector_scanner&lt; SV &gt;::find_eq_with_nulls()</a>.</p>

</div>
</div>
<a id="a7fe9583056b9b1ff6bb2589ded6612b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fe9583056b9b1ff6bb2589ded6612b2">&#9670;&nbsp;</a></span>find_eq() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1sparse__vector__scanner.html">bm::sparse_vector_scanner</a>&lt; SV &gt;::find_eq </td>
          <td>(</td>
          <td class="paramtype">const SV &amp;&#160;</td>
          <td class="paramname"><em>sv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename SV::value_type&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="rscsample05_8cpp.html#a4ca03dfc387c36e69ea916426572acdc">SV::bvector_type</a> &amp;&#160;</td>
          <td class="paramname"><em>bv_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find all sparse vector elements EQ to search value </p>
<p >Find all sparse vector elements equivalent to specified value</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>- input sparse vector </td></tr>
    <tr><td class="paramname">value</td><td>- value to search for </td></tr>
    <tr><td class="paramname">bv_out</td><td>- search result bit-vector (search result is a vector of 1s when sv[i] == value) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="svsample06_8cpp-example.html#a26">svsample06.cpp</a>, <a class="el" href="svsample07a_8cpp-example.html#a22">svsample07a.cpp</a>, <a class="el" href="xsample03_8cpp-example.html#a40">xsample03.cpp</a>, and <a class="el" href="xsample07_8cpp-example.html#a63">xsample07.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bmsparsevec__algo_8h_source.html#l02774">2774</a> of file <a class="el" href="bmsparsevec__algo_8h_source.html">bmsparsevec_algo.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="xsample07_8cpp_source.html#l00905">compute_frequent_kmers()</a>, <a class="el" href="svsample06_8cpp_source.html#l00133">main()</a>, and <a class="el" href="xsample03_8cpp_source.html#l00349">run_benchmark()</a>.</p>

</div>
</div>
<a id="a5427018a1a713e5146dc97a2997bc9a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5427018a1a713e5146dc97a2997bc9a9">&#9670;&nbsp;</a></span>find_eq() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1sparse__vector__scanner.html">bm::sparse_vector_scanner</a>&lt; SV &gt;::find_eq </td>
          <td>(</td>
          <td class="paramtype">const SV &amp;&#160;</td>
          <td class="paramname"><em>sv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename SV::value_type&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename SV::size_type &amp;&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find first sparse vector element </p>
<p >Find all sparse vector elements equivalent to specified value. Works well if sperse vector represents unordered set</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>- input sparse vector </td></tr>
    <tr><td class="paramname">value</td><td>- value to search for </td></tr>
    <tr><td class="paramname">pos</td><td>- output found sparse vector element index</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if found </dd></dl>

<p class="definition">Definition at line <a class="el" href="bmsparsevec__algo_8h_source.html#l02798">2798</a> of file <a class="el" href="bmsparsevec__algo_8h_source.html">bmsparsevec_algo.h</a>.</p>

</div>
</div>
<a id="af84dcafdb4ee0eb1673b93bb52c72631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af84dcafdb4ee0eb1673b93bb52c72631">&#9670;&nbsp;</a></span>find_eq_str() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1sparse__vector__scanner.html">bm::sparse_vector_scanner</a>&lt; SV &gt;::find_eq_str </td>
          <td>(</td>
          <td class="paramtype">const SV &amp;&#160;</td>
          <td class="paramname"><em>sv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbm_1_1sparse__vector__scanner.html#a3890a7946df47e738cd7e3496b78f767">value_type</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1sparse__vector__scanner.html#a2610acb19f7d9127c681d584ecf9e9ea">bvector_type</a> &amp;&#160;</td>
          <td class="paramname"><em>bv_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find sparse vector elements (string) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>- sparse vector of strings to search </td></tr>
    <tr><td class="paramname">str</td><td>- string to search for </td></tr>
    <tr><td class="paramname">bv_out</td><td>- search result bit-vector (search result masks 1 elements) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="strsvsample06_8cpp-example.html#a22">strsvsample06.cpp</a>, <a class="el" href="strsvsample07_8cpp-example.html#a13">strsvsample07.cpp</a>, and <a class="el" href="xsample05_8cpp-example.html#a31">xsample05.cpp</a>.</dd>
</dl>

<p class="reference">Referenced by <a class="el" href="strsvsample06_8cpp_source.html#l00047">main()</a>, and <a class="el" href="xsample05_8cpp_source.html#l00318">run_benchmark()</a>.</p>

</div>
</div>
<a id="ac3b0e645f5eb33647a3ccf12f1b01c35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3b0e645f5eb33647a3ccf12f1b01c35">&#9670;&nbsp;</a></span>find_eq_str() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1sparse__vector__scanner.html">bm::sparse_vector_scanner</a>&lt; SV &gt;::find_eq_str </td>
          <td>(</td>
          <td class="paramtype">const SV &amp;&#160;</td>
          <td class="paramname"><em>sv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbm_1_1sparse__vector__scanner.html#a3890a7946df47e738cd7e3496b78f767">value_type</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1sparse__vector__scanner.html#a5856b08009c13a4683c8fc4566bdf89c">size_type</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find first sparse vector element (string) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>- sparse vector of strings to search </td></tr>
    <tr><td class="paramname">str</td><td>- string to search for </td></tr>
    <tr><td class="paramname">pos</td><td>- [out] index of the first found </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a591aeeb28ad76f0de6575178c7722e15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a591aeeb28ad76f0de6575178c7722e15">&#9670;&nbsp;</a></span>find_eq_str() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SV &gt; </div>
<div class="memtemplate">
template&lt;typename SV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1sparse__vector__scanner.html">bm::sparse_vector_scanner</a>&lt; SV &gt;::find_eq_str </td>
          <td>(</td>
          <td class="paramtype">const typename SV::value_type *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="rscsample05_8cpp.html#a4ca03dfc387c36e69ea916426572acdc">SV::bvector_type</a> &amp;&#160;</td>
          <td class="paramname"><em>bv_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bmsparsevec__algo_8h_source.html#l02199">2199</a> of file <a class="el" href="bmsparsevec__algo_8h_source.html">bmsparsevec_algo.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>.</p>

</div>
</div>
<a id="a1113943fa447f96f12cef5755f940acd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1113943fa447f96f12cef5755f940acd">&#9670;&nbsp;</a></span>find_eq_str() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SV &gt; </div>
<div class="memtemplate">
template&lt;typename SV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1sparse__vector__scanner.html">bm::sparse_vector_scanner</a>&lt; SV &gt;::find_eq_str </td>
          <td>(</td>
          <td class="paramtype">const typename SV::value_type *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename SV::size_type &amp;&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bmsparsevec__algo_8h_source.html#l02140">2140</a> of file <a class="el" href="bmsparsevec__algo_8h_source.html">bmsparsevec_algo.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>.</p>

</div>
</div>
<a id="a66a3466fd6b0db61c76fc0bb1c17e962"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66a3466fd6b0db61c76fc0bb1c17e962">&#9670;&nbsp;</a></span>find_eq_str() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1sparse__vector__scanner.html">bm::sparse_vector_scanner</a>&lt; SV &gt;::find_eq_str </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbm_1_1sparse__vector__scanner.html#a3890a7946df47e738cd7e3496b78f767">value_type</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1sparse__vector__scanner.html#a2610acb19f7d9127c681d584ecf9e9ea">bvector_type</a> &amp;&#160;</td>
          <td class="paramname"><em>bv_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find sparse vector elementa (string) in the attached SV </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- string to search for </td></tr>
    <tr><td class="paramname">bv_out</td><td>- search result bit-vector (search result masks 1 elements) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1fa8ee597d24dae81bc5e5d88cc3cfd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fa8ee597d24dae81bc5e5d88cc3cfd2">&#9670;&nbsp;</a></span>find_eq_str() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1sparse__vector__scanner.html">bm::sparse_vector_scanner</a>&lt; SV &gt;::find_eq_str </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbm_1_1sparse__vector__scanner.html#a3890a7946df47e738cd7e3496b78f767">value_type</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1sparse__vector__scanner.html#a5856b08009c13a4683c8fc4566bdf89c">size_type</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>binary find first sparse vector element (string) Sparse vector must be attached (<a class="el" href="classbm_1_1sparse__vector__scanner.html#aa5bd3464c5c0528ff168649413b5e7ee" title="bind sparse vector for all searches">bind()</a>) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- string to search for </td></tr>
    <tr><td class="paramname">pos</td><td>- [out] index of the first found </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbm_1_1sparse__vector__scanner.html#aa5bd3464c5c0528ff168649413b5e7ee" title="bind sparse vector for all searches">bind</a> </dd></dl>

</div>
</div>
<a id="afae57733f1ff13d74563af27337e31fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afae57733f1ff13d74563af27337e31fb">&#9670;&nbsp;</a></span>find_eq_str() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SV &gt; </div>
<div class="memtemplate">
template&lt;class TPipe &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1sparse__vector__scanner.html">bm::sparse_vector_scanner</a>&lt; SV &gt;::find_eq_str </td>
          <td>(</td>
          <td class="paramtype">TPipe &amp;&#160;</td>
          <td class="paramname"><em>pipe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find sparse vector elements using search pipeline </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipe</td><td>- pipeline to run </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bmsparsevec__algo_8h_source.html#l02284">2284</a> of file <a class="el" href="bmsparsevec__algo_8h_source.html">bmsparsevec_algo.h</a>.</p>

</div>
</div>
<a id="a2ecfd0fc4a6d8a3c62b086979989df88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ecfd0fc4a6d8a3c62b086979989df88">&#9670;&nbsp;</a></span>find_eq_str_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SV &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1sparse__vector__scanner.html">bm::sparse_vector_scanner</a>&lt; SV &gt;::find_eq_str_impl </td>
          <td>(</td>
          <td class="paramtype">const SV &amp;&#160;</td>
          <td class="paramname"><em>sv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbm_1_1sparse__vector__scanner.html#a3890a7946df47e738cd7e3496b78f767">value_type</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1sparse__vector__scanner.html#a2610acb19f7d9127c681d584ecf9e9ea">bvector_type</a> &amp;&#160;</td>
          <td class="paramname"><em>bv_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>prefix_sub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find EQ str / prefix impl </p>
<p >aggregator search</p>

<p class="definition">Definition at line <a class="el" href="bmsparsevec__algo_8h_source.html#l02233">2233</a> of file <a class="el" href="bmsparsevec__algo_8h_source.html">bmsparsevec_algo.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>.</p>

</div>
</div>
<a id="ad19877c3b18ba5054d8e40f2d99f8cef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad19877c3b18ba5054d8e40f2d99f8cef">&#9670;&nbsp;</a></span>find_eq_str_prefix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1sparse__vector__scanner.html">bm::sparse_vector_scanner</a>&lt; SV &gt;::find_eq_str_prefix </td>
          <td>(</td>
          <td class="paramtype">const SV &amp;&#160;</td>
          <td class="paramname"><em>sv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbm_1_1sparse__vector__scanner.html#a3890a7946df47e738cd7e3496b78f767">value_type</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1sparse__vector__scanner.html#a2610acb19f7d9127c681d584ecf9e9ea">bvector_type</a> &amp;&#160;</td>
          <td class="paramname"><em>bv_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find sparse vector elements with a given prefix (string) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>- sparse vector of strings to search </td></tr>
    <tr><td class="paramname">str</td><td>- string prefix to search for "123" is a prefix for "1234567" </td></tr>
    <tr><td class="paramname">bv_out</td><td>- search result bit-vector (search result masks 1 elements) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="strsvsample06_8cpp-example.html#a23">strsvsample06.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bmsparsevec__algo_8h_source.html#l02129">2129</a> of file <a class="el" href="bmsparsevec__algo_8h_source.html">bmsparsevec_algo.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="strsvsample06_8cpp_source.html#l00047">main()</a>.</p>

</div>
</div>
<a id="a4564161d1c4941f94c1cbd15e981377b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4564161d1c4941f94c1cbd15e981377b">&#9670;&nbsp;</a></span>find_eq_with_nulls()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SV &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1sparse__vector__scanner.html">bm::sparse_vector_scanner</a>&lt; SV &gt;::find_eq_with_nulls </td>
          <td>(</td>
          <td class="paramtype">const SV &amp;&#160;</td>
          <td class="paramname"><em>sv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1sparse__vector__scanner.html#a3890a7946df47e738cd7e3496b78f767">value_type</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1sparse__vector__scanner.html#a2610acb19f7d9127c681d584ecf9e9ea">bvector_type</a> &amp;&#160;</td>
          <td class="paramname"><em>bv_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1sparse__vector__scanner.html#a5856b08009c13a4683c8fc4566bdf89c">size_type</a>&#160;</td>
          <td class="paramname"><em>search_limit</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find value (may include NULL indexes) </p>

<p class="definition">Definition at line <a class="el" href="bmsparsevec__algo_8h_source.html#l01572">1572</a> of file <a class="el" href="bmsparsevec__algo_8h_source.html">bmsparsevec_algo.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="bmsparsevec__algo_8h_source.html#l00874">bm::sparse_vector_scanner&lt; SV &gt;::find_eq()</a>.</p>

</div>
</div>
<a id="a5e79e776b3e5c9cc3aca005a8511d09f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e79e776b3e5c9cc3aca005a8511d09f">&#9670;&nbsp;</a></span>find_eq_with_nulls_horizontal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1sparse__vector__scanner.html">bm::sparse_vector_scanner</a>&lt; SV &gt;::find_eq_with_nulls_horizontal </td>
          <td>(</td>
          <td class="paramtype">const SV &amp;&#160;</td>
          <td class="paramname"><em>sv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1sparse__vector__scanner.html#a3890a7946df47e738cd7e3496b78f767">value_type</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1sparse__vector__scanner.html#a2610acb19f7d9127c681d584ecf9e9ea">bvector_type</a> &amp;&#160;</td>
          <td class="paramname"><em>bv_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For testing purposes only. </p>

<p class="definition">Definition at line <a class="el" href="bmsparsevec__algo_8h_source.html#l01765">1765</a> of file <a class="el" href="bmsparsevec__algo_8h_source.html">bmsparsevec_algo.h</a>.</p>

<p class="reference">References <a class="el" href="bmfunc_8h_source.html#l00752">bm::bitscan()</a>, and <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>.</p>

</div>
</div>
<a id="a0e65e170dfd3e3449f80bc32d358e747"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e65e170dfd3e3449f80bc32d358e747">&#9670;&nbsp;</a></span>find_first_eq() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SV &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1sparse__vector__scanner.html">bm::sparse_vector_scanner</a>&lt; SV &gt;::find_first_eq </td>
          <td>(</td>
          <td class="paramtype">const SV &amp;&#160;</td>
          <td class="paramname"><em>sv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbm_1_1sparse__vector__scanner.html#a3890a7946df47e738cd7e3496b78f767">value_type</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1sparse__vector__scanner.html#a5856b08009c13a4683c8fc4566bdf89c">size_type</a> &amp;&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>remaped</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find first string value (may include NULL indexes) </p>

<p class="definition">Definition at line <a class="el" href="bmsparsevec__algo_8h_source.html#l01627">1627</a> of file <a class="el" href="bmsparsevec__algo_8h_source.html">bmsparsevec_algo.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>.</p>

</div>
</div>
<a id="a584cef9598e42f5c658028c2bf074c2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a584cef9598e42f5c658028c2bf074c2e">&#9670;&nbsp;</a></span>find_first_eq() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SV &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1sparse__vector__scanner.html">bm::sparse_vector_scanner</a>&lt; SV &gt;::find_first_eq </td>
          <td>(</td>
          <td class="paramtype">const SV &amp;&#160;</td>
          <td class="paramname"><em>sv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1sparse__vector__scanner.html#a3890a7946df47e738cd7e3496b78f767">value_type</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1sparse__vector__scanner.html#a5856b08009c13a4683c8fc4566bdf89c">size_type</a> &amp;&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find first value (may include NULL indexes) </p>

<p class="definition">Definition at line <a class="el" href="bmsparsevec__algo_8h_source.html#l01603">1603</a> of file <a class="el" href="bmsparsevec__algo_8h_source.html">bmsparsevec_algo.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>.</p>

</div>
</div>
<a id="aead5949c77e69780907bae570f629e69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aead5949c77e69780907bae570f629e69">&#9670;&nbsp;</a></span>find_ge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1sparse__vector__scanner.html">bm::sparse_vector_scanner</a>&lt; SV &gt;::find_ge </td>
          <td>(</td>
          <td class="paramtype">const SV &amp;&#160;</td>
          <td class="paramname"><em>sv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1sparse__vector__scanner.html#a3890a7946df47e738cd7e3496b78f767">value_type</a>&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1sparse__vector__scanner.html#a2610acb19f7d9127c681d584ecf9e9ea">bvector_type</a> &amp;&#160;</td>
          <td class="paramname"><em>bv_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find all elements sparse vector element greater or equal (&gt;=) than value </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>- input sparse vector </td></tr>
    <tr><td class="paramname">value</td><td>- value to search for </td></tr>
    <tr><td class="paramname">bv_out</td><td>- search result bit-vector (search result is a vector of 1s when sv[i] &gt;= value) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="svsample10_8cpp-example.html#a12">svsample10.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bmsparsevec__algo_8h_source.html#l01828">1828</a> of file <a class="el" href="bmsparsevec__algo_8h_source.html">bmsparsevec_algo.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="svsample10_8cpp_source.html#l00074">main()</a>.</p>

</div>
</div>
<a id="af36d1b7cb0fa99f7b5a7ac799f0ce398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af36d1b7cb0fa99f7b5a7ac799f0ce398">&#9670;&nbsp;</a></span>find_gt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1sparse__vector__scanner.html">bm::sparse_vector_scanner</a>&lt; SV &gt;::find_gt </td>
          <td>(</td>
          <td class="paramtype">const SV &amp;&#160;</td>
          <td class="paramname"><em>sv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1sparse__vector__scanner.html#a3890a7946df47e738cd7e3496b78f767">value_type</a>&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1sparse__vector__scanner.html#a2610acb19f7d9127c681d584ecf9e9ea">bvector_type</a> &amp;&#160;</td>
          <td class="paramname"><em>bv_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find all elements sparse vector element greater (&gt;) than value </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>- input sparse vector </td></tr>
    <tr><td class="paramname">value</td><td>- value to search for </td></tr>
    <tr><td class="paramname">bv_out</td><td>- search result bit-vector (search result is a vector of 1s when sv[i] &gt; value) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="svsample10_8cpp-example.html#a10">svsample10.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bmsparsevec__algo_8h_source.html#l01817">1817</a> of file <a class="el" href="bmsparsevec__algo_8h_source.html">bmsparsevec_algo.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="svsample10_8cpp_source.html#l00074">main()</a>.</p>

</div>
</div>
<a id="a6ea82c93f2123f4f8f687ab29cec1490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ea82c93f2123f4f8f687ab29cec1490">&#9670;&nbsp;</a></span>find_gt_horizontal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1sparse__vector__scanner.html">bm::sparse_vector_scanner</a>&lt; SV &gt;::find_gt_horizontal </td>
          <td>(</td>
          <td class="paramtype">const SV &amp;&#160;</td>
          <td class="paramname"><em>sv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1sparse__vector__scanner.html#a3890a7946df47e738cd7e3496b78f767">value_type</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1sparse__vector__scanner.html#a2610acb19f7d9127c681d584ecf9e9ea">bvector_type</a> &amp;&#160;</td>
          <td class="paramname"><em>bv_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>null_correct</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For testing purposes only. </p>

<p class="definition">Definition at line <a class="el" href="bmsparsevec__algo_8h_source.html#l01906">1906</a> of file <a class="el" href="bmsparsevec__algo_8h_source.html">bmsparsevec_algo.h</a>.</p>

<p class="reference">References <a class="el" href="bmfunc_8h_source.html#l00752">bm::bitscan()</a>, and <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>.</p>

</div>
</div>
<a id="aec58a1e6d0d8cd4cf161353d427455cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec58a1e6d0d8cd4cf161353d427455cd">&#9670;&nbsp;</a></span>find_le()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1sparse__vector__scanner.html">bm::sparse_vector_scanner</a>&lt; SV &gt;::find_le </td>
          <td>(</td>
          <td class="paramtype">const SV &amp;&#160;</td>
          <td class="paramname"><em>sv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1sparse__vector__scanner.html#a3890a7946df47e738cd7e3496b78f767">value_type</a>&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1sparse__vector__scanner.html#a2610acb19f7d9127c681d584ecf9e9ea">bvector_type</a> &amp;&#160;</td>
          <td class="paramname"><em>bv_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find all elements sparse vector element less or equal (&lt;=) than value </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>- input sparse vector </td></tr>
    <tr><td class="paramname">value</td><td>- value to search for </td></tr>
    <tr><td class="paramname">bv_out</td><td>- search result bit-vector (search result is a vector of 1s when sv[i] &lt;= value) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="svsample10_8cpp-example.html#a13">svsample10.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bmsparsevec__algo_8h_source.html#l01877">1877</a> of file <a class="el" href="bmsparsevec__algo_8h_source.html">bmsparsevec_algo.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="svsample10_8cpp_source.html#l00074">main()</a>.</p>

</div>
</div>
<a id="aa08de09bbf36b6832c4357e24477cc65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa08de09bbf36b6832c4357e24477cc65">&#9670;&nbsp;</a></span>find_lt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1sparse__vector__scanner.html">bm::sparse_vector_scanner</a>&lt; SV &gt;::find_lt </td>
          <td>(</td>
          <td class="paramtype">const SV &amp;&#160;</td>
          <td class="paramname"><em>sv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1sparse__vector__scanner.html#a3890a7946df47e738cd7e3496b78f767">value_type</a>&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1sparse__vector__scanner.html#a2610acb19f7d9127c681d584ecf9e9ea">bvector_type</a> &amp;&#160;</td>
          <td class="paramname"><em>bv_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find all elements sparse vector element less (&lt;) than value </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>- input sparse vector </td></tr>
    <tr><td class="paramname">value</td><td>- value to search for </td></tr>
    <tr><td class="paramname">bv_out</td><td>- search result bit-vector (search result is a vector of 1s when sv[i] &lt; value) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="svsample10_8cpp-example.html#a11">svsample10.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bmsparsevec__algo_8h_source.html#l01866">1866</a> of file <a class="el" href="bmsparsevec__algo_8h_source.html">bmsparsevec_algo.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="svsample10_8cpp_source.html#l00074">main()</a>.</p>

</div>
</div>
<a id="a9e9639918d1fb60c0f84b098be001049"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e9639918d1fb60c0f84b098be001049">&#9670;&nbsp;</a></span>find_nonzero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1sparse__vector__scanner.html">bm::sparse_vector_scanner</a>&lt; SV &gt;::find_nonzero </td>
          <td>(</td>
          <td class="paramtype">const SV &amp;&#160;</td>
          <td class="paramname"><em>sv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="rscsample05_8cpp.html#a4ca03dfc387c36e69ea916426572acdc">SV::bvector_type</a> &amp;&#160;</td>
          <td class="paramname"><em>bv_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find non-zero elements Output vector is computed as a logical OR (join) of all planes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>- input sparse vector </td></tr>
    <tr><td class="paramname">bv_out</td><td>- output bit-bector of non-zero elements </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bmsparsevec__algo_8h_source.html#l02827">2827</a> of file <a class="el" href="bmsparsevec__algo_8h_source.html">bmsparsevec_algo.h</a>.</p>

</div>
</div>
<a id="acf5b4cb9a5fb20ab482f403f9ee9a3ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf5b4cb9a5fb20ab482f403f9ee9a3ee">&#9670;&nbsp;</a></span>find_positive()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1sparse__vector__scanner.html">bm::sparse_vector_scanner</a>&lt; SV &gt;::find_positive </td>
          <td>(</td>
          <td class="paramtype">const SV &amp;&#160;</td>
          <td class="paramname"><em>sv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="rscsample05_8cpp.html#a4ca03dfc387c36e69ea916426572acdc">SV::bvector_type</a> &amp;&#160;</td>
          <td class="paramname"><em>bv_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find positive (greter than zero elements) Output vector is computed as a logical OR (join) of all planes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>- input sparse vector </td></tr>
    <tr><td class="paramname">bv_out</td><td>- output bit-bector of non-zero elements </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bmsparsevec__algo_8h_source.html#l02841">2841</a> of file <a class="el" href="bmsparsevec__algo_8h_source.html">bmsparsevec_algo.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>.</p>

</div>
</div>
<a id="af4db5cbc383399b813515f26c8b8df3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4db5cbc383399b813515f26c8b8df3d">&#9670;&nbsp;</a></span>find_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1sparse__vector__scanner.html">bm::sparse_vector_scanner</a>&lt; SV &gt;::find_range </td>
          <td>(</td>
          <td class="paramtype">const SV &amp;&#160;</td>
          <td class="paramname"><em>sv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1sparse__vector__scanner.html#a3890a7946df47e738cd7e3496b78f767">value_type</a>&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1sparse__vector__scanner.html#a3890a7946df47e738cd7e3496b78f767">value_type</a>&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1sparse__vector__scanner.html#a2610acb19f7d9127c681d584ecf9e9ea">bvector_type</a> &amp;&#160;</td>
          <td class="paramname"><em>bv_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find all elements sparse vector element in closed range [left..right] interval </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>- input sparse vector </td></tr>
    <tr><td class="paramname">from</td><td>- range from </td></tr>
    <tr><td class="paramname">to</td><td>- range to </td></tr>
    <tr><td class="paramname">bv_out</td><td>- search result bit-vector (search result is a vector of 1s when sv[i] &lt;= value) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="svsample10_8cpp-example.html#a14">svsample10.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bmsparsevec__algo_8h_source.html#l01888">1888</a> of file <a class="el" href="bmsparsevec__algo_8h_source.html">bmsparsevec_algo.h</a>.</p>

<p class="reference">References <a class="el" href="bmutil_8h_source.html#l00536">bm::xor_swap()</a>.</p>

<p class="reference">Referenced by <a class="el" href="svsample10_8cpp_source.html#l00074">main()</a>.</p>

</div>
</div>
<a id="a5f64aeebe7d6a3b378dea86f5ecb502c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f64aeebe7d6a3b378dea86f5ecb502c">&#9670;&nbsp;</a></span>find_zero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1sparse__vector__scanner.html">bm::sparse_vector_scanner</a>&lt; SV &gt;::find_zero </td>
          <td>(</td>
          <td class="paramtype">const SV &amp;&#160;</td>
          <td class="paramname"><em>sv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1sparse__vector__scanner.html#a2610acb19f7d9127c681d584ecf9e9ea">bvector_type</a> &amp;&#160;</td>
          <td class="paramname"><em>bv_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>null_correct</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find all sparse vector elements EQ to 0 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>- input sparse vector </td></tr>
    <tr><td class="paramname">bv_out</td><td>- output bit-vector (search result masks 1 elements) </td></tr>
    <tr><td class="paramname">null_correct</td><td>- flag to perform NULL correction </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bmsparsevec__algo_8h_source.html#l01505">1505</a> of file <a class="el" href="bmsparsevec__algo_8h_source.html">bmsparsevec_algo.h</a>.</p>

<p class="reference">References <a class="el" href="bmconst_8h_source.html#l00109">bm::id_max</a>.</p>

<p class="reference">Referenced by <a class="el" href="bmsparsevec__algo_8h_source.html#l01246">bm::set2set_11_transform&lt; SV &gt;::attach_sv()</a>.</p>

</div>
</div>
<a id="afcdfc9aabb7e74ffba05a8be5ca3f8fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcdfc9aabb7e74ffba05a8be5ca3f8fd">&#9670;&nbsp;</a></span>get_bvector_alloc_pool()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SV &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1sparse__vector__scanner.html#aa2f5ebd37c06d9a8b69d2a26efaac638">allocator_pool_type</a>&amp; <a class="el" href="classbm_1_1sparse__vector__scanner.html">bm::sparse_vector_scanner</a>&lt; SV &gt;::get_bvector_alloc_pool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return allocator pool for blocks (Can be used to improve performance of repeated searches with the same scanner) </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="svsample07a_8cpp-example.html#a17">svsample07a.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bmsparsevec__algo_8h_source.html#l00926">926</a> of file <a class="el" href="bmsparsevec__algo_8h_source.html">bmsparsevec_algo.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="svsample07a_8cpp_source.html#l00059">main()</a>.</p>

</div>
</div>
<a id="aa041f214a89bebea528c8539933fb423"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa041f214a89bebea528c8539933fb423">&#9670;&nbsp;</a></span>gt_slice_limit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SV &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr int <a class="el" href="classbm_1_1sparse__vector__scanner.html">bm::sparse_vector_scanner</a>&lt; SV &gt;::gt_slice_limit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the slice limit for signed/unsigned vector value types. </p>

<p class="definition">Definition at line <a class="el" href="bmsparsevec__algo_8h_source.html#l00996">996</a> of file <a class="el" href="bmsparsevec__algo_8h_source.html">bmsparsevec_algo.h</a>.</p>

</div>
</div>
<a id="a69e62acaeac6d53bee042d076db2e1e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69e62acaeac6d53bee042d076db2e1e3">&#9670;&nbsp;</a></span>invert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1sparse__vector__scanner.html">bm::sparse_vector_scanner</a>&lt; SV &gt;::invert </td>
          <td>(</td>
          <td class="paramtype">const SV &amp;&#160;</td>
          <td class="paramname"><em>sv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1sparse__vector__scanner.html#a2610acb19f7d9127c681d584ecf9e9ea">bvector_type</a> &amp;&#160;</td>
          <td class="paramname"><em>bv_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>invert search result ("EQ" to "not EQ") </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>- input sparse vector </td></tr>
    <tr><td class="paramname">bv_out</td><td>- output bit-bector of non-zero elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="svsample06_8cpp-example.html#a27">svsample06.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bmsparsevec__algo_8h_source.html#l01532">1532</a> of file <a class="el" href="bmsparsevec__algo_8h_source.html">bmsparsevec_algo.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="svsample06_8cpp_source.html#l00133">main()</a>.</p>

</div>
</div>
<a id="adcea3d6c5050f0d8a34872ea09830b6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcea3d6c5050f0d8a34872ea09830b6b">&#9670;&nbsp;</a></span>lower_bound_str()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1sparse__vector__scanner.html">bm::sparse_vector_scanner</a>&lt; SV &gt;::lower_bound_str </td>
          <td>(</td>
          <td class="paramtype">const SV &amp;&#160;</td>
          <td class="paramname"><em>sv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbm_1_1sparse__vector__scanner.html#a3890a7946df47e738cd7e3496b78f767">value_type</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1sparse__vector__scanner.html#a5856b08009c13a4683c8fc4566bdf89c">size_type</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>lower bound search for an array position </p>
<p >Method assumes the sparse array is sorted</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>- input sparse vector </td></tr>
    <tr><td class="paramname">str</td><td>- value to search for </td></tr>
    <tr><td class="paramname">pos</td><td>- output sparse vector element index</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if value found </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="strsvsample02_8cpp-example.html#a7">strsvsample02.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bmsparsevec__algo_8h_source.html#l02580">2580</a> of file <a class="el" href="bmsparsevec__algo_8h_source.html">bmsparsevec_algo.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>.</p>

<p class="reference">Referenced by <a class="el" href="strsvsample02_8cpp_source.html#l00081">insertion_sort()</a>.</p>

</div>
</div>
<a id="a5aec048117bfa28782bb25bcb7568501"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aec048117bfa28782bb25bcb7568501">&#9670;&nbsp;</a></span>prepare_and_sub_aggregator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SV &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1sparse__vector__scanner.html">bm::sparse_vector_scanner</a>&lt; SV &gt;::prepare_and_sub_aggregator </td>
          <td>(</td>
          <td class="paramtype">const SV &amp;&#160;</td>
          <td class="paramname"><em>sv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbm_1_1sparse__vector__scanner.html#a3890a7946df47e738cd7e3496b78f767">value_type</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>octet_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>prefix_sub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepare aggregator for AND-SUB (EQ) search (string) </p>

<p class="definition">Definition at line <a class="el" href="bmsparsevec__algo_8h_source.html#l01676">1676</a> of file <a class="el" href="bmsparsevec__algo_8h_source.html">bmsparsevec_algo.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>.</p>

</div>
</div>
<a id="a454a1aa3b0948b2bec784b27a7a26849"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a454a1aa3b0948b2bec784b27a7a26849">&#9670;&nbsp;</a></span>prepare_and_sub_aggregator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SV &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1sparse__vector__scanner.html">bm::sparse_vector_scanner</a>&lt; SV &gt;::prepare_and_sub_aggregator </td>
          <td>(</td>
          <td class="paramtype">const SV &amp;&#160;</td>
          <td class="paramname"><em>sv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1sparse__vector__scanner.html#a3890a7946df47e738cd7e3496b78f767">value_type</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepare aggregator for AND-SUB (EQ) search. </p>

<p class="definition">Definition at line <a class="el" href="bmsparsevec__algo_8h_source.html#l01725">1725</a> of file <a class="el" href="bmsparsevec__algo_8h_source.html">bmsparsevec_algo.h</a>.</p>

<p class="reference">References <a class="el" href="bmfunc_8h_source.html#l00752">bm::bitscan()</a>, and <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>.</p>

</div>
</div>
<a id="a49e339edeaf9b57fa19e10d94f2162b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49e339edeaf9b57fa19e10d94f2162b9">&#9670;&nbsp;</a></span>remap_tosv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SV &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1sparse__vector__scanner.html">bm::sparse_vector_scanner</a>&lt; SV &gt;::remap_tosv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbm_1_1sparse__vector__scanner.html#a653fbc8c97f4699d6879b12ad42f9838">remap_vector_type</a> &amp;&#160;</td>
          <td class="paramname"><em>remap_vect_target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbm_1_1sparse__vector__scanner.html#a3890a7946df47e738cd7e3496b78f767">value_type</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SV &amp;&#160;</td>
          <td class="paramname"><em>sv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remap input value into SV char encodings. </p>

<p class="definition">Definition at line <a class="el" href="bmsparsevec__algo_8h_source.html#l02219">2219</a> of file <a class="el" href="bmsparsevec__algo_8h_source.html">bmsparsevec_algo.h</a>.</p>

</div>
</div>
<a id="a7fd8c8e2b6687af8e1dbdd617a7fac08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fd8c8e2b6687af8e1dbdd617a7fac08">&#9670;&nbsp;</a></span>reset_binding()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1sparse__vector__scanner.html">bm::sparse_vector_scanner</a>&lt; SV &gt;::reset_binding</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reset sparse vector binding </p>

<p class="definition">Definition at line <a class="el" href="bmsparsevec__algo_8h_source.html#l01496">1496</a> of file <a class="el" href="bmsparsevec__algo_8h_source.html">bmsparsevec_algo.h</a>.</p>

</div>
</div>
<a id="acea7e56e787292e325c3f1d68e1e15b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acea7e56e787292e325c3f1d68e1e15b6">&#9670;&nbsp;</a></span>reset_search_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SV &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1sparse__vector__scanner.html">bm::sparse_vector_scanner</a>&lt; SV &gt;::reset_search_range</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>reset (disable) search range </p>

<p class="definition">Definition at line <a class="el" href="bmsparsevec__algo_8h_source.html#l02888">2888</a> of file <a class="el" href="bmsparsevec__algo_8h_source.html">bmsparsevec_algo.h</a>.</p>

<p class="reference">References <a class="el" href="bmconst_8h_source.html#l00109">bm::id_max</a>.</p>

</div>
</div>
<a id="ae9526c0f803b23408420e2eaf8eec10e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9526c0f803b23408420e2eaf8eec10e">&#9670;&nbsp;</a></span>set_search_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SV &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1sparse__vector__scanner.html">bm::sparse_vector_scanner</a>&lt; SV &gt;::set_search_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbm_1_1sparse__vector__scanner.html#a5856b08009c13a4683c8fc4566bdf89c">size_type</a>&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1sparse__vector__scanner.html#a5856b08009c13a4683c8fc4566bdf89c">size_type</a>&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set search boundaries (hint for the aggregator) </p>

<p class="definition">Definition at line <a class="el" href="bmsparsevec__algo_8h_source.html#l02877">2877</a> of file <a class="el" href="bmsparsevec__algo_8h_source.html">bmsparsevec_algo.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="bmsparsevec__algo_8h_source.html">bmsparsevec_algo.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
