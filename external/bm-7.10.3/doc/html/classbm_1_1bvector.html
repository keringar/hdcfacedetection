<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>BitMagic-C++: bm::bvector&lt; Alloc &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">BitMagic-C++
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacebm.html">bm</a></li><li class="navelem"><a class="el" href="classbm_1_1bvector.html">bvector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle"><div class="title">bm::bvector&lt; Alloc &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__bmagic.html">BitMagic Library</a> &raquo; <a class="el" href="group__bvector.html">bvector&lt;&gt; container</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Bitvector Bit-vector container with runtime compression of bits.  
 <a href="classbm_1_1bvector.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="bm_8h_source.html">bm.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbm_1_1bvector_1_1allocation__policy.html">allocation_policy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">memory allocation policy  <a href="structbm_1_1bvector_1_1allocation__policy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector_1_1bulk__insert__iterator.html">bulk_insert_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output iterator iterator designed to set "ON" bits based on input sequence of integers.  <a href="classbm_1_1bvector_1_1bulk__insert__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector_1_1counted__enumerator.html">counted_enumerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant iterator designed to enumerate "ON" bits <a class="el" href="classbm_1_1bvector_1_1counted__enumerator.html" title="Constant iterator designed to enumerate &quot;ON&quot; bits counted_enumerator keeps bitcount,...">counted_enumerator</a> keeps bitcount, ie number of ON bits starting from the position 0 in the bit string up to the currently enumerated bit.  <a href="classbm_1_1bvector_1_1counted__enumerator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector_1_1enumerator.html">enumerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant iterator designed to enumerate "ON" bits.  <a href="classbm_1_1bvector_1_1enumerator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector_1_1insert__iterator.html">insert_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output iterator iterator designed to set "ON" bits based on input sequence of integers (bit indeces).  <a href="classbm_1_1bvector_1_1insert__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector_1_1iterator__base.html">iterator_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all iterators.  <a href="classbm_1_1bvector_1_1iterator__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector_1_1mem__pool__guard.html">mem_pool_guard</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector_1_1reference.html">reference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class reference implements an object for bit assignment.  <a href="classbm_1_1bvector_1_1reference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbm_1_1bvector_1_1statistics.html">statistics</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statistical information about bitset's memory allocation details.  <a href="structbm_1_1bvector_1_1statistics.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a05f1e977cb5e6208838afc7e7b69e5f0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a05f1e977cb5e6208838afc7e7b69e5f0">optmode</a> { <a class="el" href="classbm_1_1bvector.html#a05f1e977cb5e6208838afc7e7b69e5f0afc03833a1770728dde103c7364b12660">opt_none</a> = 0
, <a class="el" href="classbm_1_1bvector.html#a05f1e977cb5e6208838afc7e7b69e5f0af7f71b9fa4aac73572f492b60df4dbbe">opt_free_0</a> = 1
, <a class="el" href="classbm_1_1bvector.html#a05f1e977cb5e6208838afc7e7b69e5f0ad4c02e1ba1f9522be654e0e129ced2fc">opt_free_01</a> = 2
, <a class="el" href="classbm_1_1bvector.html#a05f1e977cb5e6208838afc7e7b69e5f0a99b64b2444e1a8b22a5e89b02dca6001">opt_compress</a> = 3
 }</td></tr>
<tr class="memdesc:a05f1e977cb5e6208838afc7e7b69e5f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimization mode Every next level means additional checks (better compression vs time)  <a href="classbm_1_1bvector.html#a05f1e977cb5e6208838afc7e7b69e5f0">More...</a><br /></td></tr>
<tr class="separator:a05f1e977cb5e6208838afc7e7b69e5f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1dbe63690fd5cd2b1e064795d3f1b6c"><td class="memItemLeft" align="right" valign="top"><a id="ad1dbe63690fd5cd2b1e064795d3f1b6c"></a>
typedef Alloc&#160;</td><td class="memItemRight" valign="bottom"><b>allocator_type</b></td></tr>
<tr class="separator:ad1dbe63690fd5cd2b1e064795d3f1b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c8990a2147fdc3e6094011e77e559e8"><td class="memItemLeft" align="right" valign="top"><a id="a2c8990a2147fdc3e6094011e77e559e8"></a>
typedef allocator_type::allocator_pool_type&#160;</td><td class="memItemRight" valign="bottom"><b>allocator_pool_type</b></td></tr>
<tr class="separator:a2c8990a2147fdc3e6094011e77e559e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fdfeafe05217c31cdc9140b7642b611"><td class="memItemLeft" align="right" valign="top"><a id="a6fdfeafe05217c31cdc9140b7642b611"></a>
typedef blocks_manager&lt; Alloc &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>blocks_manager_type</b></td></tr>
<tr class="separator:a6fdfeafe05217c31cdc9140b7642b611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac11e61368363493754cbe97b69a1ca71"><td class="memItemLeft" align="right" valign="top"><a id="ac11e61368363493754cbe97b69a1ca71"></a>
typedef blocks_manager_type::block_idx_type&#160;</td><td class="memItemRight" valign="bottom"><b>block_idx_type</b></td></tr>
<tr class="separator:ac11e61368363493754cbe97b69a1ca71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fea809653a2792c84fd10c92b5c47c4"><td class="memItemLeft" align="right" valign="top"><a id="a7fea809653a2792c84fd10c92b5c47c4"></a>
typedef <a class="el" href="namespacebm.html#acd2b71d7a1e902a6f5bbf87c725ecacc">bvector_size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b></td></tr>
<tr class="separator:a7fea809653a2792c84fd10c92b5c47c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04d7ea71a6e69abb26e03b31f93e6689"><td class="memItemLeft" align="right" valign="top"><a id="a04d7ea71a6e69abb26e03b31f93e6689"></a>
typedef bool&#160;</td><td class="memItemRight" valign="bottom"><b>const_reference</b></td></tr>
<tr class="separator:a04d7ea71a6e69abb26e03b31f93e6689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad65985be02279456319b7a1f6eb794ee"><td class="memItemLeft" align="right" valign="top"><a id="ad65985be02279456319b7a1f6eb794ee"></a>
typedef rs_index&lt; <a class="el" href="classbm_1_1bvector.html#ad1dbe63690fd5cd2b1e064795d3f1b6c">allocator_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>blocks_count</b></td></tr>
<tr class="separator:ad65985be02279456319b7a1f6eb794ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9ed62250af37ade811aaf20b7a8d9a2"><td class="memItemLeft" align="right" valign="top"><a id="ac9ed62250af37ade811aaf20b7a8d9a2"></a>
typedef rs_index&lt; <a class="el" href="classbm_1_1bvector.html#ad1dbe63690fd5cd2b1e064795d3f1b6c">allocator_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>rs_index_type</b></td></tr>
<tr class="separator:ac9ed62250af37ade811aaf20b7a8d9a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Construction, initialization, assignment</div></td></tr>
<tr class="memitem:a159e3c2cb32e6d098eddd9d1eac21c88"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a159e3c2cb32e6d098eddd9d1eac21c88">bvector</a> (<a class="el" href="group__bvector.html#gad0b87b3b7292383a864d27feaf1c9eff">strategy</a> strat=<a class="el" href="group__bvector.html#ggad0b87b3b7292383a864d27feaf1c9effa40920ae0ef7b4411d60463d8f576b5ba">BM_BIT</a>, const <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *glevel_len=<a class="el" href="structbm_1_1gap__len__table.html">bm::gap_len_table</a>&lt; true &gt;::_len, <a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> bv_size=<a class="el" href="namespacebm.html#a104b924a1df81542db2a6296fbf26a65">bm::id_max</a>, const Alloc &amp;alloc=Alloc())</td></tr>
<tr class="memdesc:a159e3c2cb32e6d098eddd9d1eac21c88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs bvector class.  <a href="classbm_1_1bvector.html#a159e3c2cb32e6d098eddd9d1eac21c88">More...</a><br /></td></tr>
<tr class="separator:a159e3c2cb32e6d098eddd9d1eac21c88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae54e579bdddadece60dcfa519d18a1c5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#ae54e579bdddadece60dcfa519d18a1c5">bvector</a> (<a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> bv_size, <a class="el" href="group__bvector.html#gad0b87b3b7292383a864d27feaf1c9eff">strategy</a> strat=<a class="el" href="group__bvector.html#ggad0b87b3b7292383a864d27feaf1c9effa40920ae0ef7b4411d60463d8f576b5ba">BM_BIT</a>, const <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *glevel_len=<a class="el" href="structbm_1_1gap__len__table.html">bm::gap_len_table</a>&lt; true &gt;::_len, const Alloc &amp;alloc=Alloc())</td></tr>
<tr class="memdesc:ae54e579bdddadece60dcfa519d18a1c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs bvector class.  <a href="classbm_1_1bvector.html#ae54e579bdddadece60dcfa519d18a1c5">More...</a><br /></td></tr>
<tr class="separator:ae54e579bdddadece60dcfa519d18a1c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a608b979d18211645c625e1bcd41cf307"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a608b979d18211645c625e1bcd41cf307">bvector</a> (const <a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;<a class="el" href="sample6_8cpp.html#ac07bb102df543a0c581493c5f35b2129">bvect</a>)</td></tr>
<tr class="memdesc:a608b979d18211645c625e1bcd41cf307"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="classbm_1_1bvector.html#a608b979d18211645c625e1bcd41cf307">More...</a><br /></td></tr>
<tr class="separator:a608b979d18211645c625e1bcd41cf307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb493ca86ebd58f02a1a5a73c393b199"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#acb493ca86ebd58f02a1a5a73c393b199">bvector</a> (const <a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;<a class="el" href="sample6_8cpp.html#ac07bb102df543a0c581493c5f35b2129">bvect</a>, <a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> left, <a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> right)</td></tr>
<tr class="memdesc:acb493ca86ebd58f02a1a5a73c393b199"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor for range copy [left..right].  <a href="classbm_1_1bvector.html#acb493ca86ebd58f02a1a5a73c393b199">More...</a><br /></td></tr>
<tr class="separator:acb493ca86ebd58f02a1a5a73c393b199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a96c45c37c5c046178883060d363c83"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a0a96c45c37c5c046178883060d363c83">bvector</a> (const <a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;<a class="el" href="sample6_8cpp.html#ac07bb102df543a0c581493c5f35b2129">bvect</a>, <a class="el" href="group__bvector.html#gacfee7c9af0d11e534813a7429ffb1a31">bm::finalization</a> is_final)</td></tr>
<tr class="memdesc:a0a96c45c37c5c046178883060d363c83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy-constructor for mutable/immutable initialization.  <a href="classbm_1_1bvector.html#a0a96c45c37c5c046178883060d363c83">More...</a><br /></td></tr>
<tr class="separator:a0a96c45c37c5c046178883060d363c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae50d9168a9e937a054ebfda45fa8e338"><td class="memItemLeft" align="right" valign="top"><a id="ae50d9168a9e937a054ebfda45fa8e338"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~bvector</b> () <a class="el" href="bmdef_8h.html#a40d7d3c011d2128b1f0c392127d7d61e">BMNOEXCEPT</a></td></tr>
<tr class="separator:ae50d9168a9e937a054ebfda45fa8e338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaceb8d31d9da05f977de5c6a6cd62e24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#aaceb8d31d9da05f977de5c6a6cd62e24">init</a> ()</td></tr>
<tr class="memdesc:aaceb8d31d9da05f977de5c6a6cd62e24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit post-construction initialization. Must be caled to make sure safe use of *_no_check() methods.  <a href="classbm_1_1bvector.html#aaceb8d31d9da05f977de5c6a6cd62e24">More...</a><br /></td></tr>
<tr class="separator:aaceb8d31d9da05f977de5c6a6cd62e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ffde9962a72e85ad2e6da29b397882e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbm_1_1bvector.html">bvector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a3ffde9962a72e85ad2e6da29b397882e">operator=</a> (const <a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;<a class="el" href="sample6_8cpp.html#ac07bb102df543a0c581493c5f35b2129">bvect</a>)</td></tr>
<tr class="memdesc:a3ffde9962a72e85ad2e6da29b397882e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <a href="classbm_1_1bvector.html#a3ffde9962a72e85ad2e6da29b397882e">More...</a><br /></td></tr>
<tr class="separator:a3ffde9962a72e85ad2e6da29b397882e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bd58c5e2c84307768b0e62f1d59f438"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a1bd58c5e2c84307768b0e62f1d59f438">bvector</a> (<a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;&amp;<a class="el" href="sample6_8cpp.html#ac07bb102df543a0c581493c5f35b2129">bvect</a>) <a class="el" href="bmdef_8h.html#a40d7d3c011d2128b1f0c392127d7d61e">BMNOEXCEPT</a></td></tr>
<tr class="memdesc:a1bd58c5e2c84307768b0e62f1d59f438"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="classbm_1_1bvector.html#a1bd58c5e2c84307768b0e62f1d59f438">More...</a><br /></td></tr>
<tr class="separator:a1bd58c5e2c84307768b0e62f1d59f438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65dd5a92d3360c796e841ed783724406"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a65dd5a92d3360c796e841ed783724406">bvector</a> (std::initializer_list&lt; <a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> &gt; il)</td></tr>
<tr class="memdesc:a65dd5a92d3360c796e841ed783724406"><td class="mdescLeft">&#160;</td><td class="mdescRight">Brace constructor.  <a href="classbm_1_1bvector.html#a65dd5a92d3360c796e841ed783724406">More...</a><br /></td></tr>
<tr class="separator:a65dd5a92d3360c796e841ed783724406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa75a19006f39dddff108694a0a87dee0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbm_1_1bvector.html">bvector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#aa75a19006f39dddff108694a0a87dee0">operator=</a> (<a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;&amp;<a class="el" href="sample6_8cpp.html#ac07bb102df543a0c581493c5f35b2129">bvect</a>) <a class="el" href="bmdef_8h.html#a40d7d3c011d2128b1f0c392127d7d61e">BMNOEXCEPT</a></td></tr>
<tr class="memdesc:aa75a19006f39dddff108694a0a87dee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <a href="classbm_1_1bvector.html#aa75a19006f39dddff108694a0a87dee0">More...</a><br /></td></tr>
<tr class="separator:aa75a19006f39dddff108694a0a87dee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1bc1b5c4ee46ac788a1718bf26b303e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#ac1bc1b5c4ee46ac788a1718bf26b303e">copy</a> (const <a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;<a class="el" href="sample6_8cpp.html#ac07bb102df543a0c581493c5f35b2129">bvect</a>, <a class="el" href="group__bvector.html#gacfee7c9af0d11e534813a7429ffb1a31">bm::finalization</a> is_final)</td></tr>
<tr class="memdesc:ac1bc1b5c4ee46ac788a1718bf26b303e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy bvector from the argument bvector.  <a href="classbm_1_1bvector.html#ac1bc1b5c4ee46ac788a1718bf26b303e">More...</a><br /></td></tr>
<tr class="separator:ac1bc1b5c4ee46ac788a1718bf26b303e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af513c039068c4ef27494235a5f1aaf4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#af513c039068c4ef27494235a5f1aaf4f">move_from</a> (<a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;<a class="el" href="sample6_8cpp.html#ac07bb102df543a0c581493c5f35b2129">bvect</a>) <a class="el" href="bmdef_8h.html#a40d7d3c011d2128b1f0c392127d7d61e">BMNOEXCEPT</a></td></tr>
<tr class="memdesc:af513c039068c4ef27494235a5f1aaf4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move bvector content from another bvector.  <a href="classbm_1_1bvector.html#af513c039068c4ef27494235a5f1aaf4f">More...</a><br /></td></tr>
<tr class="separator:af513c039068c4ef27494235a5f1aaf4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9764b5a36f4b012d1e4b4dbef4e85d0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a9764b5a36f4b012d1e4b4dbef4e85d0e">swap</a> (<a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;<a class="el" href="sample6_8cpp.html#ac07bb102df543a0c581493c5f35b2129">bvect</a>) <a class="el" href="bmdef_8h.html#a40d7d3c011d2128b1f0c392127d7d61e">BMNOEXCEPT</a></td></tr>
<tr class="memdesc:a9764b5a36f4b012d1e4b4dbef4e85d0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges content of bv and this bvector.  <a href="classbm_1_1bvector.html#a9764b5a36f4b012d1e4b4dbef4e85d0e">More...</a><br /></td></tr>
<tr class="separator:a9764b5a36f4b012d1e4b4dbef4e85d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a237170e9f988319665bbcac2cd10e24e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a237170e9f988319665bbcac2cd10e24e">merge</a> (<a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;<a class="el" href="sample6_8cpp.html#ac07bb102df543a0c581493c5f35b2129">bvect</a>)</td></tr>
<tr class="memdesc:a237170e9f988319665bbcac2cd10e24e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge/move content from another vector.  <a href="classbm_1_1bvector.html#a237170e9f988319665bbcac2cd10e24e">More...</a><br /></td></tr>
<tr class="separator:a237170e9f988319665bbcac2cd10e24e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58994dceeabe24a90abfd2b434208c1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbm_1_1bvector_1_1reference.html">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a58994dceeabe24a90abfd2b434208c1b">operator[]</a> (<a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> n)</td></tr>
<tr class="memdesc:a58994dceeabe24a90abfd2b434208c1b"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="classbm_1_1bvector.html#a58994dceeabe24a90abfd2b434208c1b">More...</a><br /></td></tr>
<tr class="separator:a58994dceeabe24a90abfd2b434208c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3554686ee2878e6dcd13b047e8bc668c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a3554686ee2878e6dcd13b047e8bc668c">operator[]</a> (<a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> n) const <a class="el" href="bmdef_8h.html#a40d7d3c011d2128b1f0c392127d7d61e">BMNOEXCEPT</a></td></tr>
<tr class="memdesc:a3554686ee2878e6dcd13b047e8bc668c"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="classbm_1_1bvector.html#a3554686ee2878e6dcd13b047e8bc668c">More...</a><br /></td></tr>
<tr class="separator:a3554686ee2878e6dcd13b047e8bc668c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fce12ee64a6011d6184277443f0bfcd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a0fce12ee64a6011d6184277443f0bfcd">operator&amp;=</a> (const <a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;bv)</td></tr>
<tr class="memdesc:a0fce12ee64a6011d6184277443f0bfcd"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="classbm_1_1bvector.html#a0fce12ee64a6011d6184277443f0bfcd">More...</a><br /></td></tr>
<tr class="separator:a0fce12ee64a6011d6184277443f0bfcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3adf4c9870b960d5dff4203074fc3d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#ac3adf4c9870b960d5dff4203074fc3d7">operator^=</a> (const <a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;bv)</td></tr>
<tr class="memdesc:ac3adf4c9870b960d5dff4203074fc3d7"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="classbm_1_1bvector.html#ac3adf4c9870b960d5dff4203074fc3d7">More...</a><br /></td></tr>
<tr class="separator:ac3adf4c9870b960d5dff4203074fc3d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac48cd211c038bdc186baeca30e42fa93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#ac48cd211c038bdc186baeca30e42fa93">operator|=</a> (const <a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;bv)</td></tr>
<tr class="memdesc:ac48cd211c038bdc186baeca30e42fa93"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="classbm_1_1bvector.html#ac48cd211c038bdc186baeca30e42fa93">More...</a><br /></td></tr>
<tr class="separator:ac48cd211c038bdc186baeca30e42fa93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ceab1a0111e47f2fe4c4421e44fd3e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a7ceab1a0111e47f2fe4c4421e44fd3e4">operator-=</a> (const <a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;bv)</td></tr>
<tr class="memdesc:a7ceab1a0111e47f2fe4c4421e44fd3e4"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="classbm_1_1bvector.html#a7ceab1a0111e47f2fe4c4421e44fd3e4">More...</a><br /></td></tr>
<tr class="separator:a7ceab1a0111e47f2fe4c4421e44fd3e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33ba6bcb25602091aedbd01dcb831dcf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a33ba6bcb25602091aedbd01dcb831dcf">operator&lt;</a> (const <a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;bv) const</td></tr>
<tr class="memdesc:a33ba6bcb25602091aedbd01dcb831dcf"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="classbm_1_1bvector.html#a33ba6bcb25602091aedbd01dcb831dcf">More...</a><br /></td></tr>
<tr class="separator:a33ba6bcb25602091aedbd01dcb831dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e18cf38c1986e81c495ac10cc1e8c96"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a9e18cf38c1986e81c495ac10cc1e8c96">operator&lt;=</a> (const <a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;bv) const</td></tr>
<tr class="memdesc:a9e18cf38c1986e81c495ac10cc1e8c96"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="classbm_1_1bvector.html#a9e18cf38c1986e81c495ac10cc1e8c96">More...</a><br /></td></tr>
<tr class="separator:a9e18cf38c1986e81c495ac10cc1e8c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a493c937eedfa6e8ad1f2b381678075cd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a493c937eedfa6e8ad1f2b381678075cd">operator&gt;</a> (const <a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;bv) const</td></tr>
<tr class="memdesc:a493c937eedfa6e8ad1f2b381678075cd"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="classbm_1_1bvector.html#a493c937eedfa6e8ad1f2b381678075cd">More...</a><br /></td></tr>
<tr class="separator:a493c937eedfa6e8ad1f2b381678075cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f5dfbe8e46c969d36ecbaf7261db03c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a9f5dfbe8e46c969d36ecbaf7261db03c">operator&gt;=</a> (const <a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;bv) const</td></tr>
<tr class="memdesc:a9f5dfbe8e46c969d36ecbaf7261db03c"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="classbm_1_1bvector.html#a9f5dfbe8e46c969d36ecbaf7261db03c">More...</a><br /></td></tr>
<tr class="separator:a9f5dfbe8e46c969d36ecbaf7261db03c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8de936ff88917bbc069045c36eabbf09"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a8de936ff88917bbc069045c36eabbf09">operator==</a> (const <a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;bv) const <a class="el" href="bmdef_8h.html#a40d7d3c011d2128b1f0c392127d7d61e">BMNOEXCEPT</a></td></tr>
<tr class="memdesc:a8de936ff88917bbc069045c36eabbf09"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="classbm_1_1bvector.html#a8de936ff88917bbc069045c36eabbf09">More...</a><br /></td></tr>
<tr class="separator:a8de936ff88917bbc069045c36eabbf09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab97d916d8dae991a7d86fd8083b69061"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#ab97d916d8dae991a7d86fd8083b69061">operator!=</a> (const <a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;bv) const <a class="el" href="bmdef_8h.html#a40d7d3c011d2128b1f0c392127d7d61e">BMNOEXCEPT</a></td></tr>
<tr class="memdesc:ab97d916d8dae991a7d86fd8083b69061"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="classbm_1_1bvector.html#ab97d916d8dae991a7d86fd8083b69061">More...</a><br /></td></tr>
<tr class="separator:ab97d916d8dae991a7d86fd8083b69061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51687153e07d3be056aeb38ada237816"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a51687153e07d3be056aeb38ada237816">operator~</a> () const</td></tr>
<tr class="memdesc:a51687153e07d3be056aeb38ada237816"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="classbm_1_1bvector.html#a51687153e07d3be056aeb38ada237816">More...</a><br /></td></tr>
<tr class="separator:a51687153e07d3be056aeb38ada237816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f97290c7998d85514404e10f6a11a63"><td class="memItemLeft" align="right" valign="top"><a id="a7f97290c7998d85514404e10f6a11a63"></a>
Alloc&#160;</td><td class="memItemRight" valign="bottom"><b>get_allocator</b> () const</td></tr>
<tr class="separator:a7f97290c7998d85514404e10f6a11a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5caf8104ebf999f36fc1f812aaff0bd5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a5caf8104ebf999f36fc1f812aaff0bd5">set_allocator_pool</a> (<a class="el" href="classbm_1_1bvector.html#a2c8990a2147fdc3e6094011e77e559e8">allocator_pool_type</a> *pool_ptr) <a class="el" href="bmdef_8h.html#a40d7d3c011d2128b1f0c392127d7d61e">BMNOEXCEPT</a></td></tr>
<tr class="memdesc:a5caf8104ebf999f36fc1f812aaff0bd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set allocator pool for local (non-th readed) memory cyclic(lots of alloc-free ops) opertations.  <a href="classbm_1_1bvector.html#a5caf8104ebf999f36fc1f812aaff0bd5">More...</a><br /></td></tr>
<tr class="separator:a5caf8104ebf999f36fc1f812aaff0bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade78fa98c59c68aedb4fd71e7b274c5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbm_1_1bvector.html#a2c8990a2147fdc3e6094011e77e559e8">allocator_pool_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#ade78fa98c59c68aedb4fd71e7b274c5f">get_allocator_pool</a> () <a class="el" href="bmdef_8h.html#a40d7d3c011d2128b1f0c392127d7d61e">BMNOEXCEPT</a></td></tr>
<tr class="memdesc:ade78fa98c59c68aedb4fd71e7b274c5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get curent allocator pool (if set)  <a href="classbm_1_1bvector.html#ade78fa98c59c68aedb4fd71e7b274c5f">More...</a><br /></td></tr>
<tr class="separator:ade78fa98c59c68aedb4fd71e7b274c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Read-only / immutable vector methods &lt;br&gt;</div></td></tr>
<tr class="memitem:a9b20bfbb6f69d1a598cf8d1ef643616e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a9b20bfbb6f69d1a598cf8d1ef643616e">freeze</a> ()</td></tr>
<tr class="memdesc:a9b20bfbb6f69d1a598cf8d1ef643616e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn current vector to read-only (immutable vector).  <a href="classbm_1_1bvector.html#a9b20bfbb6f69d1a598cf8d1ef643616e">More...</a><br /></td></tr>
<tr class="separator:a9b20bfbb6f69d1a598cf8d1ef643616e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8dcdc659b4a912cb9e7478bf10f53ac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#ab8dcdc659b4a912cb9e7478bf10f53ac">is_ro</a> () const <a class="el" href="bmdef_8h.html#a40d7d3c011d2128b1f0c392127d7d61e">BMNOEXCEPT</a></td></tr>
<tr class="memdesc:ab8dcdc659b4a912cb9e7478bf10f53ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if vector is read-only.  <a href="classbm_1_1bvector.html#ab8dcdc659b4a912cb9e7478bf10f53ac">More...</a><br /></td></tr>
<tr class="separator:ab8dcdc659b4a912cb9e7478bf10f53ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Bit access/modification methods &lt;br&gt;</div></td></tr>
<tr class="memitem:a6dfc9af9e9041405cbd29394121c4eb6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a6dfc9af9e9041405cbd29394121c4eb6">set_bit</a> (<a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> n, bool val=true)</td></tr>
<tr class="memdesc:a6dfc9af9e9041405cbd29394121c4eb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets bit n.  <a href="classbm_1_1bvector.html#a6dfc9af9e9041405cbd29394121c4eb6">More...</a><br /></td></tr>
<tr class="separator:a6dfc9af9e9041405cbd29394121c4eb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ad7f4b32fd00b9f267db403d13fd53a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a2ad7f4b32fd00b9f267db403d13fd53a">set_bit_and</a> (<a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> n, bool val=true)</td></tr>
<tr class="memdesc:a2ad7f4b32fd00b9f267db403d13fd53a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets bit n using bit AND with the provided value.  <a href="classbm_1_1bvector.html#a2ad7f4b32fd00b9f267db403d13fd53a">More...</a><br /></td></tr>
<tr class="separator:a2ad7f4b32fd00b9f267db403d13fd53a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afef7a91140cfeb7e28698f8bbda2bdd6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#afef7a91140cfeb7e28698f8bbda2bdd6">inc</a> (<a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> n)</td></tr>
<tr class="memdesc:afef7a91140cfeb7e28698f8bbda2bdd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the specified element.  <a href="classbm_1_1bvector.html#afef7a91140cfeb7e28698f8bbda2bdd6">More...</a><br /></td></tr>
<tr class="separator:afef7a91140cfeb7e28698f8bbda2bdd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad93c93b81d5d1de52571c156fb3142a8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#ad93c93b81d5d1de52571c156fb3142a8">set_bit_conditional</a> (<a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> n, bool val, bool condition)</td></tr>
<tr class="memdesc:ad93c93b81d5d1de52571c156fb3142a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets bit n only if current value equals the condition.  <a href="classbm_1_1bvector.html#ad93c93b81d5d1de52571c156fb3142a8">More...</a><br /></td></tr>
<tr class="separator:ad93c93b81d5d1de52571c156fb3142a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b4259a5cc4ebd8953832c696e24f02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a52b4259a5cc4ebd8953832c696e24f02">set</a> (<a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> n, bool val=true)</td></tr>
<tr class="memdesc:a52b4259a5cc4ebd8953832c696e24f02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets bit n if val is true, clears bit n if val is false.  <a href="classbm_1_1bvector.html#a52b4259a5cc4ebd8953832c696e24f02">More...</a><br /></td></tr>
<tr class="separator:a52b4259a5cc4ebd8953832c696e24f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a948743fdaf254dfc9d946b75c5e301a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a948743fdaf254dfc9d946b75c5e301a0">set</a> ()</td></tr>
<tr class="memdesc:a948743fdaf254dfc9d946b75c5e301a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets every bit in this bitset to 1.  <a href="classbm_1_1bvector.html#a948743fdaf254dfc9d946b75c5e301a0">More...</a><br /></td></tr>
<tr class="separator:a948743fdaf254dfc9d946b75c5e301a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab48294badc50633015b10ce9b890772f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#ab48294badc50633015b10ce9b890772f">set</a> (const <a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> *ids, <a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> ids_size, <a class="el" href="group__bvector.html#ga04a7a7cda4bf04cd107e198b3b1e4ed8">bm::sort_order</a> so=<a class="el" href="group__bvector.html#gga04a7a7cda4bf04cd107e198b3b1e4ed8a981e9b62bb43cc0388f268f1041f9293">bm::BM_UNKNOWN</a>)</td></tr>
<tr class="memdesc:ab48294badc50633015b10ce9b890772f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set list of bits in this bitset to 1.  <a href="classbm_1_1bvector.html#ab48294badc50633015b10ce9b890772f">More...</a><br /></td></tr>
<tr class="separator:ab48294badc50633015b10ce9b890772f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae79e966df54b3083fb14519f74a800af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#ae79e966df54b3083fb14519f74a800af">keep</a> (const <a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> *ids, <a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> ids_size, <a class="el" href="group__bvector.html#ga04a7a7cda4bf04cd107e198b3b1e4ed8">bm::sort_order</a> so=<a class="el" href="group__bvector.html#gga04a7a7cda4bf04cd107e198b3b1e4ed8a981e9b62bb43cc0388f268f1041f9293">bm::BM_UNKNOWN</a>)</td></tr>
<tr class="memdesc:ae79e966df54b3083fb14519f74a800af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keep list of bits in this bitset, others are cleared.  <a href="classbm_1_1bvector.html#ae79e966df54b3083fb14519f74a800af">More...</a><br /></td></tr>
<tr class="separator:ae79e966df54b3083fb14519f74a800af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6f13fa4ba188585e5c5d4e89843a44e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#ac6f13fa4ba188585e5c5d4e89843a44e">clear</a> (const <a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> *ids, <a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> ids_size, <a class="el" href="group__bvector.html#ga04a7a7cda4bf04cd107e198b3b1e4ed8">bm::sort_order</a> so=<a class="el" href="group__bvector.html#gga04a7a7cda4bf04cd107e198b3b1e4ed8a981e9b62bb43cc0388f268f1041f9293">bm::BM_UNKNOWN</a>)</td></tr>
<tr class="memdesc:ac6f13fa4ba188585e5c5d4e89843a44e"><td class="mdescLeft">&#160;</td><td class="mdescRight">clear list of bits in this bitset  <a href="classbm_1_1bvector.html#ac6f13fa4ba188585e5c5d4e89843a44e">More...</a><br /></td></tr>
<tr class="separator:ac6f13fa4ba188585e5c5d4e89843a44e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff4c0900eed72eaccff6f5804e33ce97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#aff4c0900eed72eaccff6f5804e33ce97">set_bit_no_check</a> (<a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> n)</td></tr>
<tr class="memdesc:aff4c0900eed72eaccff6f5804e33ce97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set bit without checking preconditions (size, etc)  <a href="classbm_1_1bvector.html#aff4c0900eed72eaccff6f5804e33ce97">More...</a><br /></td></tr>
<tr class="separator:aff4c0900eed72eaccff6f5804e33ce97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab4aa312f9de74d4256790680ac5b663"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#aab4aa312f9de74d4256790680ac5b663">set_bit_no_check</a> (<a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> n, bool val)</td></tr>
<tr class="memdesc:aab4aa312f9de74d4256790680ac5b663"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set specified bit without checking preconditions (size, etc)  <a href="classbm_1_1bvector.html#aab4aa312f9de74d4256790680ac5b663">More...</a><br /></td></tr>
<tr class="separator:aab4aa312f9de74d4256790680ac5b663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb2ecaa1a55856533e6b4afbf788eae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#aafb2ecaa1a55856533e6b4afbf788eae">set_range</a> (<a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> left, <a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> right, bool value=true)</td></tr>
<tr class="memdesc:aafb2ecaa1a55856533e6b4afbf788eae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all bits in the specified closed interval [left,right] Interval must be inside the bvector's size. This method DOES NOT resize vector.  <a href="classbm_1_1bvector.html#aafb2ecaa1a55856533e6b4afbf788eae">More...</a><br /></td></tr>
<tr class="separator:aafb2ecaa1a55856533e6b4afbf788eae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81d21e99befe6e54a0fb33c0778cf1f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a81d21e99befe6e54a0fb33c0778cf1f0">clear_range</a> (<a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> left, <a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> right)</td></tr>
<tr class="memdesc:a81d21e99befe6e54a0fb33c0778cf1f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all bits to zero in the specified closed interval [left,right] Interval must be inside the bvector's size. This method DOES NOT resize vector.  <a href="classbm_1_1bvector.html#a81d21e99befe6e54a0fb33c0778cf1f0">More...</a><br /></td></tr>
<tr class="separator:a81d21e99befe6e54a0fb33c0778cf1f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7595276e924423bc734c4fd74113f1b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a7595276e924423bc734c4fd74113f1b5">keep_range</a> (<a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> left, <a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> right)</td></tr>
<tr class="memdesc:a7595276e924423bc734c4fd74113f1b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all bits to zero outside of the closed interval [left,right] Expected result: 00000...0[left, right]0....0000.  <a href="classbm_1_1bvector.html#a7595276e924423bc734c4fd74113f1b5">More...</a><br /></td></tr>
<tr class="separator:a7595276e924423bc734c4fd74113f1b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7978570375ae288a6893d7b4d673769"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#ab7978570375ae288a6893d7b4d673769">copy_range</a> (const <a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;<a class="el" href="sample6_8cpp.html#ac07bb102df543a0c581493c5f35b2129">bvect</a>, <a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> left, <a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> right)</td></tr>
<tr class="memdesc:ab7978570375ae288a6893d7b4d673769"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy all bits in the specified closed interval [left,right].  <a href="classbm_1_1bvector.html#ab7978570375ae288a6893d7b4d673769">More...</a><br /></td></tr>
<tr class="separator:ab7978570375ae288a6893d7b4d673769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a352a4c7989b9a36c986d9d0302e9ad9e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a352a4c7989b9a36c986d9d0302e9ad9e">clear_bit</a> (<a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> n)</td></tr>
<tr class="memdesc:a352a4c7989b9a36c986d9d0302e9ad9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears bit n.  <a href="classbm_1_1bvector.html#a352a4c7989b9a36c986d9d0302e9ad9e">More...</a><br /></td></tr>
<tr class="separator:a352a4c7989b9a36c986d9d0302e9ad9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae090add70219316e9c0b3eb914b9cb8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#ae090add70219316e9c0b3eb914b9cb8e">clear_bit_no_check</a> (<a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> n)</td></tr>
<tr class="memdesc:ae090add70219316e9c0b3eb914b9cb8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears bit n without precondiion checks.  <a href="classbm_1_1bvector.html#ae090add70219316e9c0b3eb914b9cb8e">More...</a><br /></td></tr>
<tr class="separator:ae090add70219316e9c0b3eb914b9cb8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e02adaea0509c3dbde5abbd9e782131"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a4e02adaea0509c3dbde5abbd9e782131">clear</a> (bool free_mem=true) <a class="el" href="bmdef_8h.html#a40d7d3c011d2128b1f0c392127d7d61e">BMNOEXCEPT</a></td></tr>
<tr class="memdesc:a4e02adaea0509c3dbde5abbd9e782131"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears every bit in the bitvector.  <a href="classbm_1_1bvector.html#a4e02adaea0509c3dbde5abbd9e782131">More...</a><br /></td></tr>
<tr class="separator:a4e02adaea0509c3dbde5abbd9e782131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecf6a1e30257fa59d2a25908ad7b4d4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#aecf6a1e30257fa59d2a25908ad7b4d4e">reset</a> () <a class="el" href="bmdef_8h.html#a40d7d3c011d2128b1f0c392127d7d61e">BMNOEXCEPT</a></td></tr>
<tr class="memdesc:aecf6a1e30257fa59d2a25908ad7b4d4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears every bit in the bitvector.  <a href="classbm_1_1bvector.html#aecf6a1e30257fa59d2a25908ad7b4d4e">More...</a><br /></td></tr>
<tr class="separator:aecf6a1e30257fa59d2a25908ad7b4d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8085be85fb9d94426c1b45010e282138"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a8085be85fb9d94426c1b45010e282138">flip</a> (<a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> n)</td></tr>
<tr class="memdesc:a8085be85fb9d94426c1b45010e282138"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flips bit n.  <a href="classbm_1_1bvector.html#a8085be85fb9d94426c1b45010e282138">More...</a><br /></td></tr>
<tr class="separator:a8085be85fb9d94426c1b45010e282138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf87e9eb001e03c8828c7a92d9ab4e90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#aaf87e9eb001e03c8828c7a92d9ab4e90">flip</a> ()</td></tr>
<tr class="memdesc:aaf87e9eb001e03c8828c7a92d9ab4e90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flips all bits.  <a href="classbm_1_1bvector.html#aaf87e9eb001e03c8828c7a92d9ab4e90">More...</a><br /></td></tr>
<tr class="separator:aaf87e9eb001e03c8828c7a92d9ab4e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fbb5c0bd6f4b05712ee7701dcd1fe1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbm_1_1bvector_1_1insert__iterator.html">insert_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a6fbb5c0bd6f4b05712ee7701dcd1fe1e">inserter</a> ()</td></tr>
<tr class="memdesc:a6fbb5c0bd6f4b05712ee7701dcd1fe1e"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="classbm_1_1bvector.html#a6fbb5c0bd6f4b05712ee7701dcd1fe1e">More...</a><br /></td></tr>
<tr class="separator:a6fbb5c0bd6f4b05712ee7701dcd1fe1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Size and capacity</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p >By default bvector is dynamically sized, manual control methods available </p>
</div></td></tr>
<tr class="memitem:a2f4d04c5a506faa42a6ce36dfc6c445b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a2f4d04c5a506faa42a6ce36dfc6c445b">size</a> () const <a class="el" href="bmdef_8h.html#a40d7d3c011d2128b1f0c392127d7d61e">BMNOEXCEPT</a></td></tr>
<tr class="memdesc:a2f4d04c5a506faa42a6ce36dfc6c445b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns bvector's capacity (number of bits it can store)  <a href="classbm_1_1bvector.html#a2f4d04c5a506faa42a6ce36dfc6c445b">More...</a><br /></td></tr>
<tr class="separator:a2f4d04c5a506faa42a6ce36dfc6c445b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56b7573c759e51c8943cf95a82a5b9d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a56b7573c759e51c8943cf95a82a5b9d6">resize</a> (<a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> new_size)</td></tr>
<tr class="memdesc:a56b7573c759e51c8943cf95a82a5b9d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change size of the bvector.  <a href="classbm_1_1bvector.html#a56b7573c759e51c8943cf95a82a5b9d6">More...</a><br /></td></tr>
<tr class="separator:a56b7573c759e51c8943cf95a82a5b9d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Population counting, ranks, ranges and intervals</div></td></tr>
<tr class="memitem:a3009ba9b116f13f4933a48641f3a695d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a3009ba9b116f13f4933a48641f3a695d">count</a> () const <a class="el" href="bmdef_8h.html#a40d7d3c011d2128b1f0c392127d7d61e">BMNOEXCEPT</a></td></tr>
<tr class="memdesc:a3009ba9b116f13f4933a48641f3a695d"><td class="mdescLeft">&#160;</td><td class="mdescRight">population count (count of ON bits)  <a href="classbm_1_1bvector.html#a3009ba9b116f13f4933a48641f3a695d">More...</a><br /></td></tr>
<tr class="separator:a3009ba9b116f13f4933a48641f3a695d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d8a2e8d82811acaa152d1378719ff5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbm_1_1bvector.html#ac11e61368363493754cbe97b69a1ca71">block_idx_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#ac9d8a2e8d82811acaa152d1378719ff5">count_blocks</a> (unsigned *arr) const <a class="el" href="bmdef_8h.html#a40d7d3c011d2128b1f0c392127d7d61e">BMNOEXCEPT</a></td></tr>
<tr class="memdesc:ac9d8a2e8d82811acaa152d1378719ff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bitcount values for all bvector blocks.  <a href="classbm_1_1bvector.html#ac9d8a2e8d82811acaa152d1378719ff5">More...</a><br /></td></tr>
<tr class="separator:ac9d8a2e8d82811acaa152d1378719ff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99395aaa8ab689455054bda9b261de60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a99395aaa8ab689455054bda9b261de60">count_range</a> (<a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> left, <a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> right, const <a class="el" href="classbm_1_1bvector.html#ac9ed62250af37ade811aaf20b7a8d9a2">rs_index_type</a> &amp;rs_idx) const <a class="el" href="bmdef_8h.html#a40d7d3c011d2128b1f0c392127d7d61e">BMNOEXCEPT</a></td></tr>
<tr class="memdesc:a99395aaa8ab689455054bda9b261de60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns count of 1 bits in the given range [left..right] Uses rank-select index to accelerate the search.  <a href="classbm_1_1bvector.html#a99395aaa8ab689455054bda9b261de60">More...</a><br /></td></tr>
<tr class="separator:a99395aaa8ab689455054bda9b261de60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81785984718d65787b5c3f32216d9e7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a81785984718d65787b5c3f32216d9e7d">count_range</a> (<a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> left, <a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> right) const <a class="el" href="bmdef_8h.html#a40d7d3c011d2128b1f0c392127d7d61e">BMNOEXCEPT</a></td></tr>
<tr class="memdesc:a81785984718d65787b5c3f32216d9e7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns count of 1 bits in the given range [left..right].  <a href="classbm_1_1bvector.html#a81785984718d65787b5c3f32216d9e7d">More...</a><br /></td></tr>
<tr class="separator:a81785984718d65787b5c3f32216d9e7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaf5944b67f0b8f2a767732753e08b0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#acaf5944b67f0b8f2a767732753e08b0d">count_range_no_check</a> (<a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> left, <a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> right) const <a class="el" href="bmdef_8h.html#a40d7d3c011d2128b1f0c392127d7d61e">BMNOEXCEPT</a></td></tr>
<tr class="memdesc:acaf5944b67f0b8f2a767732753e08b0d"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="classbm_1_1bvector.html#acaf5944b67f0b8f2a767732753e08b0d">More...</a><br /></td></tr>
<tr class="separator:acaf5944b67f0b8f2a767732753e08b0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75aa9c01449453121996398c8bc54ec7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a75aa9c01449453121996398c8bc54ec7">count_range_no_check</a> (<a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> left, <a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> right, const <a class="el" href="classbm_1_1bvector.html#ac9ed62250af37ade811aaf20b7a8d9a2">rs_index_type</a> &amp;rs_idx) const <a class="el" href="bmdef_8h.html#a40d7d3c011d2128b1f0c392127d7d61e">BMNOEXCEPT</a></td></tr>
<tr class="memdesc:a75aa9c01449453121996398c8bc54ec7"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="classbm_1_1bvector.html#a75aa9c01449453121996398c8bc54ec7">More...</a><br /></td></tr>
<tr class="separator:a75aa9c01449453121996398c8bc54ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d36a1f08ff5c39c55b6bbdfe6251001"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a7d36a1f08ff5c39c55b6bbdfe6251001">is_all_one_range</a> (<a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> left, <a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> right) const <a class="el" href="bmdef_8h.html#a40d7d3c011d2128b1f0c392127d7d61e">BMNOEXCEPT</a></td></tr>
<tr class="memdesc:a7d36a1f08ff5c39c55b6bbdfe6251001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if all bits in the range are 1s (saturated interval) Function uses closed interval [left, right].  <a href="classbm_1_1bvector.html#a7d36a1f08ff5c39c55b6bbdfe6251001">More...</a><br /></td></tr>
<tr class="separator:a7d36a1f08ff5c39c55b6bbdfe6251001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a530f12c9a00799ecbe9abd276a7ae619"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a530f12c9a00799ecbe9abd276a7ae619">any_range</a> (<a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> left, <a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> right) const <a class="el" href="bmdef_8h.html#a40d7d3c011d2128b1f0c392127d7d61e">BMNOEXCEPT</a></td></tr>
<tr class="memdesc:a530f12c9a00799ecbe9abd276a7ae619"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if any bits in the range are 1s (non-empty interval) Function uses closed interval [left, right].  <a href="classbm_1_1bvector.html#a530f12c9a00799ecbe9abd276a7ae619">More...</a><br /></td></tr>
<tr class="separator:a530f12c9a00799ecbe9abd276a7ae619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb63744a9d6039d9e8daa38cf21e3c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#adfb63744a9d6039d9e8daa38cf21e3c6">build_rs_index</a> (<a class="el" href="classbm_1_1bvector.html#ac9ed62250af37ade811aaf20b7a8d9a2">rs_index_type</a> *rs_idx, <a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; *bv_blocks=0) const</td></tr>
<tr class="memdesc:adfb63744a9d6039d9e8daa38cf21e3c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute running total of all blocks in bit vector (rank-select index)  <a href="classbm_1_1bvector.html#adfb63744a9d6039d9e8daa38cf21e3c6">More...</a><br /></td></tr>
<tr class="separator:adfb63744a9d6039d9e8daa38cf21e3c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3e0e88f17cc86b58e006186955c461b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#ad3e0e88f17cc86b58e006186955c461b">count_to</a> (<a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> n, const <a class="el" href="classbm_1_1bvector.html#ac9ed62250af37ade811aaf20b7a8d9a2">rs_index_type</a> &amp;rs_idx) const <a class="el" href="bmdef_8h.html#a40d7d3c011d2128b1f0c392127d7d61e">BMNOEXCEPT</a></td></tr>
<tr class="memdesc:ad3e0e88f17cc86b58e006186955c461b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns count of 1 bits (population) in [0..right] range.  <a href="classbm_1_1bvector.html#ad3e0e88f17cc86b58e006186955c461b">More...</a><br /></td></tr>
<tr class="separator:ad3e0e88f17cc86b58e006186955c461b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65b175606ea472e33b9b6af1f7b04ee7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a65b175606ea472e33b9b6af1f7b04ee7">rank</a> (<a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> n, const <a class="el" href="classbm_1_1bvector.html#ac9ed62250af37ade811aaf20b7a8d9a2">rs_index_type</a> &amp;rs_idx) const <a class="el" href="bmdef_8h.html#a40d7d3c011d2128b1f0c392127d7d61e">BMNOEXCEPT</a></td></tr>
<tr class="memdesc:a65b175606ea472e33b9b6af1f7b04ee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns rank of specified bit position (same as <a class="el" href="classbm_1_1bvector.html#ad3e0e88f17cc86b58e006186955c461b" title="Returns count of 1 bits (population) in [0..right] range.">count_to()</a>)  <a href="classbm_1_1bvector.html#a65b175606ea472e33b9b6af1f7b04ee7">More...</a><br /></td></tr>
<tr class="separator:a65b175606ea472e33b9b6af1f7b04ee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc7ead9fd4044f190d45946762a1011a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#abc7ead9fd4044f190d45946762a1011a">rank_corrected</a> (<a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> n, const <a class="el" href="classbm_1_1bvector.html#ac9ed62250af37ade811aaf20b7a8d9a2">rs_index_type</a> &amp;rs_idx) const <a class="el" href="bmdef_8h.html#a40d7d3c011d2128b1f0c392127d7d61e">BMNOEXCEPT</a></td></tr>
<tr class="memdesc:abc7ead9fd4044f190d45946762a1011a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns rank corrceted by the requested border value (as -1)  <a href="classbm_1_1bvector.html#abc7ead9fd4044f190d45946762a1011a">More...</a><br /></td></tr>
<tr class="separator:abc7ead9fd4044f190d45946762a1011a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a649167f4b128d053d6312a3a00114403"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a649167f4b128d053d6312a3a00114403">count_to_test</a> (<a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> n, const <a class="el" href="classbm_1_1bvector.html#ac9ed62250af37ade811aaf20b7a8d9a2">rs_index_type</a> &amp;rs_idx) const <a class="el" href="bmdef_8h.html#a40d7d3c011d2128b1f0c392127d7d61e">BMNOEXCEPT</a></td></tr>
<tr class="memdesc:a649167f4b128d053d6312a3a00114403"><td class="mdescLeft">&#160;</td><td class="mdescRight">popcount in [0..right] range if test(right) == true  <a href="classbm_1_1bvector.html#a649167f4b128d053d6312a3a00114403">More...</a><br /></td></tr>
<tr class="separator:a649167f4b128d053d6312a3a00114403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af491626f7200e6ab4e3c9e8d5f7d80fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#af491626f7200e6ab4e3c9e8d5f7d80fb">recalc_count</a> () <a class="el" href="bmdef_8h.html#a40d7d3c011d2128b1f0c392127d7d61e">BMNOEXCEPT</a></td></tr>
<tr class="memdesc:af491626f7200e6ab4e3c9e8d5f7d80fb"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="classbm_1_1bvector.html#af491626f7200e6ab4e3c9e8d5f7d80fb">More...</a><br /></td></tr>
<tr class="separator:af491626f7200e6ab4e3c9e8d5f7d80fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6352dfd0b04f7d5541c47b5335706c1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a6352dfd0b04f7d5541c47b5335706c1b">forget_count</a> () <a class="el" href="bmdef_8h.html#a40d7d3c011d2128b1f0c392127d7d61e">BMNOEXCEPT</a></td></tr>
<tr class="memdesc:a6352dfd0b04f7d5541c47b5335706c1b"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="classbm_1_1bvector.html#a6352dfd0b04f7d5541c47b5335706c1b">More...</a><br /></td></tr>
<tr class="separator:a6352dfd0b04f7d5541c47b5335706c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Bit access (read-only) &lt;br&gt;</div></td></tr>
<tr class="memitem:af2553cf458874b088e0675e093289d89"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#af2553cf458874b088e0675e093289d89">get_bit</a> (<a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> n) const <a class="el" href="bmdef_8h.html#a40d7d3c011d2128b1f0c392127d7d61e">BMNOEXCEPT</a></td></tr>
<tr class="memdesc:af2553cf458874b088e0675e093289d89"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if bit n is set and false is bit n is 0.  <a href="classbm_1_1bvector.html#af2553cf458874b088e0675e093289d89">More...</a><br /></td></tr>
<tr class="separator:af2553cf458874b088e0675e093289d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16d902c3df4aa6aa88d8e137af4a4b9b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a16d902c3df4aa6aa88d8e137af4a4b9b">test</a> (<a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> n) const <a class="el" href="bmdef_8h.html#a40d7d3c011d2128b1f0c392127d7d61e">BMNOEXCEPT</a></td></tr>
<tr class="memdesc:a16d902c3df4aa6aa88d8e137af4a4b9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if bit n is set and false is bit n is 0.  <a href="classbm_1_1bvector.html#a16d902c3df4aa6aa88d8e137af4a4b9b">More...</a><br /></td></tr>
<tr class="separator:a16d902c3df4aa6aa88d8e137af4a4b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">bit-shift and insert operations &lt;br&gt;</div></td></tr>
<tr class="memitem:aacf96380ec223d52340a60ec57c8bdbd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#aacf96380ec223d52340a60ec57c8bdbd">shift_right</a> ()</td></tr>
<tr class="memdesc:aacf96380ec223d52340a60ec57c8bdbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift right by 1 bit, fill with zero return carry out.  <a href="classbm_1_1bvector.html#aacf96380ec223d52340a60ec57c8bdbd">More...</a><br /></td></tr>
<tr class="separator:aacf96380ec223d52340a60ec57c8bdbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9730694fb531221dcde1b685a0b2e4b1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a9730694fb531221dcde1b685a0b2e4b1">shift_left</a> ()</td></tr>
<tr class="memdesc:a9730694fb531221dcde1b685a0b2e4b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift left by 1 bit, fill with zero return carry out.  <a href="classbm_1_1bvector.html#a9730694fb531221dcde1b685a0b2e4b1">More...</a><br /></td></tr>
<tr class="separator:a9730694fb531221dcde1b685a0b2e4b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aa18488051520338d0787c4867d944d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a3aa18488051520338d0787c4867d944d">insert</a> (<a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> n, bool value)</td></tr>
<tr class="memdesc:a3aa18488051520338d0787c4867d944d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert bit into specified position All the vector content after insert position is shifted right.  <a href="classbm_1_1bvector.html#a3aa18488051520338d0787c4867d944d">More...</a><br /></td></tr>
<tr class="separator:a3aa18488051520338d0787c4867d944d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab20d0778a1d4885fc15bdf2126493349"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#ab20d0778a1d4885fc15bdf2126493349">erase</a> (<a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> n)</td></tr>
<tr class="memdesc:ab20d0778a1d4885fc15bdf2126493349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase bit in the specified position All the vector content after erase position is shifted left.  <a href="classbm_1_1bvector.html#ab20d0778a1d4885fc15bdf2126493349">More...</a><br /></td></tr>
<tr class="separator:ab20d0778a1d4885fc15bdf2126493349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Check for empty-ness of container &lt;br&gt;</div></td></tr>
<tr class="memitem:a69729bae3fca407ff1228cf2db761adb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a69729bae3fca407ff1228cf2db761adb">any</a> () const <a class="el" href="bmdef_8h.html#a40d7d3c011d2128b1f0c392127d7d61e">BMNOEXCEPT</a></td></tr>
<tr class="memdesc:a69729bae3fca407ff1228cf2db761adb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if any bits in this bitset are set, and otherwise returns false.  <a href="classbm_1_1bvector.html#a69729bae3fca407ff1228cf2db761adb">More...</a><br /></td></tr>
<tr class="separator:a69729bae3fca407ff1228cf2db761adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6833053b4c459557138b02e8f0589db"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#ad6833053b4c459557138b02e8f0589db">none</a> () const <a class="el" href="bmdef_8h.html#a40d7d3c011d2128b1f0c392127d7d61e">BMNOEXCEPT</a></td></tr>
<tr class="memdesc:ad6833053b4c459557138b02e8f0589db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if no bits are set, otherwise returns false.  <a href="classbm_1_1bvector.html#ad6833053b4c459557138b02e8f0589db">More...</a><br /></td></tr>
<tr class="separator:ad6833053b4c459557138b02e8f0589db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a746b0a896ba6286d0b8fefeb69fa880b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a746b0a896ba6286d0b8fefeb69fa880b">empty</a> () const <a class="el" href="bmdef_8h.html#a40d7d3c011d2128b1f0c392127d7d61e">BMNOEXCEPT</a></td></tr>
<tr class="memdesc:a746b0a896ba6286d0b8fefeb69fa880b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the set is empty (no bits are set, otherwise returns false) Please note that this is NOT a size check, it is an empty SET check (absense of 1s)  <a href="classbm_1_1bvector.html#a746b0a896ba6286d0b8fefeb69fa880b">More...</a><br /></td></tr>
<tr class="separator:a746b0a896ba6286d0b8fefeb69fa880b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Scan and find bits and indexes</div></td></tr>
<tr class="memitem:a08093c98bb6dfe27708357801aae7280"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a08093c98bb6dfe27708357801aae7280">find</a> (<a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> &amp;pos) const <a class="el" href="bmdef_8h.html#a40d7d3c011d2128b1f0c392127d7d61e">BMNOEXCEPT</a></td></tr>
<tr class="memdesc:a08093c98bb6dfe27708357801aae7280"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds index of first 1 bit.  <a href="classbm_1_1bvector.html#a08093c98bb6dfe27708357801aae7280">More...</a><br /></td></tr>
<tr class="separator:a08093c98bb6dfe27708357801aae7280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd50f443d3c80491293dad2b880a06de"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#afd50f443d3c80491293dad2b880a06de">find</a> (<a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> from, <a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> &amp;pos) const <a class="el" href="bmdef_8h.html#a40d7d3c011d2128b1f0c392127d7d61e">BMNOEXCEPT</a></td></tr>
<tr class="memdesc:afd50f443d3c80491293dad2b880a06de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find index of 1 bit starting from position.  <a href="classbm_1_1bvector.html#afd50f443d3c80491293dad2b880a06de">More...</a><br /></td></tr>
<tr class="separator:afd50f443d3c80491293dad2b880a06de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ab6964e14405327936d183a11dcd455"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a9ab6964e14405327936d183a11dcd455">get_first</a> () const <a class="el" href="bmdef_8h.html#a40d7d3c011d2128b1f0c392127d7d61e">BMNOEXCEPT</a></td></tr>
<tr class="memdesc:a9ab6964e14405327936d183a11dcd455"><td class="mdescLeft">&#160;</td><td class="mdescRight">find first 1 bit in vector. Function may return 0 and this requires an extra check if bit 0 is actually set or bit-vector is empty  <a href="classbm_1_1bvector.html#a9ab6964e14405327936d183a11dcd455">More...</a><br /></td></tr>
<tr class="separator:a9ab6964e14405327936d183a11dcd455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a09e493d97f5a66b6ec4e14e04cf118"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a3a09e493d97f5a66b6ec4e14e04cf118">get_next</a> (<a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> prev) const <a class="el" href="bmdef_8h.html#a40d7d3c011d2128b1f0c392127d7d61e">BMNOEXCEPT</a></td></tr>
<tr class="memdesc:a3a09e493d97f5a66b6ec4e14e04cf118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the number of the next bit ON.  <a href="classbm_1_1bvector.html#a3a09e493d97f5a66b6ec4e14e04cf118">More...</a><br /></td></tr>
<tr class="separator:a3a09e493d97f5a66b6ec4e14e04cf118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4da9b61aca4523c7523136e2db68aa8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#ab4da9b61aca4523c7523136e2db68aa8">extract_next</a> (<a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> prev)</td></tr>
<tr class="memdesc:ab4da9b61aca4523c7523136e2db68aa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the number of the next bit ON and sets it to 0.  <a href="classbm_1_1bvector.html#ab4da9b61aca4523c7523136e2db68aa8">More...</a><br /></td></tr>
<tr class="separator:ab4da9b61aca4523c7523136e2db68aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada8a47cb4a23e1402a7a6d728e35d50f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#ada8a47cb4a23e1402a7a6d728e35d50f">find_reverse</a> (<a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> &amp;pos) const <a class="el" href="bmdef_8h.html#a40d7d3c011d2128b1f0c392127d7d61e">BMNOEXCEPT</a></td></tr>
<tr class="memdesc:ada8a47cb4a23e1402a7a6d728e35d50f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds last index of 1 bit.  <a href="classbm_1_1bvector.html#ada8a47cb4a23e1402a7a6d728e35d50f">More...</a><br /></td></tr>
<tr class="separator:ada8a47cb4a23e1402a7a6d728e35d50f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65a5b7902932108922c56e4803e67ec9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a65a5b7902932108922c56e4803e67ec9">find_reverse</a> (<a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> from, <a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> &amp;pos) const <a class="el" href="bmdef_8h.html#a40d7d3c011d2128b1f0c392127d7d61e">BMNOEXCEPT</a></td></tr>
<tr class="memdesc:a65a5b7902932108922c56e4803e67ec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse finds next(prev) index of 1 bit.  <a href="classbm_1_1bvector.html#a65a5b7902932108922c56e4803e67ec9">More...</a><br /></td></tr>
<tr class="separator:a65a5b7902932108922c56e4803e67ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a509670c79426e6388396c7720519f5c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a509670c79426e6388396c7720519f5c1">find_range</a> (<a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> &amp;<a class="el" href="classbm_1_1bvector.html#a86b939f3aed555dc073e8c26e9efea71">first</a>, <a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> &amp;last) const <a class="el" href="bmdef_8h.html#a40d7d3c011d2128b1f0c392127d7d61e">BMNOEXCEPT</a></td></tr>
<tr class="memdesc:a509670c79426e6388396c7720519f5c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds dynamic range of bit-vector [first, last].  <a href="classbm_1_1bvector.html#a509670c79426e6388396c7720519f5c1">More...</a><br /></td></tr>
<tr class="separator:a509670c79426e6388396c7720519f5c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b2b0eb6ec338ab789ec6508cfab7ff0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a9b2b0eb6ec338ab789ec6508cfab7ff0">find_rank</a> (<a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> <a class="el" href="classbm_1_1bvector.html#a65b175606ea472e33b9b6af1f7b04ee7">rank</a>, <a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> from, <a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> &amp;pos) const <a class="el" href="bmdef_8h.html#a40d7d3c011d2128b1f0c392127d7d61e">BMNOEXCEPT</a></td></tr>
<tr class="memdesc:a9b2b0eb6ec338ab789ec6508cfab7ff0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find bit-vector position for the specified rank(bitcount)  <a href="classbm_1_1bvector.html#a9b2b0eb6ec338ab789ec6508cfab7ff0">More...</a><br /></td></tr>
<tr class="separator:a9b2b0eb6ec338ab789ec6508cfab7ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf0fad1e7ecb0704c2e640cdeb71ab82"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#aaf0fad1e7ecb0704c2e640cdeb71ab82">find_rank</a> (<a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> <a class="el" href="classbm_1_1bvector.html#a65b175606ea472e33b9b6af1f7b04ee7">rank</a>, <a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> from, <a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> &amp;pos, const <a class="el" href="classbm_1_1bvector.html#ac9ed62250af37ade811aaf20b7a8d9a2">rs_index_type</a> &amp;rs_idx) const <a class="el" href="bmdef_8h.html#a40d7d3c011d2128b1f0c392127d7d61e">BMNOEXCEPT</a></td></tr>
<tr class="memdesc:aaf0fad1e7ecb0704c2e640cdeb71ab82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find bit-vector position for the specified rank(bitcount)  <a href="classbm_1_1bvector.html#aaf0fad1e7ecb0704c2e640cdeb71ab82">More...</a><br /></td></tr>
<tr class="separator:aaf0fad1e7ecb0704c2e640cdeb71ab82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ded07c26c000250baf5215c29c3b602"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a7ded07c26c000250baf5215c29c3b602">select</a> (<a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> <a class="el" href="classbm_1_1bvector.html#a65b175606ea472e33b9b6af1f7b04ee7">rank</a>, <a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> &amp;pos, const <a class="el" href="classbm_1_1bvector.html#ac9ed62250af37ade811aaf20b7a8d9a2">rs_index_type</a> &amp;rs_idx) const <a class="el" href="bmdef_8h.html#a40d7d3c011d2128b1f0c392127d7d61e">BMNOEXCEPT</a></td></tr>
<tr class="memdesc:a7ded07c26c000250baf5215c29c3b602"><td class="mdescLeft">&#160;</td><td class="mdescRight">select bit-vector position for the specified rank(bitcount)  <a href="classbm_1_1bvector.html#a7ded07c26c000250baf5215c29c3b602">More...</a><br /></td></tr>
<tr class="separator:a7ded07c26c000250baf5215c29c3b602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Algebra of Sets operations &lt;br&gt;</div></td></tr>
<tr class="memitem:a001b183876bd7ab940f711bb48263d47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a001b183876bd7ab940f711bb48263d47">bit_or</a> (const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;bv1, const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;bv2, typename <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::<a class="el" href="classbm_1_1bvector.html#a05f1e977cb5e6208838afc7e7b69e5f0">optmode</a> opt_mode=<a class="el" href="classbm_1_1bvector.html#a05f1e977cb5e6208838afc7e7b69e5f0afc03833a1770728dde103c7364b12660">opt_none</a>)</td></tr>
<tr class="memdesc:a001b183876bd7ab940f711bb48263d47"><td class="mdescLeft">&#160;</td><td class="mdescRight">3-operand OR : this := bv1 OR bv2  <a href="classbm_1_1bvector.html#a001b183876bd7ab940f711bb48263d47">More...</a><br /></td></tr>
<tr class="separator:a001b183876bd7ab940f711bb48263d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af34934a5a60a21f364b8df4dfc0f7247"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#af34934a5a60a21f364b8df4dfc0f7247">bit_xor</a> (const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;bv1, const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;bv2, typename <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::<a class="el" href="classbm_1_1bvector.html#a05f1e977cb5e6208838afc7e7b69e5f0">optmode</a> opt_mode=<a class="el" href="classbm_1_1bvector.html#a05f1e977cb5e6208838afc7e7b69e5f0afc03833a1770728dde103c7364b12660">opt_none</a>)</td></tr>
<tr class="memdesc:af34934a5a60a21f364b8df4dfc0f7247"><td class="mdescLeft">&#160;</td><td class="mdescRight">3-operand XOR : this := bv1 XOR bv2  <a href="classbm_1_1bvector.html#af34934a5a60a21f364b8df4dfc0f7247">More...</a><br /></td></tr>
<tr class="separator:af34934a5a60a21f364b8df4dfc0f7247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37c1ccb4755c61450311918ad3330aa6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a37c1ccb4755c61450311918ad3330aa6">bit_and</a> (const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;bv1, const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;bv2, typename <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::<a class="el" href="classbm_1_1bvector.html#a05f1e977cb5e6208838afc7e7b69e5f0">optmode</a> opt_mode=<a class="el" href="classbm_1_1bvector.html#a05f1e977cb5e6208838afc7e7b69e5f0afc03833a1770728dde103c7364b12660">opt_none</a>)</td></tr>
<tr class="memdesc:a37c1ccb4755c61450311918ad3330aa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">3-operand AND : this := bv1 AND bv2  <a href="classbm_1_1bvector.html#a37c1ccb4755c61450311918ad3330aa6">More...</a><br /></td></tr>
<tr class="separator:a37c1ccb4755c61450311918ad3330aa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7de27b4dad4aa277b074182ab663710"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#ae7de27b4dad4aa277b074182ab663710">bit_or_and</a> (const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;bv1, const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;bv2, typename <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::<a class="el" href="classbm_1_1bvector.html#a05f1e977cb5e6208838afc7e7b69e5f0">optmode</a> opt_mode=<a class="el" href="classbm_1_1bvector.html#a05f1e977cb5e6208838afc7e7b69e5f0afc03833a1770728dde103c7364b12660">opt_none</a>)</td></tr>
<tr class="memdesc:ae7de27b4dad4aa277b074182ab663710"><td class="mdescLeft">&#160;</td><td class="mdescRight">3-operand AND where result is ORed into the terget vector : this |= bv1 AND bv2 TARGET := TARGET OR (BV1 AND BV2)  <a href="classbm_1_1bvector.html#ae7de27b4dad4aa277b074182ab663710">More...</a><br /></td></tr>
<tr class="separator:ae7de27b4dad4aa277b074182ab663710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a0538cdc1ced8502f42c2ca602c0b91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a5a0538cdc1ced8502f42c2ca602c0b91">bit_sub</a> (const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;bv1, const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;bv2, typename <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::<a class="el" href="classbm_1_1bvector.html#a05f1e977cb5e6208838afc7e7b69e5f0">optmode</a> opt_mode=<a class="el" href="classbm_1_1bvector.html#a05f1e977cb5e6208838afc7e7b69e5f0afc03833a1770728dde103c7364b12660">opt_none</a>)</td></tr>
<tr class="memdesc:a5a0538cdc1ced8502f42c2ca602c0b91"><td class="mdescLeft">&#160;</td><td class="mdescRight">3-operand SUB : this := bv1 MINUS bv2 SUBtraction is also known as AND NOT  <a href="classbm_1_1bvector.html#a5a0538cdc1ced8502f42c2ca602c0b91">More...</a><br /></td></tr>
<tr class="separator:a5a0538cdc1ced8502f42c2ca602c0b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee4b63ca79de51765a89a2d37cd6f5bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#aee4b63ca79de51765a89a2d37cd6f5bf">bit_or</a> (const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;bv)</td></tr>
<tr class="memdesc:aee4b63ca79de51765a89a2d37cd6f5bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">2 operand logical OR  <a href="classbm_1_1bvector.html#aee4b63ca79de51765a89a2d37cd6f5bf">More...</a><br /></td></tr>
<tr class="separator:aee4b63ca79de51765a89a2d37cd6f5bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99946dcf231dfed93022197cfb2c327d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a99946dcf231dfed93022197cfb2c327d">bit_and</a> (const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;bv, <a class="el" href="classbm_1_1bvector.html#a05f1e977cb5e6208838afc7e7b69e5f0">optmode</a> opt_mode=<a class="el" href="classbm_1_1bvector.html#a05f1e977cb5e6208838afc7e7b69e5f0afc03833a1770728dde103c7364b12660">opt_none</a>)</td></tr>
<tr class="memdesc:a99946dcf231dfed93022197cfb2c327d"><td class="mdescLeft">&#160;</td><td class="mdescRight">2 operand logical AND  <a href="classbm_1_1bvector.html#a99946dcf231dfed93022197cfb2c327d">More...</a><br /></td></tr>
<tr class="separator:a99946dcf231dfed93022197cfb2c327d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae087c7b4d78f00d7b04ea0e9e4915ba3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#ae087c7b4d78f00d7b04ea0e9e4915ba3">bit_xor</a> (const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;bv)</td></tr>
<tr class="memdesc:ae087c7b4d78f00d7b04ea0e9e4915ba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">2 operand logical XOR  <a href="classbm_1_1bvector.html#ae087c7b4d78f00d7b04ea0e9e4915ba3">More...</a><br /></td></tr>
<tr class="separator:ae087c7b4d78f00d7b04ea0e9e4915ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb5659f54365fb0a7714a3c3282ca481"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#aeb5659f54365fb0a7714a3c3282ca481">bit_sub</a> (const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;bv)</td></tr>
<tr class="memdesc:aeb5659f54365fb0a7714a3c3282ca481"><td class="mdescLeft">&#160;</td><td class="mdescRight">2 operand logical SUB(AND NOT). Also known as MINUS.  <a href="classbm_1_1bvector.html#aeb5659f54365fb0a7714a3c3282ca481">More...</a><br /></td></tr>
<tr class="separator:aeb5659f54365fb0a7714a3c3282ca481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27e95553f358ebebda6b521336682deb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a27e95553f358ebebda6b521336682deb">invert</a> ()</td></tr>
<tr class="memdesc:a27e95553f358ebebda6b521336682deb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invert/NEG all bits It should be noted, invert is affected by <a class="el" href="classbm_1_1bvector.html#a2f4d04c5a506faa42a6ce36dfc6c445b" title="Returns bvector&#39;s capacity (number of bits it can store)">size()</a> if size is set - it only inverts [0..size-1] bits.  <a href="classbm_1_1bvector.html#a27e95553f358ebebda6b521336682deb">More...</a><br /></td></tr>
<tr class="separator:a27e95553f358ebebda6b521336682deb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae57f6d62d1f54eeaa604ae7ce53e0e0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#ae57f6d62d1f54eeaa604ae7ce53e0e0f">combine_operation</a> (const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;<a class="el" href="sample6_8cpp.html#ac07bb102df543a0c581493c5f35b2129">bvect</a>, <a class="el" href="group__bvector.html#ga42405343976ec931388381cea4092bf1">bm::operation</a> opcode)</td></tr>
<tr class="memdesc:ae57f6d62d1f54eeaa604ae7ce53e0e0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">perform a set-algebra operation by operation code  <a href="classbm_1_1bvector.html#ae57f6d62d1f54eeaa604ae7ce53e0e0f">More...</a><br /></td></tr>
<tr class="separator:ae57f6d62d1f54eeaa604ae7ce53e0e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1084ec5fad8c1faf50d31a182dc4287"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#ac1084ec5fad8c1faf50d31a182dc4287">combine_operation_or</a> (const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;<a class="el" href="sample6_8cpp.html#ac07bb102df543a0c581493c5f35b2129">bvect</a>)</td></tr>
<tr class="memdesc:ac1084ec5fad8c1faf50d31a182dc4287"><td class="mdescLeft">&#160;</td><td class="mdescRight">perform a set-algebra operation OR  <a href="classbm_1_1bvector.html#ac1084ec5fad8c1faf50d31a182dc4287">More...</a><br /></td></tr>
<tr class="separator:ac1084ec5fad8c1faf50d31a182dc4287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84bd0af8809c420103c6545b6ea92412"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a84bd0af8809c420103c6545b6ea92412">combine_operation_and</a> (const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;<a class="el" href="sample6_8cpp.html#ac07bb102df543a0c581493c5f35b2129">bvect</a>, <a class="el" href="classbm_1_1bvector.html#a05f1e977cb5e6208838afc7e7b69e5f0">optmode</a> opt_mode)</td></tr>
<tr class="memdesc:a84bd0af8809c420103c6545b6ea92412"><td class="mdescLeft">&#160;</td><td class="mdescRight">perform a set-algebra operation AND  <a href="classbm_1_1bvector.html#a84bd0af8809c420103c6545b6ea92412">More...</a><br /></td></tr>
<tr class="separator:a84bd0af8809c420103c6545b6ea92412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc454e79b5261f7c4859cac74aa81832"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#acc454e79b5261f7c4859cac74aa81832">combine_operation_sub</a> (const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;<a class="el" href="sample6_8cpp.html#ac07bb102df543a0c581493c5f35b2129">bvect</a>)</td></tr>
<tr class="memdesc:acc454e79b5261f7c4859cac74aa81832"><td class="mdescLeft">&#160;</td><td class="mdescRight">perform a set-algebra operation MINUS (AND NOT)  <a href="classbm_1_1bvector.html#acc454e79b5261f7c4859cac74aa81832">More...</a><br /></td></tr>
<tr class="separator:acc454e79b5261f7c4859cac74aa81832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a311f59a89c8b75a252fc7e55400ea2e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a311f59a89c8b75a252fc7e55400ea2e4">combine_operation_xor</a> (const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;<a class="el" href="sample6_8cpp.html#ac07bb102df543a0c581493c5f35b2129">bvect</a>)</td></tr>
<tr class="memdesc:a311f59a89c8b75a252fc7e55400ea2e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">perform a set-algebra operation XOR  <a href="classbm_1_1bvector.html#a311f59a89c8b75a252fc7e55400ea2e4">More...</a><br /></td></tr>
<tr class="separator:a311f59a89c8b75a252fc7e55400ea2e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Iterator-traversal methods &lt;br&gt;</div></td></tr>
<tr class="memitem:a86b939f3aed555dc073e8c26e9efea71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbm_1_1bvector_1_1enumerator.html">enumerator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a86b939f3aed555dc073e8c26e9efea71">first</a> () const</td></tr>
<tr class="memdesc:a86b939f3aed555dc073e8c26e9efea71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns enumerator pointing on the first non-zero bit.  <a href="classbm_1_1bvector.html#a86b939f3aed555dc073e8c26e9efea71">More...</a><br /></td></tr>
<tr class="separator:a86b939f3aed555dc073e8c26e9efea71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a937cd13482984f234a5d94cc638c22b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbm_1_1bvector_1_1enumerator.html">enumerator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a937cd13482984f234a5d94cc638c22b5">end</a> () const</td></tr>
<tr class="memdesc:a937cd13482984f234a5d94cc638c22b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns enumerator pointing on the next bit after the last.  <a href="classbm_1_1bvector.html#a937cd13482984f234a5d94cc638c22b5">More...</a><br /></td></tr>
<tr class="separator:a937cd13482984f234a5d94cc638c22b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae3a8b0367bcec9ea9b24b064e66dee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbm_1_1bvector_1_1enumerator.html">enumerator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#abae3a8b0367bcec9ea9b24b064e66dee">get_enumerator</a> (<a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> pos) const</td></tr>
<tr class="memdesc:abae3a8b0367bcec9ea9b24b064e66dee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns enumerator pointing on specified or the next available bit.  <a href="classbm_1_1bvector.html#abae3a8b0367bcec9ea9b24b064e66dee">More...</a><br /></td></tr>
<tr class="separator:abae3a8b0367bcec9ea9b24b064e66dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Memory management and compression &lt;br&gt;</div></td></tr>
<tr class="memitem:af30532c371bfdc8e2ba02bc2115b004d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#af30532c371bfdc8e2ba02bc2115b004d">calc_stat</a> (struct <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::<a class="el" href="structbm_1_1bvector_1_1statistics.html">statistics</a> *st) const <a class="el" href="bmdef_8h.html#a40d7d3c011d2128b1f0c392127d7d61e">BMNOEXCEPT</a></td></tr>
<tr class="memdesc:af30532c371bfdc8e2ba02bc2115b004d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates bitvector statistics.  <a href="classbm_1_1bvector.html#af30532c371bfdc8e2ba02bc2115b004d">More...</a><br /></td></tr>
<tr class="separator:af30532c371bfdc8e2ba02bc2115b004d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a653ee052b297a49c35344704df67a452"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a653ee052b297a49c35344704df67a452">set_new_blocks_strat</a> (<a class="el" href="group__bvector.html#gad0b87b3b7292383a864d27feaf1c9eff">strategy</a> strat)</td></tr>
<tr class="memdesc:a653ee052b297a49c35344704df67a452"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets new blocks allocation strategy.  <a href="classbm_1_1bvector.html#a653ee052b297a49c35344704df67a452">More...</a><br /></td></tr>
<tr class="separator:a653ee052b297a49c35344704df67a452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a615337f0db4c56d0cf1df85477c9fe41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bvector.html#gad0b87b3b7292383a864d27feaf1c9eff">strategy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a615337f0db4c56d0cf1df85477c9fe41">get_new_blocks_strat</a> () const <a class="el" href="bmdef_8h.html#a40d7d3c011d2128b1f0c392127d7d61e">BMNOEXCEPT</a></td></tr>
<tr class="memdesc:a615337f0db4c56d0cf1df85477c9fe41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns blocks allocation strategy.  <a href="classbm_1_1bvector.html#a615337f0db4c56d0cf1df85477c9fe41">More...</a><br /></td></tr>
<tr class="separator:a615337f0db4c56d0cf1df85477c9fe41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a622e6827d799a561e2f0db28f7ac19d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a622e6827d799a561e2f0db28f7ac19d2">optimize</a> (<a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *temp_block=0, <a class="el" href="classbm_1_1bvector.html#a05f1e977cb5e6208838afc7e7b69e5f0">optmode</a> opt_mode=<a class="el" href="classbm_1_1bvector.html#a05f1e977cb5e6208838afc7e7b69e5f0a99b64b2444e1a8b22a5e89b02dca6001">opt_compress</a>, <a class="el" href="structbm_1_1bvector_1_1statistics.html">statistics</a> *stat=0)</td></tr>
<tr class="memdesc:a622e6827d799a561e2f0db28f7ac19d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimize memory bitvector's memory allocation.  <a href="classbm_1_1bvector.html#a622e6827d799a561e2f0db28f7ac19d2">More...</a><br /></td></tr>
<tr class="separator:a622e6827d799a561e2f0db28f7ac19d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8ebec3020f30fdd4f20cc96b7d211a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#ac8ebec3020f30fdd4f20cc96b7d211a5">optimize_range</a> (<a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> left, <a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> right, <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *temp_block, <a class="el" href="classbm_1_1bvector.html#a05f1e977cb5e6208838afc7e7b69e5f0">optmode</a> opt_mode=<a class="el" href="classbm_1_1bvector.html#a05f1e977cb5e6208838afc7e7b69e5f0a99b64b2444e1a8b22a5e89b02dca6001">opt_compress</a>)</td></tr>
<tr class="memdesc:ac8ebec3020f30fdd4f20cc96b7d211a5"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="classbm_1_1bvector.html#ac8ebec3020f30fdd4f20cc96b7d211a5">More...</a><br /></td></tr>
<tr class="separator:ac8ebec3020f30fdd4f20cc96b7d211a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa2d954f42ea75520b8795066302daab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#aaa2d954f42ea75520b8795066302daab">optimize_gap_size</a> ()</td></tr>
<tr class="memdesc:aaa2d954f42ea75520b8795066302daab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimize sizes of GAP blocks.  <a href="classbm_1_1bvector.html#aaa2d954f42ea75520b8795066302daab">More...</a><br /></td></tr>
<tr class="separator:aaa2d954f42ea75520b8795066302daab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14f9b220fec8e7b65e4e5ed2832af96b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a14f9b220fec8e7b65e4e5ed2832af96b">set_gap_levels</a> (const <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *glevel_len)</td></tr>
<tr class="memdesc:a14f9b220fec8e7b65e4e5ed2832af96b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets new GAP lengths table. All GAP blocks will be reallocated to match the new scheme.  <a href="classbm_1_1bvector.html#a14f9b220fec8e7b65e4e5ed2832af96b">More...</a><br /></td></tr>
<tr class="separator:a14f9b220fec8e7b65e4e5ed2832af96b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3641cc5dd36f35bd38e9a63701037e0d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a3641cc5dd36f35bd38e9a63701037e0d">is_init</a> () const <a class="el" href="bmdef_8h.html#a40d7d3c011d2128b1f0c392127d7d61e">BMNOEXCEPT</a></td></tr>
<tr class="memdesc:a3641cc5dd36f35bd38e9a63701037e0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if bvector is initialized at all.  <a href="classbm_1_1bvector.html#a3641cc5dd36f35bd38e9a63701037e0d">More...</a><br /></td></tr>
<tr class="separator:a3641cc5dd36f35bd38e9a63701037e0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a686fbdd5710a7ebeeb2aff8ea3d8f73c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a686fbdd5710a7ebeeb2aff8ea3d8f73c">fill_alloc_digest</a> (<a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;bv_blocks) const</td></tr>
<tr class="memdesc:a686fbdd5710a7ebeeb2aff8ea3d8f73c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate blocks digest vector (for diagnostics purposes) 1 is added if NB is a real, allocated block.  <a href="classbm_1_1bvector.html#a686fbdd5710a7ebeeb2aff8ea3d8f73c">More...</a><br /></td></tr>
<tr class="separator:a686fbdd5710a7ebeeb2aff8ea3d8f73c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Comparison &lt;br&gt;</div></td></tr>
<tr class="memitem:acfb4e0f923e55057db5ed518853fbecf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#acfb4e0f923e55057db5ed518853fbecf">compare</a> (const <a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;<a class="el" href="sample6_8cpp.html#ac07bb102df543a0c581493c5f35b2129">bvect</a>) const <a class="el" href="bmdef_8h.html#a40d7d3c011d2128b1f0c392127d7d61e">BMNOEXCEPT</a></td></tr>
<tr class="memdesc:acfb4e0f923e55057db5ed518853fbecf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexicographical comparison with a bitvector.  <a href="classbm_1_1bvector.html#acfb4e0f923e55057db5ed518853fbecf">More...</a><br /></td></tr>
<tr class="separator:acfb4e0f923e55057db5ed518853fbecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23a267a48a594836e6a2f1d08a4166f3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a23a267a48a594836e6a2f1d08a4166f3">equal</a> (const <a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;<a class="el" href="sample6_8cpp.html#ac07bb102df543a0c581493c5f35b2129">bvect</a>) const <a class="el" href="bmdef_8h.html#a40d7d3c011d2128b1f0c392127d7d61e">BMNOEXCEPT</a></td></tr>
<tr class="memdesc:a23a267a48a594836e6a2f1d08a4166f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equal comparison with an agr bit-vector.  <a href="classbm_1_1bvector.html#a23a267a48a594836e6a2f1d08a4166f3">More...</a><br /></td></tr>
<tr class="separator:a23a267a48a594836e6a2f1d08a4166f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8554bf7b4d276acc00cd31c87cc544ec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a8554bf7b4d276acc00cd31c87cc544ec">find_first_mismatch</a> (const <a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;<a class="el" href="sample6_8cpp.html#ac07bb102df543a0c581493c5f35b2129">bvect</a>, <a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> &amp;pos, <a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> search_to=<a class="el" href="namespacebm.html#a104b924a1df81542db2a6296fbf26a65">bm::id_max</a>) const <a class="el" href="bmdef_8h.html#a40d7d3c011d2128b1f0c392127d7d61e">BMNOEXCEPT</a></td></tr>
<tr class="memdesc:a8554bf7b4d276acc00cd31c87cc544ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find index of first bit different between this and the agr vector.  <a href="classbm_1_1bvector.html#a8554bf7b4d276acc00cd31c87cc544ec">More...</a><br /></td></tr>
<tr class="separator:a8554bf7b4d276acc00cd31c87cc544ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:aeec1461fca400b5b4313765eb9e94c73"><td class="memItemLeft" align="right" valign="top"><a id="aeec1461fca400b5b4313765eb9e94c73"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>iterator_base</b></td></tr>
<tr class="separator:aeec1461fca400b5b4313765eb9e94c73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71cabca9670588878381f72d16e059b8"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a71cabca9670588878381f72d16e059b8">enumerator</a></td></tr>
<tr class="memdesc:a71cabca9670588878381f72d16e059b8"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="classbm_1_1bvector.html#a71cabca9670588878381f72d16e059b8">More...</a><br /></td></tr>
<tr class="separator:a71cabca9670588878381f72d16e059b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b713f8799df176e5ab5da91d782bf3"><td class="memTemplParams" colspan="2"><a id="a27b713f8799df176e5ab5da91d782bf3"></a>
template&lt;class BV &gt; </td></tr>
<tr class="memitem:a27b713f8799df176e5ab5da91d782bf3"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>aggregator</b></td></tr>
<tr class="separator:a27b713f8799df176e5ab5da91d782bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c9c233ddf57904ea68788295b997e9b"><td class="memTemplParams" colspan="2"><a id="a6c9c233ddf57904ea68788295b997e9b"></a>
template&lt;class BV &gt; </td></tr>
<tr class="memitem:a6c9c233ddf57904ea68788295b997e9b"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operation_deserializer</b></td></tr>
<tr class="separator:a6c9c233ddf57904ea68788295b997e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11896fa79b61c0fdf3fab7924333f402"><td class="memTemplParams" colspan="2"><a id="a11896fa79b61c0fdf3fab7924333f402"></a>
template&lt;class BV , class DEC &gt; </td></tr>
<tr class="memitem:a11896fa79b61c0fdf3fab7924333f402"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>deserializer</b></td></tr>
<tr class="separator:a11896fa79b61c0fdf3fab7924333f402"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Open internals &lt;br&gt;</h2></td></tr>
<tr class="memitem:ae07a3598a5f3a5dace950cc48c5e1369"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#ae07a3598a5f3a5dace950cc48c5e1369">combine_operation_with_block</a> (<a class="el" href="classbm_1_1bvector.html#ac11e61368363493754cbe97b69a1ca71">block_idx_type</a> nb, const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *arg_blk, bool arg_gap, <a class="el" href="group__bvector.html#ga42405343976ec931388381cea4092bf1">bm::operation</a> opcode)</td></tr>
<tr class="memdesc:ae07a3598a5f3a5dace950cc48c5e1369"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="classbm_1_1bvector.html#ae07a3598a5f3a5dace950cc48c5e1369">More...</a><br /></td></tr>
<tr class="separator:ae07a3598a5f3a5dace950cc48c5e1369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a08b48003a0f25be9c148b942b1d85b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classbm_1_1bvector.html#a6fdfeafe05217c31cdc9140b7642b611">blocks_manager_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a4a08b48003a0f25be9c148b942b1d85b">get_blocks_manager</a> () const <a class="el" href="bmdef_8h.html#a40d7d3c011d2128b1f0c392127d7d61e">BMNOEXCEPT</a></td></tr>
<tr class="memdesc:a4a08b48003a0f25be9c148b942b1d85b"><td class="mdescLeft">&#160;</td><td class="mdescRight">get access to memory manager (internal) Use only if you are BitMagic library  <a href="classbm_1_1bvector.html#a4a08b48003a0f25be9c148b942b1d85b">More...</a><br /></td></tr>
<tr class="separator:a4a08b48003a0f25be9c148b942b1d85b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe9de075b14a63c8940ba462e3eca98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbm_1_1bvector.html#a6fdfeafe05217c31cdc9140b7642b611">blocks_manager_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a0fe9de075b14a63c8940ba462e3eca98">get_blocks_manager</a> () <a class="el" href="bmdef_8h.html#a40d7d3c011d2128b1f0c392127d7d61e">BMNOEXCEPT</a></td></tr>
<tr class="memdesc:a0fe9de075b14a63c8940ba462e3eca98"><td class="mdescLeft">&#160;</td><td class="mdescRight">get access to memory manager (internal) Use only if you are BitMagic library  <a href="classbm_1_1bvector.html#a0fe9de075b14a63c8940ba462e3eca98">More...</a><br /></td></tr>
<tr class="separator:a0fe9de075b14a63c8940ba462e3eca98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc874cffc4cd09986dcb6b6f597bf05b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#abc874cffc4cd09986dcb6b6f597bf05b">import</a> (const <a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> *ids, <a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> ids_size, <a class="el" href="group__bvector.html#ga04a7a7cda4bf04cd107e198b3b1e4ed8">bm::sort_order</a> sorted_idx)</td></tr>
<tr class="memdesc:abc874cffc4cd09986dcb6b6f597bf05b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import integers (set bits).  <a href="classbm_1_1bvector.html#abc874cffc4cd09986dcb6b6f597bf05b">More...</a><br /></td></tr>
<tr class="separator:abc874cffc4cd09986dcb6b6f597bf05b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a354bc2c3c91235c9034a92b0fa410765"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a354bc2c3c91235c9034a92b0fa410765">import_sorted</a> (const <a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> *ids, const <a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> ids_size)</td></tr>
<tr class="memdesc:a354bc2c3c91235c9034a92b0fa410765"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import sorted integers (set bits).  <a href="classbm_1_1bvector.html#a354bc2c3c91235c9034a92b0fa410765">More...</a><br /></td></tr>
<tr class="separator:a354bc2c3c91235c9034a92b0fa410765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b7223ef1dc03d8b02b6feefea8e01b"><td class="memItemLeft" align="right" valign="top"><a id="a38b7223ef1dc03d8b02b6feefea8e01b"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>throw_bad_alloc</b> ()</td></tr>
<tr class="separator:a38b7223ef1dc03d8b02b6feefea8e01b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c6c213804cd440ce15ede3d374f0c69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a4c6c213804cd440ce15ede3d374f0c69">sync_size</a> ()</td></tr>
<tr class="memdesc:a4c6c213804cd440ce15ede3d374f0c69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Syncronize size if it got extended due to bulk import.  <a href="classbm_1_1bvector.html#a4c6c213804cd440ce15ede3d374f0c69">More...</a><br /></td></tr>
<tr class="separator:a4c6c213804cd440ce15ede3d374f0c69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04226053e3a2dfc46af6816f0bebf331"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a04226053e3a2dfc46af6816f0bebf331">import_block</a> (const <a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> *ids, <a class="el" href="classbm_1_1bvector.html#ac11e61368363493754cbe97b69a1ca71">block_idx_type</a> nblock, <a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> start, <a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> stop)</td></tr>
<tr class="memdesc:a04226053e3a2dfc46af6816f0bebf331"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="classbm_1_1bvector.html#a04226053e3a2dfc46af6816f0bebf331">More...</a><br /></td></tr>
<tr class="separator:a04226053e3a2dfc46af6816f0bebf331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56ede517bb0b4e125e3485fb518b3dc6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a56ede517bb0b4e125e3485fb518b3dc6">check_or_next</a> (<a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> prev) const <a class="el" href="bmdef_8h.html#a40d7d3c011d2128b1f0c392127d7d61e">BMNOEXCEPT</a></td></tr>
<tr class="memdesc:a56ede517bb0b4e125e3485fb518b3dc6"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="classbm_1_1bvector.html#a56ede517bb0b4e125e3485fb518b3dc6">More...</a><br /></td></tr>
<tr class="separator:a56ede517bb0b4e125e3485fb518b3dc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2916625363afc9b7ba1d266b2228b9b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#af2916625363afc9b7ba1d266b2228b9b">gap_block_set</a> (<a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">bm::gap_word_t</a> *gap_blk, bool val, <a class="el" href="classbm_1_1bvector.html#ac11e61368363493754cbe97b69a1ca71">block_idx_type</a> nblock, unsigned nbit)</td></tr>
<tr class="memdesc:af2916625363afc9b7ba1d266b2228b9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">set bit in GAP block with GAP block length control  <a href="classbm_1_1bvector.html#af2916625363afc9b7ba1d266b2228b9b">More...</a><br /></td></tr>
<tr class="separator:af2916625363afc9b7ba1d266b2228b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae520c44dddc3f037bfb5ca51d3032dcd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#ae520c44dddc3f037bfb5ca51d3032dcd">gap_block_set_no_ret</a> (<a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">bm::gap_word_t</a> *gap_blk, bool val, <a class="el" href="classbm_1_1bvector.html#ac11e61368363493754cbe97b69a1ca71">block_idx_type</a> nblock, unsigned nbit)</td></tr>
<tr class="memdesc:ae520c44dddc3f037bfb5ca51d3032dcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">set bit in GAP block with GAP block length control  <a href="classbm_1_1bvector.html#ae520c44dddc3f037bfb5ca51d3032dcd">More...</a><br /></td></tr>
<tr class="separator:ae520c44dddc3f037bfb5ca51d3032dcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a518b24a7762be7cfd1aab04de68234f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a518b24a7762be7cfd1aab04de68234f3">check_or_next_extract</a> (<a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> prev)</td></tr>
<tr class="memdesc:a518b24a7762be7cfd1aab04de68234f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if specified bit is 1, and set it to 0 if specified bit is 0, scan for the next 1 and returns it if no 1 found returns 0  <a href="classbm_1_1bvector.html#a518b24a7762be7cfd1aab04de68234f3">More...</a><br /></td></tr>
<tr class="separator:a518b24a7762be7cfd1aab04de68234f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fb610501b6597e05af112b0ee912674"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a7fb610501b6597e05af112b0ee912674">and_bit_no_check</a> (<a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> n, bool val)</td></tr>
<tr class="memdesc:a7fb610501b6597e05af112b0ee912674"><td class="mdescLeft">&#160;</td><td class="mdescRight">AND specified bit without checking preconditions (size, etc)  <a href="classbm_1_1bvector.html#a7fb610501b6597e05af112b0ee912674">More...</a><br /></td></tr>
<tr class="separator:a7fb610501b6597e05af112b0ee912674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e3997ef4b9c81aab8fccab4c79e00f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a34e3997ef4b9c81aab8fccab4c79e00f">set_bit_conditional_impl</a> (<a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> n, bool val, bool condition)</td></tr>
<tr class="memdesc:a34e3997ef4b9c81aab8fccab4c79e00f"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="classbm_1_1bvector.html#a34e3997ef4b9c81aab8fccab4c79e00f">More...</a><br /></td></tr>
<tr class="separator:a34e3997ef4b9c81aab8fccab4c79e00f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c91224fa77538f5bf407547ef030c53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a1c91224fa77538f5bf407547ef030c53">combine_operation_with_block</a> (<a class="el" href="classbm_1_1bvector.html#ac11e61368363493754cbe97b69a1ca71">block_idx_type</a> nb, bool gap, <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *blk, const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *arg_blk, bool arg_gap, <a class="el" href="group__bvector.html#ga42405343976ec931388381cea4092bf1">bm::operation</a> opcode)</td></tr>
<tr class="memdesc:a1c91224fa77538f5bf407547ef030c53"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="classbm_1_1bvector.html#a1c91224fa77538f5bf407547ef030c53">More...</a><br /></td></tr>
<tr class="separator:a1c91224fa77538f5bf407547ef030c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d483b58f9404eb755ded14de9e4df26"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a3d483b58f9404eb755ded14de9e4df26">combine_operation_block_or</a> (unsigned i, unsigned j, const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *arg_blk1, const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *arg_blk2)</td></tr>
<tr class="memdesc:a3d483b58f9404eb755ded14de9e4df26"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="classbm_1_1bvector.html#a3d483b58f9404eb755ded14de9e4df26">More...</a><br /></td></tr>
<tr class="separator:a3d483b58f9404eb755ded14de9e4df26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9024201b96bf25e4b9b6f9693bc4afdb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a9024201b96bf25e4b9b6f9693bc4afdb">combine_operation_block_xor</a> (unsigned i, unsigned j, const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *arg_blk1, const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *arg_blk2)</td></tr>
<tr class="memdesc:a9024201b96bf25e4b9b6f9693bc4afdb"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="classbm_1_1bvector.html#a9024201b96bf25e4b9b6f9693bc4afdb">More...</a><br /></td></tr>
<tr class="separator:a9024201b96bf25e4b9b6f9693bc4afdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84464d2f51d17af7a1769ce5b21f4352"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a84464d2f51d17af7a1769ce5b21f4352">combine_operation_block_and</a> (unsigned i, unsigned j, const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *arg_blk1, const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *arg_blk2)</td></tr>
<tr class="memdesc:a84464d2f51d17af7a1769ce5b21f4352"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="classbm_1_1bvector.html#a84464d2f51d17af7a1769ce5b21f4352">More...</a><br /></td></tr>
<tr class="separator:a84464d2f51d17af7a1769ce5b21f4352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a128e0a08161072a5513a26fb6dbc8432"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a128e0a08161072a5513a26fb6dbc8432">combine_operation_block_and_or</a> (unsigned i, unsigned j, const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *arg_blk1, const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *arg_blk2)</td></tr>
<tr class="memdesc:a128e0a08161072a5513a26fb6dbc8432"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="classbm_1_1bvector.html#a128e0a08161072a5513a26fb6dbc8432">More...</a><br /></td></tr>
<tr class="separator:a128e0a08161072a5513a26fb6dbc8432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89e9407fa3296087a05298607a060b68"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a89e9407fa3296087a05298607a060b68">combine_operation_block_sub</a> (unsigned i, unsigned j, const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *arg_blk1, const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *arg_blk2)</td></tr>
<tr class="memdesc:a89e9407fa3296087a05298607a060b68"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="classbm_1_1bvector.html#a89e9407fa3296087a05298607a060b68">More...</a><br /></td></tr>
<tr class="separator:a89e9407fa3296087a05298607a060b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d00112c746de55ead821ceba7ff65a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a28d00112c746de55ead821ceba7ff65a">combine_operation_block_or</a> (unsigned i, unsigned j, <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *blk, const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *arg_blk)</td></tr>
<tr class="memdesc:a28d00112c746de55ead821ceba7ff65a"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="classbm_1_1bvector.html#a28d00112c746de55ead821ceba7ff65a">More...</a><br /></td></tr>
<tr class="separator:a28d00112c746de55ead821ceba7ff65a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa74f75c8922a261ba5f2992d4c91f392"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#aa74f75c8922a261ba5f2992d4c91f392">combine_operation_block_xor</a> (unsigned i, unsigned j, <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *blk, const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *arg_blk)</td></tr>
<tr class="memdesc:aa74f75c8922a261ba5f2992d4c91f392"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="classbm_1_1bvector.html#aa74f75c8922a261ba5f2992d4c91f392">More...</a><br /></td></tr>
<tr class="separator:aa74f75c8922a261ba5f2992d4c91f392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2dcf7f8fa7a660d8bde25757e8d259c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#ac2dcf7f8fa7a660d8bde25757e8d259c">combine_operation_block_and</a> (unsigned i, unsigned j, <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *blk, const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *arg_blk)</td></tr>
<tr class="memdesc:ac2dcf7f8fa7a660d8bde25757e8d259c"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="classbm_1_1bvector.html#ac2dcf7f8fa7a660d8bde25757e8d259c">More...</a><br /></td></tr>
<tr class="separator:ac2dcf7f8fa7a660d8bde25757e8d259c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a765a98d68667863ed6cc4d3e58cd5011"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#a765a98d68667863ed6cc4d3e58cd5011">combine_operation_block_sub</a> (unsigned i, unsigned j, <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *blk, const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *arg_blk)</td></tr>
<tr class="memdesc:a765a98d68667863ed6cc4d3e58cd5011"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="classbm_1_1bvector.html#a765a98d68667863ed6cc4d3e58cd5011">More...</a><br /></td></tr>
<tr class="separator:a765a98d68667863ed6cc4d3e58cd5011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf4b2b4af70396189467408e564791ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbm_1_1bvector.html#abf4b2b4af70396189467408e564791ee">copy_range_no_check</a> (const <a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;<a class="el" href="sample6_8cpp.html#ac07bb102df543a0c581493c5f35b2129">bvect</a>, <a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> left, <a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> right)</td></tr>
<tr class="memdesc:abf4b2b4af70396189467408e564791ee"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="classbm_1_1bvector.html#abf4b2b4af70396189467408e564791ee">More...</a><br /></td></tr>
<tr class="separator:abf4b2b4af70396189467408e564791ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class Alloc&gt;<br />
class bm::bvector&lt; Alloc &gt;</div><p >Bitvector Bit-vector container with runtime compression of bits. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="bv3vlogic_8cpp-example.html#_a1">bv3vlogic.cpp</a>, <a class="el" href="bvsample01_64_8cpp-example.html#_a1">bvsample01_64.cpp</a>, <a class="el" href="bvsetalgebra_8cpp-example.html#_a1">bvsetalgebra.cpp</a>, <a class="el" href="inv_list_8cpp-example.html#_a26">inv_list.cpp</a>, <a class="el" href="rscsample04_8cpp-example.html#_a6">rscsample04.cpp</a>, <a class="el" href="rscsample05_8cpp-example.html#_a0">rscsample05.cpp</a>, <a class="el" href="rscsample06_8cpp-example.html#_a6">rscsample06.cpp</a>, <a class="el" href="sample1_8cpp-example.html#_a1">sample1.cpp</a>, <a class="el" href="sample10_8cpp-example.html#_a2">sample10.cpp</a>, <a class="el" href="sample11_8cpp-example.html#_a7">sample11.cpp</a>, <a class="el" href="sample12_8cpp-example.html#_a8">sample12.cpp</a>, <a class="el" href="sample14_8cpp-example.html#_a2">sample14.cpp</a>, <a class="el" href="sample15_8cpp-example.html#_a2">sample15.cpp</a>, <a class="el" href="sample16_8cpp-example.html#_a4">sample16.cpp</a>, <a class="el" href="sample17_8cpp-example.html#_a1">sample17.cpp</a>, <a class="el" href="sample18_8cpp-example.html#_a1">sample18.cpp</a>, <a class="el" href="sample18a_8cpp-example.html#_a1">sample18a.cpp</a>, <a class="el" href="sample19_8cpp-example.html#_a1">sample19.cpp</a>, <a class="el" href="sample2_8cpp-example.html#_a1">sample2.cpp</a>, <a class="el" href="sample20_8cpp-example.html#_a2">sample20.cpp</a>, <a class="el" href="sample21_8cpp-example.html#_a2">sample21.cpp</a>, <a class="el" href="sample22_8cpp-example.html#_a2">sample22.cpp</a>, <a class="el" href="sample23_8cpp-example.html#_a3">sample23.cpp</a>, <a class="el" href="sample24_8cpp-example.html#_a3">sample24.cpp</a>, <a class="el" href="sample25_8cpp-example.html#_a7">sample25.cpp</a>, <a class="el" href="sample26_8cpp-example.html#_a2">sample26.cpp</a>, <a class="el" href="sample3_8cpp-example.html#_a2">sample3.cpp</a>, <a class="el" href="sample4_8cpp-example.html#_a2">sample4.cpp</a>, <a class="el" href="sample5_8cpp-example.html#_a2">sample5.cpp</a>, <a class="el" href="sample6_8cpp-example.html#_a16">sample6.cpp</a>, <a class="el" href="sample7_8cpp-example.html#_a3">sample7.cpp</a>, <a class="el" href="sample8_8cpp-example.html#_a4">sample8.cpp</a>, <a class="el" href="sample9_8cpp-example.html#_a1">sample9.cpp</a>, <a class="el" href="strsvsample01_8cpp-example.html#_a0">strsvsample01.cpp</a>, <a class="el" href="strsvsample02_8cpp-example.html#_a0">strsvsample02.cpp</a>, <a class="el" href="strsvsample02a_8cpp-example.html#_a0">strsvsample02a.cpp</a>, <a class="el" href="strsvsample03_8cpp-example.html#_a0">strsvsample03.cpp</a>, <a class="el" href="strsvsample04_8cpp-example.html#_a0">strsvsample04.cpp</a>, <a class="el" href="strsvsample05_8cpp-example.html#_a0">strsvsample05.cpp</a>, <a class="el" href="strsvsample06_8cpp-example.html#_a0">strsvsample06.cpp</a>, <a class="el" href="strsvsample07_8cpp-example.html#_a0">strsvsample07.cpp</a>, <a class="el" href="svsample04_8cpp-example.html#_a2">svsample04.cpp</a>, <a class="el" href="svsample05_8cpp-example.html#_a8">svsample05.cpp</a>, <a class="el" href="svsample06_8cpp-example.html#_a9">svsample06.cpp</a>, <a class="el" href="svsample07a_8cpp-example.html#_a0">svsample07a.cpp</a>, <a class="el" href="svsample08_8cpp-example.html#_a13">svsample08.cpp</a>, <a class="el" href="svsample10_8cpp-example.html#_a9">svsample10.cpp</a>, <a class="el" href="xsample01_8cpp-example.html#_a6">xsample01.cpp</a>, <a class="el" href="xsample02_8cpp-example.html#_a21">xsample02.cpp</a>, <a class="el" href="xsample03_8cpp-example.html#_a19">xsample03.cpp</a>, <a class="el" href="xsample04_8cpp-example.html#_a26">xsample04.cpp</a>, <a class="el" href="xsample04a_8cpp-example.html#_a23">xsample04a.cpp</a>, <a class="el" href="xsample05_8cpp-example.html#_a24">xsample05.cpp</a>, <a class="el" href="xsample07_8cpp-example.html#_a40">xsample07.cpp</a>, <a class="el" href="xsample07a_8cpp-example.html#_a12">xsample07a.cpp</a>, <a class="el" href="xsample08_8cpp-example.html#_a11">xsample08.cpp</a>, and <a class="el" href="xsample09_8cpp-example.html#_a2">xsample09.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l00114">114</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a05f1e977cb5e6208838afc7e7b69e5f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05f1e977cb5e6208838afc7e7b69e5f0">&#9670;&nbsp;</a></span>optmode</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classbm_1_1bvector.html#a05f1e977cb5e6208838afc7e7b69e5f0">bm::bvector::optmode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optimization mode Every next level means additional checks (better compression vs time) </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbm_1_1bvector.html#a622e6827d799a561e2f0db28f7ac19d2" title="Optimize memory bitvector&#39;s memory allocation.">optimize</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a05f1e977cb5e6208838afc7e7b69e5f0afc03833a1770728dde103c7364b12660"></a>opt_none&#160;</td><td class="fielddoc"><p >no optimization </p>
</td></tr>
<tr><td class="fieldname"><a id="a05f1e977cb5e6208838afc7e7b69e5f0af7f71b9fa4aac73572f492b60df4dbbe"></a>opt_free_0&#160;</td><td class="fielddoc"><p >Free unused 0 blocks. </p>
</td></tr>
<tr><td class="fieldname"><a id="a05f1e977cb5e6208838afc7e7b69e5f0ad4c02e1ba1f9522be654e0e129ced2fc"></a>opt_free_01&#160;</td><td class="fielddoc"><p >Free unused 0 and 1 blocks. </p>
</td></tr>
<tr><td class="fieldname"><a id="a05f1e977cb5e6208838afc7e7b69e5f0a99b64b2444e1a8b22a5e89b02dca6001"></a>opt_compress&#160;</td><td class="fielddoc"><p >compress blocks when possible (GAP/prefix sum) </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l00132">132</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a159e3c2cb32e6d098eddd9d1eac21c88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a159e3c2cb32e6d098eddd9d1eac21c88">&#9670;&nbsp;</a></span>bvector() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::<a class="el" href="classbm_1_1bvector.html">bvector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bvector.html#gad0b87b3b7292383a864d27feaf1c9eff">strategy</a>&#160;</td>
          <td class="paramname"><em>strat</em> = <code><a class="el" href="group__bvector.html#ggad0b87b3b7292383a864d27feaf1c9effa40920ae0ef7b4411d60463d8f576b5ba">BM_BIT</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *&#160;</td>
          <td class="paramname"><em>glevel_len</em> = <code><a class="el" href="structbm_1_1gap__len__table.html">bm::gap_len_table</a>&lt;true&gt;::_len</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td>
          <td class="paramname"><em>bv_size</em> = <code><a class="el" href="namespacebm.html#a104b924a1df81542db2a6296fbf26a65">bm::id_max</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Alloc &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Alloc()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs bvector class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strat</td><td>- operation mode strategy, BM_BIT - default strategy, bvector use plain bitset blocks, (performance oriented strategy). BM_GAP - memory effitent strategy, bvector allocates blocks as array of intervals(gaps) and convert blocks into plain bitsets only when enthropy grows. </td></tr>
    <tr><td class="paramname">glevel_len</td><td><ul>
<li>pointer on C-style array keeping GAP block sizes. <a class="el" href="structbm_1_1gap__len__table.html#af9260645490e8cac0769ba84847d4512">bm::gap_len_table&lt;true&gt;::_len</a> - default value set (use <a class="el" href="structbm_1_1gap__len__table__min.html#a7049262dea6250b11522da8e8359eefc">bm::gap_len_table_min&lt;true&gt;::_len</a> for very sparse vectors) (use <a class="el" href="structbm_1_1gap__len__table__nl.html#acdb994f54c823e7b2803e19fc06b7098">bm::gap_len_table_nl&lt;true&gt;::_len</a> non-linear GAP growth) </li>
</ul>
</td></tr>
    <tr><td class="paramname">bv_size</td><td><ul>
<li>bvector size (number of bits addressable by bvector), <a class="el" href="namespacebm.html#a104b924a1df81542db2a6296fbf26a65">bm::id_max</a> means "no limits" (recommended). bit vector allocates this space dynamically on demand. </li>
</ul>
</td></tr>
    <tr><td class="paramname">alloc</td><td>- alllocator for this instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structbm_1_1gap__len__table.html" title="Default GAP lengths table.">bm::gap_len_table</a> <a class="el" href="structbm_1_1gap__len__table__min.html" title="Alternative GAP lengths table. Good for for memory saver mode and very sparse bitsets.">bm::gap_len_table_min</a> <a class="el" href="classbm_1_1bvector.html#a653ee052b297a49c35344704df67a452" title="Sets new blocks allocation strategy.">set_new_blocks_strat</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l00877">877</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="ae54e579bdddadece60dcfa519d18a1c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae54e579bdddadece60dcfa519d18a1c5">&#9670;&nbsp;</a></span>bvector() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::<a class="el" href="classbm_1_1bvector.html">bvector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td>
          <td class="paramname"><em>bv_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bvector.html#gad0b87b3b7292383a864d27feaf1c9eff">strategy</a>&#160;</td>
          <td class="paramname"><em>strat</em> = <code><a class="el" href="group__bvector.html#ggad0b87b3b7292383a864d27feaf1c9effa40920ae0ef7b4411d60463d8f576b5ba">BM_BIT</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *&#160;</td>
          <td class="paramname"><em>glevel_len</em> = <code><a class="el" href="structbm_1_1gap__len__table.html">bm::gap_len_table</a>&lt;true&gt;::_len</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Alloc &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Alloc()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs bvector class. </p>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l00889">889</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="a608b979d18211645c625e1bcd41cf307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a608b979d18211645c625e1bcd41cf307">&#9670;&nbsp;</a></span>bvector() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::<a class="el" href="classbm_1_1bvector.html">bvector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bvect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l00901">901</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="acb493ca86ebd58f02a1a5a73c393b199"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb493ca86ebd58f02a1a5a73c393b199">&#9670;&nbsp;</a></span>bvector() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::<a class="el" href="classbm_1_1bvector.html">bvector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bvect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor for range copy [left..right]. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbm_1_1bvector.html#ab7978570375ae288a6893d7b4d673769" title="Copy all bits in the specified closed interval [left,right].">copy_range</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l00911">911</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bm_8h_source.html#l07809">bm::bvector&lt; Alloc &gt;::copy_range_no_check()</a>, and <a class="el" href="bmutil_8h_source.html#l00536">bm::xor_swap()</a>.</p>

</div>
</div>
<a id="a0a96c45c37c5c046178883060d363c83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a96c45c37c5c046178883060d363c83">&#9670;&nbsp;</a></span>bvector() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::<a class="el" href="classbm_1_1bvector.html">bvector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bvect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bvector.html#gacfee7c9af0d11e534813a7429ffb1a31">bm::finalization</a>&#160;</td>
          <td class="paramname"><em>is_final</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy-constructor for mutable/immutable initialization. </p>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l00926">926</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmconst_8h_source.html#l00157">bm::BM_READONLY</a>.</p>

</div>
</div>
<a id="a1bd58c5e2c84307768b0e62f1d59f438"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bd58c5e2c84307768b0e62f1d59f438">&#9670;&nbsp;</a></span>bvector() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::<a class="el" href="classbm_1_1bvector.html">bvector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>bvect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l00960">960</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="a65dd5a92d3360c796e841ed783724406"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65dd5a92d3360c796e841ed783724406">&#9670;&nbsp;</a></span>bvector() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::<a class="el" href="classbm_1_1bvector.html">bvector</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> &gt;&#160;</td>
          <td class="paramname"><em>il</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Brace constructor. </p>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l00970">970</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bm_8h_source.html#l02291">bm::bvector&lt; Alloc &gt;::init()</a>, and <a class="el" href="bm_8h_source.html#l04426">bm::bvector&lt; Alloc &gt;::set_bit_no_check()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7fb610501b6597e05af112b0ee912674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fb610501b6597e05af112b0ee912674">&#9670;&nbsp;</a></span>and_bit_no_check()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::and_bit_no_check </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>AND specified bit without checking preconditions (size, etc) </p>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l04619">4619</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>, <a class="el" href="bmdef_8h_source.html#l00189">BMGAP_PTR</a>, <a class="el" href="bm_8h_source.html#l04494">bm::bvector&lt; Alloc &gt;::gap_block_set()</a>, <a class="el" href="bmfunc_8h_source.html#l01775">bm::gap_test_unr()</a>, <a class="el" href="bm_8h_source.html#l01932">bm::bvector&lt; Alloc &gt;::get_new_blocks_strat()</a>, <a class="el" href="bm_8h_source.html#l01080">bm::bvector&lt; Alloc &gt;::is_ro()</a>, <a class="el" href="bmdef_8h_source.html#l00161">IS_VALID_ADDR</a>, <a class="el" href="bmconst_8h_source.html#l00057">bm::set_block_mask</a>, <a class="el" href="bmconst_8h_source.html#l00056">bm::set_block_shift</a>, <a class="el" href="bmconst_8h_source.html#l00073">bm::set_word_mask</a>, and <a class="el" href="bmconst_8h_source.html#l00072">bm::set_word_shift</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l04203">bm::bvector&lt; Alloc &gt;::set_bit_and()</a>.</p>

</div>
</div>
<a id="a69729bae3fca407ff1228cf2db761adb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69729bae3fca407ff1228cf2db761adb">&#9670;&nbsp;</a></span>any()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::any</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if any bits in this bitset are set, and otherwise returns false. </p>
<dl class="section return"><dt>Returns</dt><dd>true if any bit is set </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="strsvsample06_8cpp-example.html#a16">strsvsample06.cpp</a>, <a class="el" href="xsample04_8cpp-example.html#a29">xsample04.cpp</a>, and <a class="el" href="xsample07a_8cpp-example.html#a116">xsample07a.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l02449">2449</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmfunc_8h_source.html#l02090">bm::for_each_nzblock_if()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l01574">bm::bvector&lt; Alloc &gt;::empty()</a>, <a class="el" href="xsample04_8cpp_source.html#l00250">DNA_FingerprintScanner::Find()</a>, <a class="el" href="strsvsample06_8cpp_source.html#l00047">main()</a>, <a class="el" href="bm_8h_source.html#l01568">bm::bvector&lt; Alloc &gt;::none()</a>, and <a class="el" href="xsample07a_8cpp_source.html#l01155">resolve_duplicates()</a>.</p>

</div>
</div>
<a id="a530f12c9a00799ecbe9abd276a7ae619"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a530f12c9a00799ecbe9abd276a7ae619">&#9670;&nbsp;</a></span>any_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::any_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if any bits in the range are 1s (non-empty interval) Function uses closed interval [left, right]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>- index of first bit start checking </td></tr>
    <tr><td class="paramname">right</td><td>- index of last bit</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if at least 1 bits is set </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbm_1_1bvector.html#a7d36a1f08ff5c39c55b6bbdfe6251001" title="Returns true if all bits in the range are 1s (saturated interval) Function uses closed interval [left...">is_all_one_range</a>, <a class="el" href="classbm_1_1bvector.html#a99395aaa8ab689455054bda9b261de60" title="Returns count of 1 bits in the given range [left..right] Uses rank-select index to accelerate the sea...">count_range</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="xsample08_8cpp-example.html#a22">xsample08.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l03413">3413</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmfunc_8h_source.html#l06439">bm::block_any()</a>, <a class="el" href="bmfunc_8h_source.html#l06418">bm::block_any_range()</a>, <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>, <a class="el" href="bmdef_8h_source.html#l00158">FULL_BLOCK_FAKE_ADDR</a>, <a class="el" href="bmconst_8h_source.html#l00081">bm::gap_max_bits</a>, <a class="el" href="bmfunc_8h_source.html#l00163">bm::get_block_coord()</a>, <a class="el" href="bmconst_8h_source.html#l00109">bm::id_max</a>, <a class="el" href="bmconst_8h_source.html#l00057">bm::set_block_mask</a>, <a class="el" href="bmconst_8h_source.html#l00056">bm::set_block_shift</a>, <a class="el" href="bmconst_8h_source.html#l00095">bm::set_sub_array_size</a>, <a class="el" href="bm_8h_source.html#l01514">bm::bvector&lt; Alloc &gt;::test()</a>, and <a class="el" href="bmutil_8h_source.html#l00536">bm::xor_swap()</a>.</p>

<p class="reference">Referenced by <a class="el" href="xsample08_8cpp_source.html#l00169">add_object()</a>, and <a class="el" href="sample22_8cpp_source.html#l00072">main()</a>.</p>

</div>
</div>
<a id="a99946dcf231dfed93022197cfb2c327d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99946dcf231dfed93022197cfb2c327d">&#9670;&nbsp;</a></span>bit_and() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt;Alloc&gt;&amp; <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::bit_and </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a05f1e977cb5e6208838afc7e7b69e5f0">optmode</a>&#160;</td>
          <td class="paramname"><em>opt_mode</em> = <code><a class="el" href="classbm_1_1bvector.html#a05f1e977cb5e6208838afc7e7b69e5f0afc03833a1770728dde103c7364b12660">opt_none</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>2 operand logical AND </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bv</td><td>- argument vector </td></tr>
    <tr><td class="paramname">opt_mode</td><td>- set an immediate optimization </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01814">1814</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>, <a class="el" href="bm_8h_source.html#l06381">bm::bvector&lt; Alloc &gt;::combine_operation_and()</a>, and <a class="el" href="bm_8h_source.html#l01080">bm::bvector&lt; Alloc &gt;::is_ro()</a>.</p>

</div>
</div>
<a id="a37c1ccb4755c61450311918ad3330aa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37c1ccb4755c61450311918ad3330aa6">&#9670;&nbsp;</a></span>bit_and() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp; <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::bit_and </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bv1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bv2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::<a class="el" href="classbm_1_1bvector.html#a05f1e977cb5e6208838afc7e7b69e5f0">optmode</a>&#160;</td>
          <td class="paramname"><em>opt_mode</em> = <code><a class="el" href="classbm_1_1bvector.html#a05f1e977cb5e6208838afc7e7b69e5f0afc03833a1770728dde103c7364b12660">opt_none</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>3-operand AND : this := bv1 AND bv2 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bv1</td><td>- Argument vector 1 </td></tr>
    <tr><td class="paramname">bv2</td><td>- Argument vector 2 </td></tr>
    <tr><td class="paramname">opt_mode</td><td>- optimization compression (when it is performed on the fly it is faster than a separate call to <a class="el" href="classbm_1_1bvector.html#a622e6827d799a561e2f0db28f7ac19d2" title="Optimize memory bitvector&#39;s memory allocation.">optimize()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbm_1_1bvector.html#a622e6827d799a561e2f0db28f7ac19d2" title="Optimize memory bitvector&#39;s memory allocation.">optimize</a>, <a class="el" href="classbm_1_1bvector.html#a37c1ccb4755c61450311918ad3330aa6" title="3-operand AND : this := bv1 AND bv2">bit_and</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="bvsetalgebra_8cpp-example.html#a29">bvsetalgebra.cpp</a>, <a class="el" href="strsvsample07_8cpp-example.html#a21">strsvsample07.cpp</a>, <a class="el" href="svsample10_8cpp-example.html#a16">svsample10.cpp</a>, and <a class="el" href="xsample07a_8cpp-example.html#a115">xsample07a.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l05901">5901</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bm_8h_source.html#l05901">bm::bvector&lt; Alloc &gt;::bit_and()</a>, <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>, <a class="el" href="bm_8h_source.html#l06810">bm::bvector&lt; Alloc &gt;::combine_operation_block_and()</a>, <a class="el" href="bmdef_8h_source.html#l00158">FULL_BLOCK_FAKE_ADDR</a>, <a class="el" href="bmdef_8h_source.html#l00159">FULL_SUB_BLOCK_REAL_ADDR</a>, <a class="el" href="bm_8h_source.html#l02070">bm::bvector&lt; Alloc &gt;::get_blocks_manager()</a>, <a class="el" href="bm_8h_source.html#l01080">bm::bvector&lt; Alloc &gt;::is_ro()</a>, <a class="el" href="bm_8h_source.html#l00137">bm::bvector&lt; Alloc &gt;::opt_compress</a>, <a class="el" href="bm_8h_source.html#l00134">bm::bvector&lt; Alloc &gt;::opt_none</a>, and <a class="el" href="bmconst_8h_source.html#l00095">bm::set_sub_array_size</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l05901">bm::bvector&lt; Alloc &gt;::bit_and()</a>, <a class="el" href="bm_8h_source.html#l05996">bm::bvector&lt; Alloc &gt;::bit_or_and()</a>, <a class="el" href="bvsetalgebra_8cpp_source.html#l00221">DemoAND()</a>, <a class="el" href="bm_8h_source.html#l04095">bm::bvector&lt; Alloc &gt;::keep()</a>, <a class="el" href="strsvsample07_8cpp_source.html#l00111">main()</a>, <a class="el" href="bm_8h_source.html#l02246">bm::operator&amp;()</a>, <a class="el" href="bm_8h_source.html#l01040">bm::bvector&lt; Alloc &gt;::operator&amp;=()</a>, and <a class="el" href="xsample07a_8cpp_source.html#l01155">resolve_duplicates()</a>.</p>

</div>
</div>
<a id="aee4b63ca79de51765a89a2d37cd6f5bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee4b63ca79de51765a89a2d37cd6f5bf">&#9670;&nbsp;</a></span>bit_or() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt;Alloc&gt;&amp; <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::bit_or </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>2 operand logical OR </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bv</td><td>- Argument vector. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01802">1802</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>, <a class="el" href="bm_8h_source.html#l06210">bm::bvector&lt; Alloc &gt;::combine_operation_or()</a>, and <a class="el" href="bm_8h_source.html#l01080">bm::bvector&lt; Alloc &gt;::is_ro()</a>.</p>

</div>
</div>
<a id="a001b183876bd7ab940f711bb48263d47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a001b183876bd7ab940f711bb48263d47">&#9670;&nbsp;</a></span>bit_or() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp; <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::bit_or </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bv1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bv2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::<a class="el" href="classbm_1_1bvector.html#a05f1e977cb5e6208838afc7e7b69e5f0">optmode</a>&#160;</td>
          <td class="paramname"><em>opt_mode</em> = <code><a class="el" href="classbm_1_1bvector.html#a05f1e977cb5e6208838afc7e7b69e5f0afc03833a1770728dde103c7364b12660">opt_none</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>3-operand OR : this := bv1 OR bv2 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bv1</td><td>- Argument vector 1 </td></tr>
    <tr><td class="paramname">bv2</td><td>- Argument vector 2 </td></tr>
    <tr><td class="paramname">opt_mode</td><td>- optimization compression (when it is performed on the fly it is faster than a separate call to <a class="el" href="classbm_1_1bvector.html#a622e6827d799a561e2f0db28f7ac19d2" title="Optimize memory bitvector&#39;s memory allocation.">optimize()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbm_1_1bvector.html#a622e6827d799a561e2f0db28f7ac19d2" title="Optimize memory bitvector&#39;s memory allocation.">optimize</a>, <a class="el" href="classbm_1_1bvector.html#a001b183876bd7ab940f711bb48263d47" title="3-operand OR : this := bv1 OR bv2">bit_or</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="bvsetalgebra_8cpp-example.html#a13">bvsetalgebra.cpp</a>, <a class="el" href="sample4_8cpp-example.html#a23">sample4.cpp</a>, and <a class="el" href="svsample10_8cpp-example.html#a15">svsample10.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l05689">5689</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bm_8h_source.html#l05689">bm::bvector&lt; Alloc &gt;::bit_or()</a>, <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>, <a class="el" href="bm_8h_source.html#l06655">bm::bvector&lt; Alloc &gt;::combine_operation_block_or()</a>, <a class="el" href="bmdef_8h_source.html#l00158">FULL_BLOCK_FAKE_ADDR</a>, <a class="el" href="bm_8h_source.html#l02070">bm::bvector&lt; Alloc &gt;::get_blocks_manager()</a>, <a class="el" href="bm_8h_source.html#l01080">bm::bvector&lt; Alloc &gt;::is_ro()</a>, <a class="el" href="bm_8h_source.html#l00137">bm::bvector&lt; Alloc &gt;::opt_compress</a>, <a class="el" href="bm_8h_source.html#l00134">bm::bvector&lt; Alloc &gt;::opt_none</a>, and <a class="el" href="bmconst_8h_source.html#l00095">bm::set_sub_array_size</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l05689">bm::bvector&lt; Alloc &gt;::bit_or()</a>, <a class="el" href="bm_8h_source.html#l05996">bm::bvector&lt; Alloc &gt;::bit_or_and()</a>, <a class="el" href="bm_8h_source.html#l06113">bm::bvector&lt; Alloc &gt;::bit_sub()</a>, <a class="el" href="bvsetalgebra_8cpp_source.html#l00096">DemoOR()</a>, <a class="el" href="bmsparsevec__algo_8h_source.html#l00066">bm::dynamic_range_clip_high()</a>, <a class="el" href="bmsparsevec__algo_8h_source.html#l00106">bm::dynamic_range_clip_low()</a>, <a class="el" href="sample4_8cpp_source.html#l00106">main()</a>, <a class="el" href="bm_8h_source.html#l05599">bm::bvector&lt; Alloc &gt;::merge()</a>, <a class="el" href="bm_8h_source.html#l02257">bm::operator|()</a>, <a class="el" href="bm_8h_source.html#l01042">bm::bvector&lt; Alloc &gt;::operator|=()</a>, and <a class="el" href="bmsparsevec__algo_8h_source.html#l00347">bm::sparse_vector_find_mismatch()</a>.</p>

</div>
</div>
<a id="ae7de27b4dad4aa277b074182ab663710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7de27b4dad4aa277b074182ab663710">&#9670;&nbsp;</a></span>bit_or_and()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp; <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::bit_or_and </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bv1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bv2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::<a class="el" href="classbm_1_1bvector.html#a05f1e977cb5e6208838afc7e7b69e5f0">optmode</a>&#160;</td>
          <td class="paramname"><em>opt_mode</em> = <code><a class="el" href="classbm_1_1bvector.html#a05f1e977cb5e6208838afc7e7b69e5f0afc03833a1770728dde103c7364b12660">opt_none</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>3-operand AND where result is ORed into the terget vector : this |= bv1 AND bv2 TARGET := TARGET OR (BV1 AND BV2) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bv1</td><td>- Argument vector 1 </td></tr>
    <tr><td class="paramname">bv2</td><td>- Argument vector 2 </td></tr>
    <tr><td class="paramname">opt_mode</td><td>- optimization compression (when it is performed on the fly it is faster than a separate call to <a class="el" href="classbm_1_1bvector.html#a622e6827d799a561e2f0db28f7ac19d2" title="Optimize memory bitvector&#39;s memory allocation.">optimize()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbm_1_1bvector.html#a622e6827d799a561e2f0db28f7ac19d2" title="Optimize memory bitvector&#39;s memory allocation.">optimize</a>, <a class="el" href="classbm_1_1bvector.html#a37c1ccb4755c61450311918ad3330aa6" title="3-operand AND : this := bv1 AND bv2">bit_and</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="bvsetalgebra_8cpp-example.html#a48">bvsetalgebra.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l05996">5996</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bm_8h_source.html#l05901">bm::bvector&lt; Alloc &gt;::bit_and()</a>, <a class="el" href="bm_8h_source.html#l05689">bm::bvector&lt; Alloc &gt;::bit_or()</a>, <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>, <a class="el" href="bm_8h_source.html#l06810">bm::bvector&lt; Alloc &gt;::combine_operation_block_and()</a>, <a class="el" href="bm_8h_source.html#l06895">bm::bvector&lt; Alloc &gt;::combine_operation_block_and_or()</a>, <a class="el" href="bmdef_8h_source.html#l00158">FULL_BLOCK_FAKE_ADDR</a>, <a class="el" href="bmdef_8h_source.html#l00159">FULL_SUB_BLOCK_REAL_ADDR</a>, <a class="el" href="bm_8h_source.html#l02070">bm::bvector&lt; Alloc &gt;::get_blocks_manager()</a>, <a class="el" href="bm_8h_source.html#l01080">bm::bvector&lt; Alloc &gt;::is_ro()</a>, <a class="el" href="bm_8h_source.html#l00137">bm::bvector&lt; Alloc &gt;::opt_compress</a>, <a class="el" href="bm_8h_source.html#l00134">bm::bvector&lt; Alloc &gt;::opt_none</a>, and <a class="el" href="bmconst_8h_source.html#l00095">bm::set_sub_array_size</a>.</p>

<p class="reference">Referenced by <a class="el" href="bvsetalgebra_8cpp_source.html#l00513">DemoAND_OR()</a>.</p>

</div>
</div>
<a id="aeb5659f54365fb0a7714a3c3282ca481"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb5659f54365fb0a7714a3c3282ca481">&#9670;&nbsp;</a></span>bit_sub() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt;Alloc&gt;&amp; <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::bit_sub </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>2 operand logical SUB(AND NOT). Also known as MINUS. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bv</td><td>- argument vector. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01837">1837</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>, <a class="el" href="bm_8h_source.html#l06469">bm::bvector&lt; Alloc &gt;::combine_operation_sub()</a>, and <a class="el" href="bm_8h_source.html#l01080">bm::bvector&lt; Alloc &gt;::is_ro()</a>.</p>

</div>
</div>
<a id="a5a0538cdc1ced8502f42c2ca602c0b91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a0538cdc1ced8502f42c2ca602c0b91">&#9670;&nbsp;</a></span>bit_sub() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp; <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::bit_sub </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bv1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bv2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::<a class="el" href="classbm_1_1bvector.html#a05f1e977cb5e6208838afc7e7b69e5f0">optmode</a>&#160;</td>
          <td class="paramname"><em>opt_mode</em> = <code><a class="el" href="classbm_1_1bvector.html#a05f1e977cb5e6208838afc7e7b69e5f0afc03833a1770728dde103c7364b12660">opt_none</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>3-operand SUB : this := bv1 MINUS bv2 SUBtraction is also known as AND NOT </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bv1</td><td>- Argument vector 1 </td></tr>
    <tr><td class="paramname">bv2</td><td>- Argument vector 2 </td></tr>
    <tr><td class="paramname">opt_mode</td><td>- optimization compression (when it is performed on the fly it is faster than a separate call to <a class="el" href="classbm_1_1bvector.html#a622e6827d799a561e2f0db28f7ac19d2" title="Optimize memory bitvector&#39;s memory allocation.">optimize()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbm_1_1bvector.html#a622e6827d799a561e2f0db28f7ac19d2" title="Optimize memory bitvector&#39;s memory allocation.">optimize</a>, <a class="el" href="classbm_1_1bvector.html#a5a0538cdc1ced8502f42c2ca602c0b91" title="3-operand SUB : this := bv1 MINUS bv2 SUBtraction is also known as AND NOT">bit_sub</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="bvsetalgebra_8cpp-example.html#a41">bvsetalgebra.cpp</a>, and <a class="el" href="xsample07_8cpp-example.html#a70">xsample07.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l06113">6113</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bm_8h_source.html#l05689">bm::bvector&lt; Alloc &gt;::bit_or()</a>, <a class="el" href="bm_8h_source.html#l06113">bm::bvector&lt; Alloc &gt;::bit_sub()</a>, <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>, <a class="el" href="bm_8h_source.html#l06995">bm::bvector&lt; Alloc &gt;::combine_operation_block_sub()</a>, <a class="el" href="bmdef_8h_source.html#l00158">FULL_BLOCK_FAKE_ADDR</a>, <a class="el" href="bmdef_8h_source.html#l00159">FULL_SUB_BLOCK_REAL_ADDR</a>, <a class="el" href="bm_8h_source.html#l02070">bm::bvector&lt; Alloc &gt;::get_blocks_manager()</a>, <a class="el" href="bm_8h_source.html#l01080">bm::bvector&lt; Alloc &gt;::is_ro()</a>, <a class="el" href="bm_8h_source.html#l00137">bm::bvector&lt; Alloc &gt;::opt_compress</a>, <a class="el" href="bm_8h_source.html#l00134">bm::bvector&lt; Alloc &gt;::opt_none</a>, and <a class="el" href="bmconst_8h_source.html#l00095">bm::set_sub_array_size</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l06113">bm::bvector&lt; Alloc &gt;::bit_sub()</a>, <a class="el" href="bm_8h_source.html#l04139">bm::bvector&lt; Alloc &gt;::clear()</a>, <a class="el" href="bvsetalgebra_8cpp_source.html#l00401">DemoSUB()</a>, <a class="el" href="xsample07_8cpp_source.html#l00966">main()</a>, <a class="el" href="bm_8h_source.html#l02279">bm::operator-()</a>, and <a class="el" href="bm_8h_source.html#l01043">bm::bvector&lt; Alloc &gt;::operator-=()</a>.</p>

</div>
</div>
<a id="ae087c7b4d78f00d7b04ea0e9e4915ba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae087c7b4d78f00d7b04ea0e9e4915ba3">&#9670;&nbsp;</a></span>bit_xor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt;Alloc&gt;&amp; <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::bit_xor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>2 operand logical XOR </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bv</td><td>- argument vector. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01826">1826</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>, <a class="el" href="bm_8h_source.html#l06282">bm::bvector&lt; Alloc &gt;::combine_operation_xor()</a>, and <a class="el" href="bm_8h_source.html#l01080">bm::bvector&lt; Alloc &gt;::is_ro()</a>.</p>

</div>
</div>
<a id="af34934a5a60a21f364b8df4dfc0f7247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af34934a5a60a21f364b8df4dfc0f7247">&#9670;&nbsp;</a></span>bit_xor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp; <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::bit_xor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bv1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bv2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::<a class="el" href="classbm_1_1bvector.html#a05f1e977cb5e6208838afc7e7b69e5f0">optmode</a>&#160;</td>
          <td class="paramname"><em>opt_mode</em> = <code><a class="el" href="classbm_1_1bvector.html#a05f1e977cb5e6208838afc7e7b69e5f0afc03833a1770728dde103c7364b12660">opt_none</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>3-operand XOR : this := bv1 XOR bv2 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bv1</td><td>- Argument vector 1 </td></tr>
    <tr><td class="paramname">bv2</td><td>- Argument vector 2 </td></tr>
    <tr><td class="paramname">opt_mode</td><td>- optimization compression (when it is performed on the fly it is faster than a separate call to <a class="el" href="classbm_1_1bvector.html#a622e6827d799a561e2f0db28f7ac19d2" title="Optimize memory bitvector&#39;s memory allocation.">optimize()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbm_1_1bvector.html#a622e6827d799a561e2f0db28f7ac19d2" title="Optimize memory bitvector&#39;s memory allocation.">optimize</a>, <a class="el" href="classbm_1_1bvector.html#af34934a5a60a21f364b8df4dfc0f7247" title="3-operand XOR : this := bv1 XOR bv2">bit_xor</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="bvsetalgebra_8cpp-example.html#a36">bvsetalgebra.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l05788">5788</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bm_8h_source.html#l05788">bm::bvector&lt; Alloc &gt;::bit_xor()</a>, <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>, <a class="el" href="bm_8h_source.html#l06728">bm::bvector&lt; Alloc &gt;::combine_operation_block_xor()</a>, <a class="el" href="bmdef_8h_source.html#l00158">FULL_BLOCK_FAKE_ADDR</a>, <a class="el" href="bmdef_8h_source.html#l00159">FULL_SUB_BLOCK_REAL_ADDR</a>, <a class="el" href="bm_8h_source.html#l02070">bm::bvector&lt; Alloc &gt;::get_blocks_manager()</a>, <a class="el" href="bm_8h_source.html#l01080">bm::bvector&lt; Alloc &gt;::is_ro()</a>, <a class="el" href="bm_8h_source.html#l00137">bm::bvector&lt; Alloc &gt;::opt_compress</a>, <a class="el" href="bm_8h_source.html#l00134">bm::bvector&lt; Alloc &gt;::opt_none</a>, and <a class="el" href="bmconst_8h_source.html#l00095">bm::set_sub_array_size</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l05788">bm::bvector&lt; Alloc &gt;::bit_xor()</a>, <a class="el" href="bvsetalgebra_8cpp_source.html#l00330">DemoXOR()</a>, <a class="el" href="bm_8h_source.html#l02268">bm::operator^()</a>, <a class="el" href="bm_8h_source.html#l01041">bm::bvector&lt; Alloc &gt;::operator^=()</a>, and <a class="el" href="bmsparsevec__algo_8h_source.html#l00347">bm::sparse_vector_find_mismatch()</a>.</p>

</div>
</div>
<a id="adfb63744a9d6039d9e8daa38cf21e3c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfb63744a9d6039d9e8daa38cf21e3c6">&#9670;&nbsp;</a></span>build_rs_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::build_rs_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#ac9ed62250af37ade811aaf20b7a8d9a2">rs_index_type</a> *&#160;</td>
          <td class="paramname"><em>rs_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; *&#160;</td>
          <td class="paramname"><em>bv_blocks</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute running total of all blocks in bit vector (rank-select index) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rs_idx</td><td>- [out] pointer to index / count structure </td></tr>
    <tr><td class="paramname">bv_blocks</td><td>- [out] list of block ids in the vector (internal, optional) Function will fill full array of running totals </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbm_1_1bvector.html#ad3e0e88f17cc86b58e006186955c461b" title="Returns count of 1 bits (population) in [0..right] range.">count_to</a>, <a class="el" href="classbm_1_1bvector.html#a7ded07c26c000250baf5215c29c3b602" title="select bit-vector position for the specified rank(bitcount)">select</a>, <a class="el" href="classbm_1_1bvector.html#a9b2b0eb6ec338ab789ec6508cfab7ff0" title="Find bit-vector position for the specified rank(bitcount)">find_rank</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="sample11_8cpp-example.html#a23">sample11.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l02499">2499</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmfunc_8h_source.html#l05347">bm::bit_block_calc_count_range()</a>, <a class="el" href="bmfunc_8h_source.html#l05433">bm::bit_block_calc_count_to()</a>, <a class="el" href="bmdef_8h_source.html#l00160">BLOCK_ADDR_SAN</a>, <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>, <a class="el" href="bmdef_8h_source.html#l00191">BM_IS_GAP</a>, <a class="el" href="bmdef_8h_source.html#l00189">BMGAP_PTR</a>, <a class="el" href="bm_8h_source.html#l04139">bm::bvector&lt; Alloc &gt;::clear()</a>, <a class="el" href="bm_8h_source.html#l04694">bm::bvector&lt; Alloc &gt;::find_reverse()</a>, <a class="el" href="bmdef_8h_source.html#l00158">FULL_BLOCK_FAKE_ADDR</a>, <a class="el" href="bmfunc_8h_source.html#l01688">bm::gap_bfind()</a>, <a class="el" href="bmfunc_8h_source.html#l02344">bm::gap_bit_count_range()</a>, <a class="el" href="bmfunc_8h_source.html#l02694">bm::gap_bit_count_to()</a>, <a class="el" href="bmconst_8h_source.html#l00081">bm::gap_max_bits</a>, <a class="el" href="bmfunc_8h_source.html#l00163">bm::get_block_coord()</a>, <a class="el" href="bm_8h_source.html#l02291">bm::bvector&lt; Alloc &gt;::init()</a>, <a class="el" href="bmconst_8h_source.html#l00119">bm::rs3_border0</a>, <a class="el" href="bmconst_8h_source.html#l00122">bm::rs3_border0_1</a>, <a class="el" href="bmconst_8h_source.html#l00120">bm::rs3_border1</a>, <a class="el" href="bmconst_8h_source.html#l00123">bm::rs3_border1_1</a>, <a class="el" href="bm_8h_source.html#l04426">bm::bvector&lt; Alloc &gt;::set_bit_no_check()</a>, <a class="el" href="bmconst_8h_source.html#l00056">bm::set_block_shift</a>, and <a class="el" href="bmconst_8h_source.html#l00095">bm::set_sub_array_size</a>.</p>

<p class="reference">Referenced by <a class="el" href="sample11_8cpp_source.html#l00154">bv_count_range_acc()</a>, <a class="el" href="sample11_8cpp_source.html#l00180">bv_count_to_acc()</a>, and <a class="el" href="sample11_8cpp_source.html#l00206">bv_count_to_range_acc()</a>.</p>

</div>
</div>
<a id="af30532c371bfdc8e2ba02bc2115b004d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af30532c371bfdc8e2ba02bc2115b004d">&#9670;&nbsp;</a></span>calc_stat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::calc_stat </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::<a class="el" href="structbm_1_1bvector_1_1statistics.html">statistics</a> *&#160;</td>
          <td class="paramname"><em>st</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates bitvector statistics. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">st</td><td>- pointer on statistics structure to be filled in.</td></tr>
  </table>
  </dd>
</dl>
<p>Function fills statistics structure containing information about how this vector uses memory and estimation of max. amount of memory bvector needs to serialize itself.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structbm_1_1bvector_1_1statistics.html" title="Statistical information about bitset&#39;s memory allocation details.">statistics</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="sample11_8cpp-example.html#a13">sample11.cpp</a>, <a class="el" href="sample26_8cpp-example.html#a6">sample26.cpp</a>, <a class="el" href="sample3_8cpp-example.html#a6">sample3.cpp</a>, <a class="el" href="sample4_8cpp-example.html#a6">sample4.cpp</a>, and <a class="el" href="xsample01_8cpp-example.html#a45">xsample01.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l03968">3968</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>, <a class="el" href="bmdef_8h_source.html#l00191">BM_IS_GAP</a>, <a class="el" href="bmdef_8h_source.html#l00189">BMGAP_PTR</a>, <a class="el" href="bmfunc_8h_source.html#l01390">bm::find_not_null_ptr()</a>, <a class="el" href="bmdef_8h_source.html#l00158">FULL_BLOCK_FAKE_ADDR</a>, <a class="el" href="bmfunc_8h_source.html#l01582">bm::gap_capacity()</a>, <a class="el" href="bmfunc_8h_source.html#l01566">bm::gap_length()</a>, <a class="el" href="bmfunc_8h_source.html#l01612">bm::gap_level()</a>, <a class="el" href="bmconst_8h_source.html#l00085">bm::gap_levels</a>, <a class="el" href="bm_8h_source.html#l01080">bm::bvector&lt; Alloc &gt;::is_ro()</a>, <a class="el" href="bmdef_8h_source.html#l00161">IS_VALID_ADDR</a>, <a class="el" href="bmconst_8h_source.html#l00055">bm::set_block_size</a>, and <a class="el" href="bmconst_8h_source.html#l00095">bm::set_sub_array_size</a>.</p>

<p class="reference">Referenced by <a class="el" href="xsample01_8cpp_source.html#l00283">calc_memory_footprint()</a>, <a class="el" href="xsample01_8cpp_source.html#l00305">convert_bv2bvs()</a>, <a class="el" href="sample11_8cpp_source.html#l00059">generate_bvector()</a>, <a class="el" href="bm_8h_source.html#l03625">bm::bvector&lt; Alloc &gt;::optimize()</a>, <a class="el" href="bm_8h_source.html#l03690">bm::bvector&lt; Alloc &gt;::optimize_gap_size()</a>, and <a class="el" href="sample3_8cpp_source.html#l00061">print_statistics()</a>.</p>

</div>
</div>
<a id="a56ede517bb0b4e125e3485fb518b3dc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56ede517bb0b4e125e3485fb518b3dc6">&#9670;&nbsp;</a></span>check_or_next()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt;::<a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::check_or_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td>
          <td class="paramname"><em>prev</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l05107">5107</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmfunc_8h_source.html#l08380">bm::bit_block_find()</a>, <a class="el" href="bmfunc_8h_source.html#l08465">bm::bit_find_first()</a>, <a class="el" href="bmconst_8h_source.html#l00115">bm::bits_in_array</a>, <a class="el" href="bmdef_8h_source.html#l00191">BM_IS_GAP</a>, <a class="el" href="bmdef_8h_source.html#l00189">BMGAP_PTR</a>, <a class="el" href="bmdef_8h_source.html#l00158">FULL_BLOCK_FAKE_ADDR</a>, <a class="el" href="bmdef_8h_source.html#l00159">FULL_SUB_BLOCK_REAL_ADDR</a>, <a class="el" href="bmfunc_8h_source.html#l03667">bm::gap_block_find()</a>, <a class="el" href="bmfunc_8h_source.html#l01661">bm::gap_find_first()</a>, <a class="el" href="bmconst_8h_source.html#l00081">bm::gap_max_bits</a>, <a class="el" href="bmfunc_8h_source.html#l00163">bm::get_block_coord()</a>, <a class="el" href="bmconst_8h_source.html#l00057">bm::set_block_mask</a>, <a class="el" href="bmconst_8h_source.html#l00056">bm::set_block_shift</a>, and <a class="el" href="bmconst_8h_source.html#l00095">bm::set_sub_array_size</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l05191">bm::bvector&lt; Alloc &gt;::check_or_next_extract()</a>, <a class="el" href="bm_8h_source.html#l04679">bm::bvector&lt; Alloc &gt;::find()</a>, <a class="el" href="bm_8h_source.html#l01612">bm::bvector&lt; Alloc &gt;::get_first()</a>, and <a class="el" href="bm_8h_source.html#l01621">bm::bvector&lt; Alloc &gt;::get_next()</a>.</p>

</div>
</div>
<a id="a518b24a7762be7cfd1aab04de68234f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a518b24a7762be7cfd1aab04de68234f3">&#9670;&nbsp;</a></span>check_or_next_extract()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt;::<a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::check_or_next_extract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td>
          <td class="paramname"><em>prev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check if specified bit is 1, and set it to 0 if specified bit is 0, scan for the next 1 and returns it if no 1 found returns 0 </p>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l05191">5191</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>, <a class="el" href="bm_8h_source.html#l05107">bm::bvector&lt; Alloc &gt;::check_or_next()</a>, <a class="el" href="bm_8h_source.html#l04460">bm::bvector&lt; Alloc &gt;::clear_bit_no_check()</a>, and <a class="el" href="bm_8h_source.html#l01080">bm::bvector&lt; Alloc &gt;::is_ro()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l01631">bm::bvector&lt; Alloc &gt;::extract_next()</a>.</p>

</div>
</div>
<a id="a4e02adaea0509c3dbde5abbd9e782131"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e02adaea0509c3dbde5abbd9e782131">&#9670;&nbsp;</a></span>clear() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::clear </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>free_mem</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears every bit in the bitvector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">free_mem</td><td>if "true" (default) bvector frees the memory, otherwise sets blocks to 0. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l04125">4125</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>, and <a class="el" href="bm_8h_source.html#l01080">bm::bvector&lt; Alloc &gt;::is_ro()</a>.</p>

</div>
</div>
<a id="ac6f13fa4ba188585e5c5d4e89843a44e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6f13fa4ba188585e5c5d4e89843a44e">&#9670;&nbsp;</a></span>clear() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::clear </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> *&#160;</td>
          <td class="paramname"><em>ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td>
          <td class="paramname"><em>ids_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bvector.html#ga04a7a7cda4bf04cd107e198b3b1e4ed8">bm::sort_order</a>&#160;</td>
          <td class="paramname"><em>so</em> = <code><a class="el" href="group__bvector.html#gga04a7a7cda4bf04cd107e198b3b1e4ed8a981e9b62bb43cc0388f268f1041f9293">bm::BM_UNKNOWN</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>clear list of bits in this bitset </p>
<p >This is equivalent of AND NOT (Set Substract), argument set as an array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ids</td><td>- pointer on array of indexes to set </td></tr>
    <tr><td class="paramname">ids_size</td><td>- size of the input (ids) </td></tr>
    <tr><td class="paramname">so</td><td>- sort order (use BM_SORTED for faster load)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbm_1_1bvector.html#a52b4259a5cc4ebd8953832c696e24f02" title="Sets bit n if val is true, clears bit n if val is false.">set</a>, <a class="el" href="classbm_1_1bvector.html#ae79e966df54b3083fb14519f74a800af" title="Keep list of bits in this bitset, others are cleared.">keep</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="bvsetalgebra_8cpp-example.html#a44">bvsetalgebra.cpp</a>, <a class="el" href="sample12_8cpp-example.html#a21">sample12.cpp</a>, <a class="el" href="sample18_8cpp-example.html#a5">sample18.cpp</a>, <a class="el" href="sample7_8cpp-example.html#a7">sample7.cpp</a>, <a class="el" href="svsample04_8cpp-example.html#a5">svsample04.cpp</a>, and <a class="el" href="xsample07a_8cpp-example.html#a97">xsample07a.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l04139">4139</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bm_8h_source.html#l06113">bm::bvector&lt; Alloc &gt;::bit_sub()</a>, <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>, <a class="el" href="bm_8h_source.html#l04694">bm::bvector&lt; Alloc &gt;::find_reverse()</a>, <a class="el" href="bm_8h_source.html#l04235">bm::bvector&lt; Alloc &gt;::import()</a>, <a class="el" href="bm_8h_source.html#l01080">bm::bvector&lt; Alloc &gt;::is_ro()</a>, and <a class="el" href="bm_8h_source.html#l02461">bm::bvector&lt; Alloc &gt;::resize()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l02499">bm::bvector&lt; Alloc &gt;::build_rs_index()</a>, <a class="el" href="sample11_8cpp_source.html#l00239">bv_count_and()</a>, <a class="el" href="bm_8h_source.html#l06381">bm::bvector&lt; Alloc &gt;::combine_operation_and()</a>, <a class="el" href="xsample07a_8cpp_source.html#l00973">compute_seq_group_union()</a>, <a class="el" href="bm_8h_source.html#l07764">bm::bvector&lt; Alloc &gt;::copy_range()</a>, <a class="el" href="bvsetalgebra_8cpp_source.html#l00401">DemoSUB()</a>, <a class="el" href="xsample07a_8cpp_source.html#l00994">CSeqClusters::elect_leaders()</a>, <a class="el" href="bm_8h_source.html#l04095">bm::bvector&lt; Alloc &gt;::keep()</a>, <a class="el" href="sample7_8cpp_source.html#l00072">main()</a>, <a class="el" href="bm_8h_source.html#l01279">bm::bvector&lt; Alloc &gt;::reset()</a>, <a class="el" href="xsample01_8cpp_source.html#l00555">speed_test_bv_index()</a>, <a class="el" href="xsample01_8cpp_source.html#l00614">speed_test_bvs_index()</a>, <a class="el" href="xsample01_8cpp_source.html#l00740">speed_test_sv_index()</a>, <a class="el" href="xsample01_8cpp_source.html#l00678">speed_test_vect_index()</a>, and <a class="el" href="xsample07a_8cpp_source.html#l00830">CSeqClusters::union_all_groups()</a>.</p>

</div>
</div>
<a id="a352a4c7989b9a36c986d9d0302e9ad9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a352a4c7989b9a36c986d9d0302e9ad9e">&#9670;&nbsp;</a></span>clear_bit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::clear_bit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears bit n. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>- bit's index to be cleaned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if bit was cleared </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="sample12_8cpp-example.html#a24">sample12.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01259">1259</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bm_8h_source.html#l04217">bm::bvector&lt; Alloc &gt;::set_bit()</a>.</p>

</div>
</div>
<a id="ae090add70219316e9c0b3eb914b9cb8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae090add70219316e9c0b3eb914b9cb8e">&#9670;&nbsp;</a></span>clear_bit_no_check()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::clear_bit_no_check </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears bit n without precondiion checks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>- bit's index to be cleaned. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l04460">4460</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>, <a class="el" href="bmdef_8h_source.html#l00338">BM_ASSERT_THROW</a>, <a class="el" href="bmdef_8h_source.html#l00189">BMGAP_PTR</a>, <a class="el" href="bm_8h_source.html#l04513">bm::bvector&lt; Alloc &gt;::gap_block_set_no_ret()</a>, <a class="el" href="bm_8h_source.html#l01932">bm::bvector&lt; Alloc &gt;::get_new_blocks_strat()</a>, <a class="el" href="bmconst_8h_source.html#l00109">bm::id_max</a>, <a class="el" href="bm_8h_source.html#l01080">bm::bvector&lt; Alloc &gt;::is_ro()</a>, <a class="el" href="bmconst_8h_source.html#l00057">bm::set_block_mask</a>, <a class="el" href="bmconst_8h_source.html#l00056">bm::set_block_shift</a>, <a class="el" href="bmconst_8h_source.html#l00073">bm::set_word_mask</a>, and <a class="el" href="bmconst_8h_source.html#l00072">bm::set_word_shift</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l05191">bm::bvector&lt; Alloc &gt;::check_or_next_extract()</a>.</p>

</div>
</div>
<a id="a81d21e99befe6e54a0fb33c0778cf1f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81d21e99befe6e54a0fb33c0778cf1f0">&#9670;&nbsp;</a></span>clear_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::clear_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets all bits to zero in the specified closed interval [left,right] Interval must be inside the bvector's size. This method DOES NOT resize vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>- interval start </td></tr>
    <tr><td class="paramname">right</td><td>- interval end (closed interval)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbm_1_1bvector.html#aafb2ecaa1a55856533e6b4afbf788eae" title="Sets all bits in the specified closed interval [left,right] Interval must be inside the bvector&#39;s siz...">set_range</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01228">1228</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bm_8h_source.html#l02366">bm::bvector&lt; Alloc &gt;::set_range()</a>.</p>

<p class="reference">Referenced by <a class="el" href="sample22_8cpp_source.html#l00072">main()</a>.</p>

</div>
</div>
<a id="ae57f6d62d1f54eeaa604ae7ce53e0e0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae57f6d62d1f54eeaa604ae7ce53e0e0f">&#9670;&nbsp;</a></span>combine_operation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::combine_operation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bvect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bvector.html#ga42405343976ec931388381cea4092bf1">bm::operation</a>&#160;</td>
          <td class="paramname"><em>opcode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>perform a set-algebra operation by operation code </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="bvsetalgebra_8cpp-example.html#a16">bvsetalgebra.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l06533">6533</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmconst_8h_source.html#l00191">bm::BM_AND</a>, <a class="el" href="bmdef_8h_source.html#l00191">BM_IS_GAP</a>, <a class="el" href="bmconst_8h_source.html#l00193">bm::BM_SUB</a>, <a class="el" href="bm_8h_source.html#l05672">bm::bvector&lt; Alloc &gt;::combine_operation_with_block()</a>, <a class="el" href="bm_8h_source.html#l02366">bm::bvector&lt; Alloc &gt;::set_range()</a>, and <a class="el" href="bmconst_8h_source.html#l00095">bm::set_sub_array_size</a>.</p>

<p class="reference">Referenced by <a class="el" href="bvsetalgebra_8cpp_source.html#l00221">DemoAND()</a>, <a class="el" href="bvsetalgebra_8cpp_source.html#l00096">DemoOR()</a>, <a class="el" href="bvsetalgebra_8cpp_source.html#l00401">DemoSUB()</a>, and <a class="el" href="bvsetalgebra_8cpp_source.html#l00330">DemoXOR()</a>.</p>

</div>
</div>
<a id="a84bd0af8809c420103c6545b6ea92412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84bd0af8809c420103c6545b6ea92412">&#9670;&nbsp;</a></span>combine_operation_and()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::combine_operation_and </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bvect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a05f1e977cb5e6208838afc7e7b69e5f0">optmode</a>&#160;</td>
          <td class="paramname"><em>opt_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>perform a set-algebra operation AND </p>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l06381">6381</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmavx2_8h_source.html#l01592">bm::avx2_test_all_zero_wave()</a>, <a class="el" href="bm_8h_source.html#l06368">BM_AND_OP</a>, <a class="el" href="bm_8h_source.html#l04139">bm::bvector&lt; Alloc &gt;::clear()</a>, <a class="el" href="bmdef_8h_source.html#l00158">FULL_BLOCK_FAKE_ADDR</a>, <a class="el" href="bmconst_8h_source.html#l00095">bm::set_sub_array_size</a>, and <a class="el" href="bmsse4_8h_source.html#l00671">bm::sse42_test_all_zero_wave()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l01814">bm::bvector&lt; Alloc &gt;::bit_and()</a>.</p>

</div>
</div>
<a id="ac2dcf7f8fa7a660d8bde25757e8d259c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2dcf7f8fa7a660d8bde25757e8d259c">&#9670;&nbsp;</a></span>combine_operation_block_and() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::combine_operation_block_and </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *&#160;</td>
          <td class="paramname"><em>blk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *&#160;</td>
          <td class="paramname"><em>arg_blk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l07252">7252</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmfunc_8h_source.html#l06815">bm::bit_block_and()</a>, <a class="el" href="bmfunc_8h_source.html#l06734">bm::bit_block_copy()</a>, <a class="el" href="bmfunc_8h_source.html#l01513">bm::bit_is_all_zero()</a>, <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>, <a class="el" href="bmdef_8h_source.html#l00191">BM_IS_GAP</a>, <a class="el" href="bmdef_8h_source.html#l00189">BMGAP_PTR</a>, <a class="el" href="bmdef_8h_source.html#l00190">BMSET_PTRGAP</a>, <a class="el" href="bmfunc_8h_source.html#l01083">bm::calc_block_digest0()</a>, <a class="el" href="bm_8h_source.html#l01574">bm::bvector&lt; Alloc &gt;::empty()</a>, <a class="el" href="bmfunc_8h_source.html#l04058">bm::gap_and_to_bitset()</a>, <a class="el" href="bmconst_8h_source.html#l00082">bm::gap_equiv_len</a>, <a class="el" href="bmfunc_8h_source.html#l01540">bm::gap_is_all_zero()</a>, <a class="el" href="bmfunc_8h_source.html#l06475">bm::gap_operation_and()</a>, <a class="el" href="bmdef_8h_source.html#l00162">IS_FULL_BLOCK</a>, <a class="el" href="bmfunc_8h_source.html#l01125">bm::update_block_digest0()</a>, and <a class="el" href="bmutil_8h_source.html#l00598">bm::word_bitcount64()</a>.</p>

</div>
</div>
<a id="a84464d2f51d17af7a1769ce5b21f4352"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84464d2f51d17af7a1769ce5b21f4352">&#9670;&nbsp;</a></span>combine_operation_block_and() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::combine_operation_block_and </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *&#160;</td>
          <td class="paramname"><em>arg_blk1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *&#160;</td>
          <td class="paramname"><em>arg_blk2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l06810">6810</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmfunc_8h_source.html#l06974">bm::bit_block_and_2way()</a>, <a class="el" href="bmfunc_8h_source.html#l01513">bm::bit_is_all_zero()</a>, <a class="el" href="bmdef_8h_source.html#l00191">BM_IS_GAP</a>, <a class="el" href="bmdef_8h_source.html#l00189">BMGAP_PTR</a>, <a class="el" href="bmdef_8h_source.html#l00158">FULL_BLOCK_FAKE_ADDR</a>, <a class="el" href="bmfunc_8h_source.html#l04058">bm::gap_and_to_bitset()</a>, <a class="el" href="bmconst_8h_source.html#l00082">bm::gap_equiv_len</a>, and <a class="el" href="bmfunc_8h_source.html#l06475">bm::gap_operation_and()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l05901">bm::bvector&lt; Alloc &gt;::bit_and()</a>, and <a class="el" href="bm_8h_source.html#l05996">bm::bvector&lt; Alloc &gt;::bit_or_and()</a>.</p>

</div>
</div>
<a id="a128e0a08161072a5513a26fb6dbc8432"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a128e0a08161072a5513a26fb6dbc8432">&#9670;&nbsp;</a></span>combine_operation_block_and_or()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::combine_operation_block_and_or </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *&#160;</td>
          <td class="paramname"><em>arg_blk1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *&#160;</td>
          <td class="paramname"><em>arg_blk2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l06895">6895</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmfunc_8h_source.html#l07041">bm::bit_block_and_or_2way()</a>, <a class="el" href="bmfunc_8h_source.html#l06734">bm::bit_block_copy()</a>, <a class="el" href="bmfunc_8h_source.html#l07666">bm::bit_block_or()</a>, <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>, <a class="el" href="bmdef_8h_source.html#l00191">BM_IS_GAP</a>, <a class="el" href="bmdef_8h_source.html#l00189">BMGAP_PTR</a>, <a class="el" href="bm_8h_source.html#l06655">bm::bvector&lt; Alloc &gt;::combine_operation_block_or()</a>, <a class="el" href="bmdef_8h_source.html#l00158">FULL_BLOCK_FAKE_ADDR</a>, <a class="el" href="bmfunc_8h_source.html#l04007">bm::gap_add_to_bitset()</a>, <a class="el" href="bmfunc_8h_source.html#l04058">bm::gap_and_to_bitset()</a>, <a class="el" href="bmconst_8h_source.html#l00082">bm::gap_equiv_len</a>, <a class="el" href="bmfunc_8h_source.html#l06475">bm::gap_operation_and()</a>, and <a class="el" href="bmfunc_8h_source.html#l06038">bm::is_bits_one()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l05996">bm::bvector&lt; Alloc &gt;::bit_or_and()</a>.</p>

</div>
</div>
<a id="a28d00112c746de55ead821ceba7ff65a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28d00112c746de55ead821ceba7ff65a">&#9670;&nbsp;</a></span>combine_operation_block_or() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::combine_operation_block_or </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *&#160;</td>
          <td class="paramname"><em>blk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *&#160;</td>
          <td class="paramname"><em>arg_blk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l07069">7069</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmfunc_8h_source.html#l06734">bm::bit_block_copy()</a>, <a class="el" href="bmfunc_8h_source.html#l07666">bm::bit_block_or()</a>, <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>, <a class="el" href="bmdef_8h_source.html#l00191">BM_IS_GAP</a>, <a class="el" href="bmdef_8h_source.html#l00189">BMGAP_PTR</a>, <a class="el" href="bmdef_8h_source.html#l00158">FULL_BLOCK_FAKE_ADDR</a>, <a class="el" href="bmfunc_8h_source.html#l04007">bm::gap_add_to_bitset()</a>, <a class="el" href="bmconst_8h_source.html#l00082">bm::gap_equiv_len</a>, <a class="el" href="bmfunc_8h_source.html#l06623">bm::gap_operation_or()</a>, <a class="el" href="bmfunc_8h_source.html#l06038">bm::is_bits_one()</a>, and <a class="el" href="bmdef_8h_source.html#l00162">IS_FULL_BLOCK</a>.</p>

</div>
</div>
<a id="a3d483b58f9404eb755ded14de9e4df26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d483b58f9404eb755ded14de9e4df26">&#9670;&nbsp;</a></span>combine_operation_block_or() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::combine_operation_block_or </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *&#160;</td>
          <td class="paramname"><em>arg_blk1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *&#160;</td>
          <td class="paramname"><em>arg_blk2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if block optimization may be needed </dd></dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l06655">6655</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmfunc_8h_source.html#l07703">bm::bit_block_or_2way()</a>, <a class="el" href="bmdef_8h_source.html#l00191">BM_IS_GAP</a>, <a class="el" href="bmdef_8h_source.html#l00189">BMGAP_PTR</a>, <a class="el" href="bmdef_8h_source.html#l00158">FULL_BLOCK_FAKE_ADDR</a>, <a class="el" href="bmfunc_8h_source.html#l04007">bm::gap_add_to_bitset()</a>, <a class="el" href="bmconst_8h_source.html#l00082">bm::gap_equiv_len</a>, and <a class="el" href="bmfunc_8h_source.html#l06623">bm::gap_operation_or()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l05689">bm::bvector&lt; Alloc &gt;::bit_or()</a>, <a class="el" href="bm_8h_source.html#l06895">bm::bvector&lt; Alloc &gt;::combine_operation_block_and_or()</a>, and <a class="el" href="bm_8h_source.html#l05599">bm::bvector&lt; Alloc &gt;::merge()</a>.</p>

</div>
</div>
<a id="a765a98d68667863ed6cc4d3e58cd5011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a765a98d68667863ed6cc4d3e58cd5011">&#9670;&nbsp;</a></span>combine_operation_block_sub() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::combine_operation_block_sub </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *&#160;</td>
          <td class="paramname"><em>blk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *&#160;</td>
          <td class="paramname"><em>arg_blk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l07356">7356</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmfunc_8h_source.html#l08193">bm::bit_andnot_arr_ffmask()</a>, <a class="el" href="bmfunc_8h_source.html#l01513">bm::bit_is_all_zero()</a>, <a class="el" href="bmfunc_8h_source.html#l08099">bm::bit_operation_sub()</a>, <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>, <a class="el" href="bmdef_8h_source.html#l00191">BM_IS_GAP</a>, <a class="el" href="bmdef_8h_source.html#l00189">BMGAP_PTR</a>, <a class="el" href="bm_8h_source.html#l01574">bm::bvector&lt; Alloc &gt;::empty()</a>, <a class="el" href="bmfunc_8h_source.html#l04457">bm::gap_convert_to_bitset_smart()</a>, <a class="el" href="bmconst_8h_source.html#l00082">bm::gap_equiv_len</a>, <a class="el" href="bmconst_8h_source.html#l00081">bm::gap_max_bits</a>, <a class="el" href="bmfunc_8h_source.html#l06669">bm::gap_operation_sub()</a>, <a class="el" href="bmfunc_8h_source.html#l03891">bm::gap_sub_to_bitset()</a>, <a class="el" href="bmdef_8h_source.html#l00162">IS_FULL_BLOCK</a>, and <a class="el" href="bmdef_8h_source.html#l00161">IS_VALID_ADDR</a>.</p>

</div>
</div>
<a id="a89e9407fa3296087a05298607a060b68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89e9407fa3296087a05298607a060b68">&#9670;&nbsp;</a></span>combine_operation_block_sub() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::combine_operation_block_sub </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *&#160;</td>
          <td class="paramname"><em>arg_blk1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *&#160;</td>
          <td class="paramname"><em>arg_blk2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l06995">6995</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmfunc_8h_source.html#l07936">bm::bit_block_sub()</a>, <a class="el" href="bmfunc_8h_source.html#l08032">bm::bit_block_sub_2way()</a>, <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>, <a class="el" href="bmdef_8h_source.html#l00191">BM_IS_GAP</a>, <a class="el" href="bmdef_8h_source.html#l00189">BMGAP_PTR</a>, <a class="el" href="bmdef_8h_source.html#l00158">FULL_BLOCK_FAKE_ADDR</a>, <a class="el" href="bmdef_8h_source.html#l00157">FULL_BLOCK_REAL_ADDR</a>, <a class="el" href="bmfunc_8h_source.html#l04432">bm::gap_convert_to_bitset()</a>, <a class="el" href="bmconst_8h_source.html#l00082">bm::gap_equiv_len</a>, <a class="el" href="bmfunc_8h_source.html#l06669">bm::gap_operation_sub()</a>, and <a class="el" href="bmfunc_8h_source.html#l03891">bm::gap_sub_to_bitset()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l06113">bm::bvector&lt; Alloc &gt;::bit_sub()</a>.</p>

</div>
</div>
<a id="aa74f75c8922a261ba5f2992d4c91f392"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa74f75c8922a261ba5f2992d4c91f392">&#9670;&nbsp;</a></span>combine_operation_block_xor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::combine_operation_block_xor </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *&#160;</td>
          <td class="paramname"><em>blk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *&#160;</td>
          <td class="paramname"><em>arg_blk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l07148">7148</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmfunc_8h_source.html#l06734">bm::bit_block_copy()</a>, <a class="el" href="bmfunc_8h_source.html#l04413">bm::bit_block_set()</a>, <a class="el" href="bmfunc_8h_source.html#l08157">bm::bit_block_xor()</a>, <a class="el" href="bmfunc_8h_source.html#l06014">bm::bit_invert()</a>, <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>, <a class="el" href="bmdef_8h_source.html#l00191">BM_IS_GAP</a>, <a class="el" href="bmdef_8h_source.html#l00189">BMGAP_PTR</a>, <a class="el" href="bmdef_8h_source.html#l00158">FULL_BLOCK_FAKE_ADDR</a>, <a class="el" href="bmconst_8h_source.html#l00082">bm::gap_equiv_len</a>, <a class="el" href="bmfunc_8h_source.html#l04577">bm::gap_invert()</a>, <a class="el" href="bmfunc_8h_source.html#l06542">bm::gap_operation_xor()</a>, <a class="el" href="bmfunc_8h_source.html#l03979">bm::gap_xor_to_bitset()</a>, and <a class="el" href="bmdef_8h_source.html#l00162">IS_FULL_BLOCK</a>.</p>

</div>
</div>
<a id="a9024201b96bf25e4b9b6f9693bc4afdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9024201b96bf25e4b9b6f9693bc4afdb">&#9670;&nbsp;</a></span>combine_operation_block_xor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::combine_operation_block_xor </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *&#160;</td>
          <td class="paramname"><em>arg_blk1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *&#160;</td>
          <td class="paramname"><em>arg_blk2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l06728">6728</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmfunc_8h_source.html#l07742">bm::bit_block_xor_2way()</a>, <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>, <a class="el" href="bmdef_8h_source.html#l00191">BM_IS_GAP</a>, <a class="el" href="bmdef_8h_source.html#l00189">BMGAP_PTR</a>, <a class="el" href="bmdef_8h_source.html#l00158">FULL_BLOCK_FAKE_ADDR</a>, <a class="el" href="bmconst_8h_source.html#l00082">bm::gap_equiv_len</a>, <a class="el" href="bmfunc_8h_source.html#l06542">bm::gap_operation_xor()</a>, <a class="el" href="bmfunc_8h_source.html#l03979">bm::gap_xor_to_bitset()</a>, and <a class="el" href="bmdef_8h_source.html#l00162">IS_FULL_BLOCK</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l05788">bm::bvector&lt; Alloc &gt;::bit_xor()</a>.</p>

</div>
</div>
<a id="ac1084ec5fad8c1faf50d31a182dc4287"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1084ec5fad8c1faf50d31a182dc4287">&#9670;&nbsp;</a></span>combine_operation_or()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::combine_operation_or </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bvect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>perform a set-algebra operation OR </p>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l06210">6210</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmavx2_8h_source.html#l01616">bm::avx2_test_all_eq_wave2()</a>, <a class="el" href="bm_8h_source.html#l06202">BM_OR_OP</a>, <a class="el" href="bmdef_8h_source.html#l00158">FULL_BLOCK_FAKE_ADDR</a>, <a class="el" href="bmconst_8h_source.html#l00095">bm::set_sub_array_size</a>, and <a class="el" href="bmsse4_8h_source.html#l00695">bm::sse42_test_all_eq_wave2()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l01802">bm::bvector&lt; Alloc &gt;::bit_or()</a>.</p>

</div>
</div>
<a id="acc454e79b5261f7c4859cac74aa81832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc454e79b5261f7c4859cac74aa81832">&#9670;&nbsp;</a></span>combine_operation_sub()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::combine_operation_sub </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bvect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>perform a set-algebra operation MINUS (AND NOT) </p>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l06469">6469</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmavx2_8h_source.html#l01592">bm::avx2_test_all_zero_wave()</a>, <a class="el" href="bm_8h_source.html#l06463">BM_SUB_OP</a>, <a class="el" href="bmdef_8h_source.html#l00158">FULL_BLOCK_FAKE_ADDR</a>, <a class="el" href="bmconst_8h_source.html#l00095">bm::set_sub_array_size</a>, and <a class="el" href="bmsse4_8h_source.html#l00671">bm::sse42_test_all_zero_wave()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l01837">bm::bvector&lt; Alloc &gt;::bit_sub()</a>.</p>

</div>
</div>
<a id="a1c91224fa77538f5bf407547ef030c53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c91224fa77538f5bf407547ef030c53">&#9670;&nbsp;</a></span>combine_operation_with_block() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::combine_operation_with_block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#ac11e61368363493754cbe97b69a1ca71">block_idx_type</a>&#160;</td>
          <td class="paramname"><em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>gap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *&#160;</td>
          <td class="paramname"><em>blk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *&#160;</td>
          <td class="paramname"><em>arg_blk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>arg_gap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bvector.html#ga42405343976ec931388381cea4092bf1">bm::operation</a>&#160;</td>
          <td class="paramname"><em>opcode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l07437">7437</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmconst_8h_source.html#l00131">bm::all_bits_mask</a>, <a class="el" href="bmfunc_8h_source.html#l08193">bm::bit_andnot_arr_ffmask()</a>, <a class="el" href="bmfunc_8h_source.html#l06734">bm::bit_block_copy()</a>, <a class="el" href="bmfunc_8h_source.html#l07409">bm::bit_operation_and()</a>, <a class="el" href="bmfunc_8h_source.html#l07876">bm::bit_operation_or()</a>, <a class="el" href="bmfunc_8h_source.html#l08099">bm::bit_operation_sub()</a>, <a class="el" href="bmfunc_8h_source.html#l08228">bm::bit_operation_xor()</a>, <a class="el" href="bmconst_8h_source.html#l00191">bm::BM_AND</a>, <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>, <a class="el" href="bmconst_8h_source.html#l00192">bm::BM_OR</a>, <a class="el" href="bmconst_8h_source.html#l00193">bm::BM_SUB</a>, <a class="el" href="bmconst_8h_source.html#l00194">bm::BM_XOR</a>, <a class="el" href="bmdef_8h_source.html#l00189">BMGAP_PTR</a>, <a class="el" href="bmfunc_8h_source.html#l04457">bm::gap_convert_to_bitset_smart()</a>, <a class="el" href="bmconst_8h_source.html#l00082">bm::gap_equiv_len</a>, <a class="el" href="bmfunc_8h_source.html#l01540">bm::gap_is_all_zero()</a>, <a class="el" href="bmconst_8h_source.html#l00081">bm::gap_max_bits</a>, <a class="el" href="bmfunc_8h_source.html#l09238">bm::operation_functions&lt; T &gt;::gap_op_to_bit()</a>, <a class="el" href="bmfunc_8h_source.html#l09244">bm::operation_functions&lt; T &gt;::gap_operation()</a>, <a class="el" href="bmdef_8h_source.html#l00162">IS_FULL_BLOCK</a>, <a class="el" href="bmdef_8h_source.html#l00161">IS_VALID_ADDR</a>, <a class="el" href="bmconst_8h_source.html#l00055">bm::set_block_size</a>, and <a class="el" href="bmavx2_8h_source.html#l03200">VECT_XOR_ARR_2_MASK</a>.</p>

</div>
</div>
<a id="ae07a3598a5f3a5dace950cc48c5e1369"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae07a3598a5f3a5dace950cc48c5e1369">&#9670;&nbsp;</a></span>combine_operation_with_block() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::combine_operation_with_block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#ac11e61368363493754cbe97b69a1ca71">block_idx_type</a>&#160;</td>
          <td class="paramname"><em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *&#160;</td>
          <td class="paramname"><em>arg_blk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>arg_gap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bvector.html#ga42405343976ec931388381cea4092bf1">bm::operation</a>&#160;</td>
          <td class="paramname"><em>opcode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l05672">5672</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00191">BM_IS_GAP</a>, <a class="el" href="bm_8h_source.html#l05672">bm::bvector&lt; Alloc &gt;::combine_operation_with_block()</a>, and <a class="el" href="bmfunc_8h_source.html#l00163">bm::get_block_coord()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l06533">bm::bvector&lt; Alloc &gt;::combine_operation()</a>, and <a class="el" href="bm_8h_source.html#l05672">bm::bvector&lt; Alloc &gt;::combine_operation_with_block()</a>.</p>

</div>
</div>
<a id="a311f59a89c8b75a252fc7e55400ea2e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a311f59a89c8b75a252fc7e55400ea2e4">&#9670;&nbsp;</a></span>combine_operation_xor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::combine_operation_xor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bvect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>perform a set-algebra operation XOR </p>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l06282">6282</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmavx2_8h_source.html#l01603">bm::avx2_test_all_zero_wave2()</a>, <a class="el" href="bm_8h_source.html#l06275">BM_XOR_OP</a>, <a class="el" href="bmdef_8h_source.html#l00158">FULL_BLOCK_FAKE_ADDR</a>, <a class="el" href="bmdef_8h_source.html#l00159">FULL_SUB_BLOCK_REAL_ADDR</a>, <a class="el" href="bmconst_8h_source.html#l00095">bm::set_sub_array_size</a>, and <a class="el" href="bmsse4_8h_source.html#l00682">bm::sse42_test_all_zero_wave2()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l01826">bm::bvector&lt; Alloc &gt;::bit_xor()</a>.</p>

</div>
</div>
<a id="acfb4e0f923e55057db5ed518853fbecf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfb4e0f923e55057db5ed518853fbecf">&#9670;&nbsp;</a></span>compare()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bvect</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lexicographical comparison with a bitvector. </p>
<p >Function compares current bitvector with the provided argument bit by bit and returns -1 if this bitvector less than the argument, 1 - greater, 0 - equal</p>
<dl class="section return"><dt>Returns</dt><dd>0 if this == arg, -1 if this &lt; arg, 1 if this &gt; arg </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbm_1_1bvector.html#a8554bf7b4d276acc00cd31c87cc544ec" title="Find index of first bit different between this and the agr vector.">find_first_mismatch</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="sample4_8cpp-example.html#a24">sample4.cpp</a>, <a class="el" href="svsample06_8cpp-example.html#a31">svsample06.cpp</a>, <a class="el" href="xsample01_8cpp-example.html#a55">xsample01.cpp</a>, <a class="el" href="xsample03_8cpp-example.html#a42">xsample03.cpp</a>, <a class="el" href="xsample04a_8cpp-example.html#a28">xsample04a.cpp</a>, and <a class="el" href="xsample05_8cpp-example.html#a34">xsample05.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l03734">3734</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmfunc_8h_source.html#l01513">bm::bit_is_all_zero()</a>, <a class="el" href="bmfunc_8h_source.html#l04657">bm::bitcmp()</a>, <a class="el" href="bm_8h_source.html#l00047">BM_DECLARE_TEMP_BLOCK</a>, <a class="el" href="bmdef_8h_source.html#l00191">BM_IS_GAP</a>, <a class="el" href="bmdef_8h_source.html#l00189">BMGAP_PTR</a>, <a class="el" href="bmdef_8h_source.html#l00158">FULL_BLOCK_FAKE_ADDR</a>, <a class="el" href="bmdef_8h_source.html#l00157">FULL_BLOCK_REAL_ADDR</a>, <a class="el" href="bmfunc_8h_source.html#l04432">bm::gap_convert_to_bitset()</a>, <a class="el" href="bmfunc_8h_source.html#l01540">bm::gap_is_all_zero()</a>, <a class="el" href="bmfunc_8h_source.html#l02846">bm::gapcmp()</a>, <a class="el" href="bmconst_8h_source.html#l00132">bm::set_block_size_op</a>, and <a class="el" href="bmconst_8h_source.html#l00095">bm::set_sub_array_size</a>.</p>

<p class="reference">Referenced by <a class="el" href="xsample01_8cpp_source.html#l00305">convert_bv2bvs()</a>, <a class="el" href="xsample04a_8cpp_source.html#l00398">fingerprint_compare()</a>, <a class="el" href="sample2_8cpp_source.html#l00055">main()</a>, <a class="el" href="bm_8h_source.html#l01045">bm::bvector&lt; Alloc &gt;::operator&lt;()</a>, <a class="el" href="bm_8h_source.html#l01046">bm::bvector&lt; Alloc &gt;::operator&lt;=()</a>, <a class="el" href="bm_8h_source.html#l01047">bm::bvector&lt; Alloc &gt;::operator&gt;()</a>, <a class="el" href="bm_8h_source.html#l01048">bm::bvector&lt; Alloc &gt;::operator&gt;=()</a>, and <a class="el" href="xsample03_8cpp_source.html#l00349">run_benchmark()</a>.</p>

</div>
</div>
<a id="ac1bc1b5c4ee46ac788a1718bf26b303e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1bc1b5c4ee46ac788a1718bf26b303e">&#9670;&nbsp;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bvect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bvector.html#gacfee7c9af0d11e534813a7429ffb1a31">bm::finalization</a>&#160;</td>
          <td class="paramname"><em>is_final</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy bvector from the argument bvector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bvect</td><td>- bit-vector to copy from </td></tr>
    <tr><td class="paramname">is_final</td><td>- BM_READONLY - copies as immutable, BM_READWRITE - copies as mutable even if the argument bvect is read-only vector, BM_UNDEFINED - follow the argument type as is </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l02301">2301</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>, <a class="el" href="bmconst_8h_source.html#l00157">bm::BM_READONLY</a>, <a class="el" href="bmconst_8h_source.html#l00158">bm::BM_READWRITE</a>, <a class="el" href="bmconst_8h_source.html#l00156">bm::BM_UNDEFINED</a>, <a class="el" href="bm_8h_source.html#l01080">bm::bvector&lt; Alloc &gt;::is_ro()</a>, <a class="el" href="bm_8h_source.html#l02461">bm::bvector&lt; Alloc &gt;::resize()</a>, and <a class="el" href="bm_8h_source.html#l01312">bm::bvector&lt; Alloc &gt;::size()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l00950">bm::bvector&lt; Alloc &gt;::operator=()</a>.</p>

</div>
</div>
<a id="ab7978570375ae288a6893d7b4d673769"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7978570375ae288a6893d7b4d673769">&#9670;&nbsp;</a></span>copy_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::copy_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bvect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy all bits in the specified closed interval [left,right]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bvect</td><td>- source bit-vector </td></tr>
    <tr><td class="paramname">left</td><td>- interval start </td></tr>
    <tr><td class="paramname">right</td><td>- interval end (closed interval) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="sample22_8cpp-example.html#a7">sample22.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l07764">7764</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bm_8h_source.html#l04139">bm::bvector&lt; Alloc &gt;::clear()</a>, <a class="el" href="bm_8h_source.html#l07809">bm::bvector&lt; Alloc &gt;::copy_range_no_check()</a>, and <a class="el" href="bmutil_8h_source.html#l00536">bm::xor_swap()</a>.</p>

<p class="reference">Referenced by <a class="el" href="sample22_8cpp_source.html#l00072">main()</a>.</p>

</div>
</div>
<a id="abf4b2b4af70396189467408e564791ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf4b2b4af70396189467408e564791ee">&#9670;&nbsp;</a></span>copy_range_no_check()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::copy_range_no_check </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bvect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l07809">7809</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>, <a class="el" href="bmdef_8h_source.html#l00338">BM_ASSERT_THROW</a>, <a class="el" href="bm_8h_source.html#l04694">bm::bvector&lt; Alloc &gt;::find_reverse()</a>, <a class="el" href="bmconst_8h_source.html#l00081">bm::gap_max_bits</a>, <a class="el" href="bmconst_8h_source.html#l00109">bm::id_max</a>, and <a class="el" href="bmconst_8h_source.html#l00056">bm::set_block_shift</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l00911">bm::bvector&lt; Alloc &gt;::bvector()</a>, and <a class="el" href="bm_8h_source.html#l07764">bm::bvector&lt; Alloc &gt;::copy_range()</a>.</p>

</div>
</div>
<a id="a3009ba9b116f13f4933a48641f3a695d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3009ba9b116f13f4933a48641f3a695d">&#9670;&nbsp;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt;::<a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::count</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>population count (count of ON bits) </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbm_1_1bvector.html#a99395aaa8ab689455054bda9b261de60" title="Returns count of 1 bits in the given range [left..right] Uses rank-select index to accelerate the sea...">count_range</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Total number of bits ON </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="bvsample01_64_8cpp-example.html#a4">bvsample01_64.cpp</a>, <a class="el" href="sample1_8cpp-example.html#a2">sample1.cpp</a>, <a class="el" href="sample11_8cpp-example.html#a17">sample11.cpp</a>, <a class="el" href="sample14_8cpp-example.html#a6">sample14.cpp</a>, <a class="el" href="sample15_8cpp-example.html#a5">sample15.cpp</a>, <a class="el" href="sample18_8cpp-example.html#a4">sample18.cpp</a>, <a class="el" href="sample18a_8cpp-example.html#a3">sample18a.cpp</a>, <a class="el" href="sample19_8cpp-example.html#a2">sample19.cpp</a>, <a class="el" href="sample3_8cpp-example.html#a7">sample3.cpp</a>, <a class="el" href="sample4_8cpp-example.html#a7">sample4.cpp</a>, <a class="el" href="sample8_8cpp-example.html#a7">sample8.cpp</a>, <a class="el" href="sample9_8cpp-example.html#a4">sample9.cpp</a>, <a class="el" href="strsvsample06_8cpp-example.html#a24">strsvsample06.cpp</a>, <a class="el" href="strsvsample07_8cpp-example.html#a19">strsvsample07.cpp</a>, <a class="el" href="svsample05_8cpp-example.html#a9">svsample05.cpp</a>, <a class="el" href="svsample06_8cpp-example.html#a18">svsample06.cpp</a>, <a class="el" href="xsample01_8cpp-example.html#a57">xsample01.cpp</a>, <a class="el" href="xsample05_8cpp-example.html#a35">xsample05.cpp</a>, <a class="el" href="xsample07_8cpp-example.html#a66">xsample07.cpp</a>, <a class="el" href="xsample07a_8cpp-example.html#a93">xsample07a.cpp</a>, and <a class="el" href="xsample09_8cpp-example.html#a37">xsample09.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l02399">2399</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>, <a class="el" href="bmfunc_8h_source.html#l01390">bm::find_not_null_ptr()</a>, <a class="el" href="bmdef_8h_source.html#l00158">FULL_BLOCK_FAKE_ADDR</a>, <a class="el" href="bmconst_8h_source.html#l00081">bm::gap_max_bits</a>, and <a class="el" href="bmconst_8h_source.html#l00095">bm::set_sub_array_size</a>.</p>

<p class="reference">Referenced by <a class="el" href="sample11_8cpp_source.html#l00115">bv_count_test()</a>, <a class="el" href="xsample07a_8cpp_source.html#l00807">CSeqClusters::clear_empty_groups()</a>, <a class="el" href="xsample07a_8cpp_source.html#l00890">compute_and_sim_row()</a>, <a class="el" href="xsample07a_8cpp_source.html#l00847">CSeqClusters::compute_avg_count()</a>, <a class="el" href="xsample07a_8cpp_source.html#l01102">compute_group()</a>, <a class="el" href="xsample07a_8cpp_source.html#l01420">compute_jaccard_clusters()</a>, <a class="el" href="xsample01_8cpp_source.html#l00367">convert_bv2vect()</a>, <a class="el" href="xsample07a_8cpp_source.html#l00994">CSeqClusters::elect_leaders()</a>, <a class="el" href="sample1_8cpp_source.html#l00040">main()</a>, <a class="el" href="sample11_8cpp_source.html#l00098">pre_heat()</a>, <a class="el" href="svsample05_8cpp_source.html#l00075">print_bvector()</a>, <a class="el" href="sample3_8cpp_source.html#l00061">print_statistics()</a>, <a class="el" href="xsample07a_8cpp_source.html#l01087">CSeqClusters::print_summary()</a>, <a class="el" href="bm_8h_source.html#l01489">bm::bvector&lt; Alloc &gt;::recalc_count()</a>, <a class="el" href="xsample05_8cpp_source.html#l00318">run_benchmark()</a>, and <a class="el" href="sample4_8cpp_source.html#l00078">serialize_bvector()</a>.</p>

</div>
</div>
<a id="ac9d8a2e8d82811acaa152d1378719ff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9d8a2e8d82811acaa152d1378719ff5">&#9670;&nbsp;</a></span>count_blocks()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt;::<a class="el" href="classbm_1_1bvector.html#ac11e61368363493754cbe97b69a1ca71">block_idx_type</a> <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::count_blocks </td>
          <td>(</td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>arr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes bitcount values for all bvector blocks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>- pointer on array of block bit counts </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index of the last block counted. This number +1 gives you number of arr elements initialized during the function call. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l02635">2635</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmfunc_8h_source.html#l01859">bm::for_each_nzblock()</a>.</p>

</div>
</div>
<a id="a81785984718d65787b5c3f32216d9e7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81785984718d65787b5c3f32216d9e7d">&#9670;&nbsp;</a></span>count_range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt;::<a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::count_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns count of 1 bits in the given range [left..right]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>- index of first bit start counting from </td></tr>
    <tr><td class="paramname">right</td><td>- index of last bit</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>population count in the diapason </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbm_1_1bvector.html#acaf5944b67f0b8f2a767732753e08b0d">count_range_no_check</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l03233">3233</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>, <a class="el" href="bm_8h_source.html#l03249">bm::bvector&lt; Alloc &gt;::count_range_no_check()</a>, <a class="el" href="bmconst_8h_source.html#l00109">bm::id_max</a>, and <a class="el" href="bmutil_8h_source.html#l00536">bm::xor_swap()</a>.</p>

</div>
</div>
<a id="a99395aaa8ab689455054bda9b261de60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99395aaa8ab689455054bda9b261de60">&#9670;&nbsp;</a></span>count_range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt;::<a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::count_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html#ac9ed62250af37ade811aaf20b7a8d9a2">rs_index_type</a> &amp;&#160;</td>
          <td class="paramname"><em>rs_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns count of 1 bits in the given range [left..right] Uses rank-select index to accelerate the search. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>- index of first bit start counting from </td></tr>
    <tr><td class="paramname">right</td><td>- index of last bit </td></tr>
    <tr><td class="paramname">rs_idx</td><td>- block count structure to accelerate search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbm_1_1bvector.html#adfb63744a9d6039d9e8daa38cf21e3c6" title="compute running total of all blocks in bit vector (rank-select index)">build_rs_index</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>population count in the diapason </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="sample11_8cpp-example.html#a21">sample11.cpp</a>, and <a class="el" href="xsample07a_8cpp-example.html#a111">xsample07a.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l03507">3507</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00338">BM_ASSERT_THROW</a>, <a class="el" href="bm_8h_source.html#l03249">bm::bvector&lt; Alloc &gt;::count_range_no_check()</a>, <a class="el" href="bmconst_8h_source.html#l00109">bm::id_max</a>, and <a class="el" href="bmutil_8h_source.html#l00536">bm::xor_swap()</a>.</p>

<p class="reference">Referenced by <a class="el" href="sample11_8cpp_source.html#l00133">bv_count_range()</a>, <a class="el" href="sample11_8cpp_source.html#l00154">bv_count_range_acc()</a>, and <a class="el" href="xsample07a_8cpp_source.html#l00994">CSeqClusters::elect_leaders()</a>.</p>

</div>
</div>
<a id="acaf5944b67f0b8f2a767732753e08b0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaf5944b67f0b8f2a767732753e08b0d">&#9670;&nbsp;</a></span>count_range_no_check() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt;::<a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::count_range_no_check </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns count of 1 bits in the given range [left..right] Function expects that caller guarantees that left &lt; right</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbm_1_1bvector.html#a99395aaa8ab689455054bda9b261de60" title="Returns count of 1 bits in the given range [left..right] Uses rank-select index to accelerate the sea...">count_range</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l03249">3249</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmfunc_8h_source.html#l05347">bm::bit_block_calc_count_range()</a>, <a class="el" href="bmconst_8h_source.html#l00114">bm::bits_in_block</a>, <a class="el" href="bmdef_8h_source.html#l00191">BM_IS_GAP</a>, <a class="el" href="bmdef_8h_source.html#l00189">BMGAP_PTR</a>, <a class="el" href="bmfunc_8h_source.html#l01802">bm::for_each_nzblock_range()</a>, <a class="el" href="bmfunc_8h_source.html#l02344">bm::gap_bit_count_range()</a>, <a class="el" href="bmfunc_8h_source.html#l02694">bm::gap_bit_count_to()</a>, <a class="el" href="bmfunc_8h_source.html#l00163">bm::get_block_coord()</a>, <a class="el" href="bmconst_8h_source.html#l00057">bm::set_block_mask</a>, and <a class="el" href="bmconst_8h_source.html#l00056">bm::set_block_shift</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l03233">bm::bvector&lt; Alloc &gt;::count_range()</a>.</p>

</div>
</div>
<a id="a75aa9c01449453121996398c8bc54ec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75aa9c01449453121996398c8bc54ec7">&#9670;&nbsp;</a></span>count_range_no_check() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt;::<a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::count_range_no_check </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html#ac9ed62250af37ade811aaf20b7a8d9a2">rs_index_type</a> &amp;&#160;</td>
          <td class="paramname"><em>rs_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns count of 1 bits in the given range [left..right] Function expects that caller guarantees that left &lt; right</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbm_1_1bvector.html#a99395aaa8ab689455054bda9b261de60" title="Returns count of 1 bits in the given range [left..right] Uses rank-select index to accelerate the sea...">count_range</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l03521">3521</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>, <a class="el" href="bm_8h_source.html#l03079">bm::bvector&lt; Alloc &gt;::count_to()</a>, and <a class="el" href="bm_8h_source.html#l01514">bm::bvector&lt; Alloc &gt;::test()</a>.</p>

</div>
</div>
<a id="ad3e0e88f17cc86b58e006186955c461b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3e0e88f17cc86b58e006186955c461b">&#9670;&nbsp;</a></span>count_to()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt;::<a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::count_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html#ac9ed62250af37ade811aaf20b7a8d9a2">rs_index_type</a> &amp;&#160;</td>
          <td class="paramname"><em>rs_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns count of 1 bits (population) in [0..right] range. </p>
<p >This operation is also known as rank of bit N.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>- index of bit to rank </td></tr>
    <tr><td class="paramname">rs_idx</td><td>- rank-select to accelerate search should be prepared using build_rs_index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>population count in the range [0..n] </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbm_1_1bvector.html#adfb63744a9d6039d9e8daa38cf21e3c6" title="compute running total of all blocks in bit vector (rank-select index)">build_rs_index</a> </dd>
<dd>
<a class="el" href="classbm_1_1bvector.html#a649167f4b128d053d6312a3a00114403" title="popcount in [0..right] range if test(right) == true">count_to_test</a>, <a class="el" href="classbm_1_1bvector.html#a7ded07c26c000250baf5215c29c3b602" title="select bit-vector position for the specified rank(bitcount)">select</a>, <a class="el" href="classbm_1_1bvector.html#a65b175606ea472e33b9b6af1f7b04ee7" title="Returns rank of specified bit position (same as count_to())">rank</a>, <a class="el" href="classbm_1_1bvector.html#abc7ead9fd4044f190d45946762a1011a" title="Returns rank corrceted by the requested border value (as -1)">rank_corrected</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="sample11_8cpp-example.html#a25">sample11.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l03079">3079</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>, <a class="el" href="bmdef_8h_source.html#l00191">BM_IS_GAP</a>, <a class="el" href="bmdef_8h_source.html#l00189">BMGAP_PTR</a>, <a class="el" href="bmdef_8h_source.html#l00158">FULL_BLOCK_FAKE_ADDR</a>, <a class="el" href="bmfunc_8h_source.html#l00163">bm::get_block_coord()</a>, <a class="el" href="bmconst_8h_source.html#l00109">bm::id_max</a>, <a class="el" href="bmconst_8h_source.html#l00057">bm::set_block_mask</a>, and <a class="el" href="bmconst_8h_source.html#l00056">bm::set_block_shift</a>.</p>

<p class="reference">Referenced by <a class="el" href="sample11_8cpp_source.html#l00180">bv_count_to_acc()</a>, <a class="el" href="sample11_8cpp_source.html#l00206">bv_count_to_range_acc()</a>, <a class="el" href="bm_8h_source.html#l03521">bm::bvector&lt; Alloc &gt;::count_range_no_check()</a>, and <a class="el" href="bm_8h_source.html#l01445">bm::bvector&lt; Alloc &gt;::rank()</a>.</p>

</div>
</div>
<a id="a649167f4b128d053d6312a3a00114403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a649167f4b128d053d6312a3a00114403">&#9670;&nbsp;</a></span>count_to_test()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt;::<a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::count_to_test </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html#ac9ed62250af37ade811aaf20b7a8d9a2">rs_index_type</a> &amp;&#160;</td>
          <td class="paramname"><em>rs_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>popcount in [0..right] range if test(right) == true </p>
<p >This is conditional rank operation, which is faster than <a class="el" href="classbm_1_1bvector.html#a16d902c3df4aa6aa88d8e137af4a4b9b" title="returns true if bit n is set and false is bit n is 0.">test()</a> plus <a class="el" href="classbm_1_1bvector.html#ad3e0e88f17cc86b58e006186955c461b" title="Returns count of 1 bits (population) in [0..right] range.">count_to()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>- index of bit to test and rank </td></tr>
    <tr><td class="paramname">rs_idx</td><td>- rank-select index (block count structure to accelerate search) should be prepared using <a class="el" href="classbm_1_1bvector.html#adfb63744a9d6039d9e8daa38cf21e3c6" title="compute running total of all blocks in bit vector (rank-select index)">build_rs_index()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>population count in the diapason or 0 if right bit test failed</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbm_1_1bvector.html#adfb63744a9d6039d9e8daa38cf21e3c6" title="compute running total of all blocks in bit vector (rank-select index)">build_rs_index</a> </dd>
<dd>
<a class="el" href="classbm_1_1bvector.html#ad3e0e88f17cc86b58e006186955c461b" title="Returns count of 1 bits (population) in [0..right] range.">count_to</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l03132">3132</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmfunc_8h_source.html#l05433">bm::bit_block_calc_count_to()</a>, <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>, <a class="el" href="bmdef_8h_source.html#l00191">BM_IS_GAP</a>, <a class="el" href="bmdef_8h_source.html#l00189">BMGAP_PTR</a>, <a class="el" href="bmdef_8h_source.html#l00158">FULL_BLOCK_FAKE_ADDR</a>, <a class="el" href="bmfunc_8h_source.html#l02694">bm::gap_bit_count_to()</a>, <a class="el" href="bmfunc_8h_source.html#l00163">bm::get_block_coord()</a>, <a class="el" href="bmconst_8h_source.html#l00109">bm::id_max</a>, <a class="el" href="bmconst_8h_source.html#l00057">bm::set_block_mask</a>, <a class="el" href="bmconst_8h_source.html#l00056">bm::set_block_shift</a>, <a class="el" href="bmconst_8h_source.html#l00073">bm::set_word_mask</a>, and <a class="el" href="bmconst_8h_source.html#l00072">bm::set_word_shift</a>.</p>

</div>
</div>
<a id="a746b0a896ba6286d0b8fefeb69fa880b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a746b0a896ba6286d0b8fefeb69fa880b">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the set is empty (no bits are set, otherwise returns false) Please note that this is NOT a size check, it is an empty SET check (absense of 1s) </p>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01574">1574</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bm_8h_source.html#l02449">bm::bvector&lt; Alloc &gt;::any()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l07252">bm::bvector&lt; Alloc &gt;::combine_operation_block_and()</a>, and <a class="el" href="bm_8h_source.html#l07356">bm::bvector&lt; Alloc &gt;::combine_operation_block_sub()</a>.</p>

</div>
</div>
<a id="a937cd13482984f234a5d94cc638c22b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a937cd13482984f234a5d94cc638c22b5">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector_1_1enumerator.html">bvector::enumerator</a> <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns enumerator pointing on the next bit after the last. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="sample10_8cpp-example.html#a7">sample10.cpp</a>, <a class="el" href="sample12_8cpp-example.html#a20">sample12.cpp</a>, <a class="el" href="sample16_8cpp-example.html#a8">sample16.cpp</a>, <a class="el" href="sample22_8cpp-example.html#a9">sample22.cpp</a>, <a class="el" href="sample5_8cpp-example.html#a5">sample5.cpp</a>, <a class="el" href="sample7_8cpp-example.html#a5">sample7.cpp</a>, <a class="el" href="sample8_8cpp-example.html#a6">sample8.cpp</a>, and <a class="el" href="xsample08_8cpp-example.html#a27">xsample08.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01889">1889</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bm_8h_source.html#l00827">bm::bvector&lt; Alloc &gt;::enumerator</a>.</p>

<p class="reference">Referenced by <a class="el" href="sample12_8cpp_source.html#l00156">combine_or_test()</a>, <a class="el" href="sample5_8cpp_source.html#l00048">main()</a>, <a class="el" href="xsample01_8cpp_source.html#l00740">speed_test_sv_index()</a>, and <a class="el" href="xsample01_8cpp_source.html#l00678">speed_test_vect_index()</a>.</p>

</div>
</div>
<a id="a23a267a48a594836e6a2f1d08a4166f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23a267a48a594836e6a2f1d08a4166f3">&#9670;&nbsp;</a></span>equal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bvect</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equal comparison with an agr bit-vector. </p>
<dl class="section return"><dt>Returns</dt><dd>true if vectors are identical </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="bv3vlogic_8cpp-example.html#a21">bv3vlogic.cpp</a>, <a class="el" href="sample14_8cpp-example.html#a15">sample14.cpp</a>, <a class="el" href="sample22_8cpp-example.html#a14">sample22.cpp</a>, and <a class="el" href="strsvsample07_8cpp-example.html#a18">strsvsample07.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l02029">2029</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bm_8h_source.html#l03852">bm::bvector&lt; Alloc &gt;::find_first_mismatch()</a>.</p>

<p class="reference">Referenced by <a class="el" href="sample14_8cpp_source.html#l00058">main()</a>, <a class="el" href="bm_8h_source.html#l01050">bm::bvector&lt; Alloc &gt;::operator!=()</a>, <a class="el" href="bm_8h_source.html#l01049">bm::bvector&lt; Alloc &gt;::operator==()</a>, <a class="el" href="bv3vlogic_8cpp_source.html#l00209">Set3VL_AndDemo()</a>, and <a class="el" href="bv3vlogic_8cpp_source.html#l00249">Set3VL_ORDemo()</a>.</p>

</div>
</div>
<a id="ab20d0778a1d4885fc15bdf2126493349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab20d0778a1d4885fc15bdf2126493349">&#9670;&nbsp;</a></span>erase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase bit in the specified position All the vector content after erase position is shifted left. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>- index of the bit to insert </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l05429">5429</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmfunc_8h_source.html#l05791">bm::bit_block_erase()</a>, <a class="el" href="bmfunc_8h_source.html#l05768">bm::bit_block_shift_l1_unr()</a>, <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>, <a class="el" href="bmdef_8h_source.html#l00338">BM_ASSERT_THROW</a>, <a class="el" href="bmconst_8h_source.html#l00146">bm::BM_BIT</a>, <a class="el" href="bmdef_8h_source.html#l00191">BM_IS_GAP</a>, <a class="el" href="bmdef_8h_source.html#l00189">BMGAP_PTR</a>, <a class="el" href="bmfunc_8h_source.html#l01390">bm::find_not_null_ptr()</a>, <a class="el" href="bmdef_8h_source.html#l00158">FULL_BLOCK_FAKE_ADDR</a>, <a class="el" href="bmfunc_8h_source.html#l01540">bm::gap_is_all_zero()</a>, <a class="el" href="bmfunc_8h_source.html#l01598">bm::gap_limit()</a>, <a class="el" href="bmconst_8h_source.html#l00081">bm::gap_max_bits</a>, <a class="el" href="bmfunc_8h_source.html#l03513">bm::gap_shift_l1()</a>, <a class="el" href="bmfunc_8h_source.html#l00163">bm::get_block_coord()</a>, <a class="el" href="bmconst_8h_source.html#l00109">bm::id_max</a>, <a class="el" href="bmdef_8h_source.html#l00162">IS_FULL_BLOCK</a>, <a class="el" href="bm_8h_source.html#l01080">bm::bvector&lt; Alloc &gt;::is_ro()</a>, <a class="el" href="bmdef_8h_source.html#l00161">IS_VALID_ADDR</a>, <a class="el" href="bm_8h_source.html#l04426">bm::bvector&lt; Alloc &gt;::set_bit_no_check()</a>, <a class="el" href="bmconst_8h_source.html#l00057">bm::set_block_mask</a>, <a class="el" href="bmconst_8h_source.html#l00056">bm::set_block_shift</a>, <a class="el" href="bmconst_8h_source.html#l00055">bm::set_block_size</a>, <a class="el" href="bmconst_8h_source.html#l00095">bm::set_sub_array_size</a>, <a class="el" href="bmconst_8h_source.html#l00110">bm::set_top_array_size</a>, and <a class="el" href="bm_8h_source.html#l01514">bm::bvector&lt; Alloc &gt;::test()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l05215">bm::bvector&lt; Alloc &gt;::shift_left()</a>.</p>

</div>
</div>
<a id="ab4da9b61aca4523c7523136e2db68aa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4da9b61aca4523c7523136e2db68aa8">&#9670;&nbsp;</a></span>extract_next()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::extract_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td>
          <td class="paramname"><em>prev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the number of the next bit ON and sets it to 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prev</td><td>- Index of the previously found bit. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index of the next bit which is ON or 0 if not found. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbm_1_1bvector.html#a9ab6964e14405327936d183a11dcd455" title="find first 1 bit in vector. Function may return 0 and this requires an extra check if bit 0 is actual...">get_first</a>, <a class="el" href="classbm_1_1bvector.html#a3a09e493d97f5a66b6ec4e14e04cf118" title="Finds the number of the next bit ON.">get_next</a>, <a class="el" href="classbm_1_1bvector.html#ada8a47cb4a23e1402a7a6d728e35d50f" title="Finds last index of 1 bit.">find_reverse</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="sample12_8cpp-example.html#a27">sample12.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01631">1631</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bm_8h_source.html#l05191">bm::bvector&lt; Alloc &gt;::check_or_next_extract()</a>, and <a class="el" href="bmconst_8h_source.html#l00109">bm::id_max</a>.</p>

<p class="reference">Referenced by <a class="el" href="sample12_8cpp_source.html#l00189">main()</a>.</p>

</div>
</div>
<a id="a686fbdd5710a7ebeeb2aff8ea3d8f73c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a686fbdd5710a7ebeeb2aff8ea3d8f73c">&#9670;&nbsp;</a></span>fill_alloc_digest()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::fill_alloc_digest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bv_blocks</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate blocks digest vector (for diagnostics purposes) 1 is added if NB is a real, allocated block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bv_blocks</td><td>- [out] bvector of blocks statistics </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l04048">4048</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00158">FULL_BLOCK_FAKE_ADDR</a>, <a class="el" href="bm_8h_source.html#l02291">bm::bvector&lt; Alloc &gt;::init()</a>, <a class="el" href="bmdef_8h_source.html#l00161">IS_VALID_ADDR</a>, <a class="el" href="bm_8h_source.html#l04426">bm::bvector&lt; Alloc &gt;::set_bit_no_check()</a>, and <a class="el" href="bmconst_8h_source.html#l00095">bm::set_sub_array_size</a>.</p>

</div>
</div>
<a id="a08093c98bb6dfe27708357801aae7280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08093c98bb6dfe27708357801aae7280">&#9670;&nbsp;</a></span>find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds index of first 1 bit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>- [out] index of the found 1 bit </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if search returned result </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbm_1_1bvector.html#a9ab6964e14405327936d183a11dcd455" title="find first 1 bit in vector. Function may return 0 and this requires an extra check if bit 0 is actual...">get_first</a>, <a class="el" href="classbm_1_1bvector.html#a3a09e493d97f5a66b6ec4e14e04cf118" title="Finds the number of the next bit ON.">get_next</a>, <a class="el" href="classbm_1_1bvector.html#ab4da9b61aca4523c7523136e2db68aa8" title="Finds the number of the next bit ON and sets it to 0.">extract_next</a>, <a class="el" href="classbm_1_1bvector.html#ada8a47cb4a23e1402a7a6d728e35d50f" title="Finds last index of 1 bit.">find_reverse</a>, <a class="el" href="classbm_1_1bvector.html#a8554bf7b4d276acc00cd31c87cc544ec" title="Find index of first bit different between this and the agr vector.">find_first_mismatch</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="sample15_8cpp-example.html#a6">sample15.cpp</a>, <a class="el" href="sample2_8cpp-example.html#a6">sample2.cpp</a>, and <a class="el" href="xsample09_8cpp-example.html#a35">xsample09.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l04876">4876</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmfunc_8h_source.html#l08465">bm::bit_find_first()</a>, <a class="el" href="bmconst_8h_source.html#l00115">bm::bits_in_array</a>, <a class="el" href="bmdef_8h_source.html#l00191">BM_IS_GAP</a>, <a class="el" href="bmdef_8h_source.html#l00189">BMGAP_PTR</a>, <a class="el" href="bmdef_8h_source.html#l00158">FULL_BLOCK_FAKE_ADDR</a>, <a class="el" href="bmdef_8h_source.html#l00159">FULL_SUB_BLOCK_REAL_ADDR</a>, <a class="el" href="bmfunc_8h_source.html#l01661">bm::gap_find_first()</a>, <a class="el" href="bmconst_8h_source.html#l00081">bm::gap_max_bits</a>, and <a class="el" href="bmconst_8h_source.html#l00095">bm::set_sub_array_size</a>.</p>

<p class="reference">Referenced by <a class="el" href="xsample09_8cpp_source.html#l00319">access_bench3()</a>, <a class="el" href="bm_8h_source.html#l04679">bm::bvector&lt; Alloc &gt;::find()</a>, <a class="el" href="bm_8h_source.html#l03852">bm::bvector&lt; Alloc &gt;::find_first_mismatch()</a>, <a class="el" href="bm_8h_source.html#l04922">bm::bvector&lt; Alloc &gt;::find_range()</a>, and <a class="el" href="sample2_8cpp_source.html#l00055">main()</a>.</p>

</div>
</div>
<a id="afd50f443d3c80491293dad2b880a06de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd50f443d3c80491293dad2b880a06de">&#9670;&nbsp;</a></span>find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find index of 1 bit starting from position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>- position to start search from, please note that if bit at from position is set then it will be found, function uses closed interval [from... </td></tr>
    <tr><td class="paramname">pos</td><td>- [out] index of the found 1 bit </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if search returned result </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbm_1_1bvector.html#a9ab6964e14405327936d183a11dcd455" title="find first 1 bit in vector. Function may return 0 and this requires an extra check if bit 0 is actual...">get_first</a>, <a class="el" href="classbm_1_1bvector.html#a3a09e493d97f5a66b6ec4e14e04cf118" title="Finds the number of the next bit ON.">get_next</a>, <a class="el" href="classbm_1_1bvector.html#ab4da9b61aca4523c7523136e2db68aa8" title="Finds the number of the next bit ON and sets it to 0.">extract_next</a>, <a class="el" href="classbm_1_1bvector.html#ada8a47cb4a23e1402a7a6d728e35d50f" title="Finds last index of 1 bit.">find_reverse</a>, <a class="el" href="classbm_1_1bvector.html#a8554bf7b4d276acc00cd31c87cc544ec" title="Find index of first bit different between this and the agr vector.">find_first_mismatch</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l04679">4679</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bm_8h_source.html#l05107">bm::bvector&lt; Alloc &gt;::check_or_next()</a>, <a class="el" href="bm_8h_source.html#l04876">bm::bvector&lt; Alloc &gt;::find()</a>, and <a class="el" href="bmconst_8h_source.html#l00109">bm::id_max</a>.</p>

</div>
</div>
<a id="a8554bf7b4d276acc00cd31c87cc544ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8554bf7b4d276acc00cd31c87cc544ec">&#9670;&nbsp;</a></span>find_first_mismatch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::find_first_mismatch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bvect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td>
          <td class="paramname"><em>search_to</em> = <code><a class="el" href="namespacebm.html#a104b924a1df81542db2a6296fbf26a65">bm::id_max</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find index of first bit different between this and the agr vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bvect</td><td>- argumnet vector to compare with </td></tr>
    <tr><td class="paramname">pos</td><td>- [out] position of the first difference </td></tr>
    <tr><td class="paramname">search_to</td><td>- search limiter [0..to] to avoid overscan (default: unlimited to the vectors end)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if didfference found, false - both vectors are equivalent </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbm_1_1bvector.html#acfb4e0f923e55057db5ed518853fbecf" title="Lexicographical comparison with a bitvector.">compare</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="sample2_8cpp-example.html#a7">sample2.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l03852">3852</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00160">BLOCK_ADDR_SAN</a>, <a class="el" href="bmfunc_8h_source.html#l08944">bm::block_find_first_diff()</a>, <a class="el" href="bm_8h_source.html#l04876">bm::bvector&lt; Alloc &gt;::find()</a>, <a class="el" href="bmdef_8h_source.html#l00158">FULL_BLOCK_FAKE_ADDR</a>, <a class="el" href="bmdef_8h_source.html#l00157">FULL_BLOCK_REAL_ADDR</a>, <a class="el" href="bmconst_8h_source.html#l00081">bm::gap_max_bits</a>, <a class="el" href="bmfunc_8h_source.html#l00163">bm::get_block_coord()</a>, <a class="el" href="bmconst_8h_source.html#l00056">bm::set_block_shift</a>, and <a class="el" href="bmconst_8h_source.html#l00095">bm::set_sub_array_size</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l02029">bm::bvector&lt; Alloc &gt;::equal()</a>, and <a class="el" href="sample2_8cpp_source.html#l00055">main()</a>.</p>

</div>
</div>
<a id="a509670c79426e6388396c7720519f5c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a509670c79426e6388396c7720519f5c1">&#9670;&nbsp;</a></span>find_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::find_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> &amp;&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds dynamic range of bit-vector [first, last]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>- index of the first found 1 bit </td></tr>
    <tr><td class="paramname">last</td><td>- index of the last found 1 bit </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if search returned result </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbm_1_1bvector.html#a9ab6964e14405327936d183a11dcd455" title="find first 1 bit in vector. Function may return 0 and this requires an extra check if bit 0 is actual...">get_first</a>, <a class="el" href="classbm_1_1bvector.html#a3a09e493d97f5a66b6ec4e14e04cf118" title="Finds the number of the next bit ON.">get_next</a>, <a class="el" href="classbm_1_1bvector.html#ab4da9b61aca4523c7523136e2db68aa8" title="Finds the number of the next bit ON and sets it to 0.">extract_next</a>, <a class="el" href="classbm_1_1bvector.html#a08093c98bb6dfe27708357801aae7280" title="Finds index of first 1 bit.">find</a>, <a class="el" href="classbm_1_1bvector.html#ada8a47cb4a23e1402a7a6d728e35d50f" title="Finds last index of 1 bit.">find_reverse</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="sample15_8cpp-example.html#a9">sample15.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l04922">4922</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>, <a class="el" href="bm_8h_source.html#l04876">bm::bvector&lt; Alloc &gt;::find()</a>, and <a class="el" href="bm_8h_source.html#l04694">bm::bvector&lt; Alloc &gt;::find_reverse()</a>.</p>

<p class="reference">Referenced by <a class="el" href="sample15_8cpp_source.html#l00062">main()</a>.</p>

</div>
</div>
<a id="a9b2b0eb6ec338ab789ec6508cfab7ff0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b2b0eb6ec338ab789ec6508cfab7ff0">&#9670;&nbsp;</a></span>find_rank() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::find_rank </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td>
          <td class="paramname"><em>rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find bit-vector position for the specified rank(bitcount) </p>
<p >Rank based search, counts number of 1s from specified position until finds the ranked position relative to start from position. In other words: range population count between from and pos == rank.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rank</td><td>- rank to find (bitcount) </td></tr>
    <tr><td class="paramname">from</td><td>- start positioon for rank search </td></tr>
    <tr><td class="paramname">pos</td><td>- position with speciefied rank (relative to from position)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if requested rank was found </dd></dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l04942">4942</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmfunc_8h_source.html#l08673">bm::block_find_rank()</a>, <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>, <a class="el" href="bmdef_8h_source.html#l00338">BM_ASSERT_THROW</a>, <a class="el" href="bmconst_8h_source.html#l00081">bm::gap_max_bits</a>, <a class="el" href="bmconst_8h_source.html#l00109">bm::id_max</a>, <a class="el" href="bmconst_8h_source.html#l00057">bm::set_block_mask</a>, <a class="el" href="bmconst_8h_source.html#l00056">bm::set_block_shift</a>, <a class="el" href="bmconst_8h_source.html#l00055">bm::set_block_size</a>, and <a class="el" href="bmconst_8h_source.html#l00111">bm::set_total_blocks</a>.</p>

</div>
</div>
<a id="aaf0fad1e7ecb0704c2e640cdeb71ab82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf0fad1e7ecb0704c2e640cdeb71ab82">&#9670;&nbsp;</a></span>find_rank() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::find_rank </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td>
          <td class="paramname"><em>rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html#ac9ed62250af37ade811aaf20b7a8d9a2">rs_index_type</a> &amp;&#160;</td>
          <td class="paramname"><em>rs_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find bit-vector position for the specified rank(bitcount) </p>
<p >Rank based search, counts number of 1s from specified position until finds the ranked position relative to start from position. In other words: range population count between from and pos == rank.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rank</td><td>- rank to find (bitcount) </td></tr>
    <tr><td class="paramname">from</td><td>- start positioon for rank search </td></tr>
    <tr><td class="paramname">pos</td><td>- position with speciefied rank (relative to from position) </td></tr>
    <tr><td class="paramname">rs_idx</td><td>- rank-select index to accelarate search (should be prepared using build_rs_index)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbm_1_1bvector.html#adfb63744a9d6039d9e8daa38cf21e3c6" title="compute running total of all blocks in bit vector (rank-select index)">build_rs_index</a>, <a class="el" href="classbm_1_1bvector.html#a7ded07c26c000250baf5215c29c3b602" title="select bit-vector position for the specified rank(bitcount)">select</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if requested rank was found </dd></dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l04995">4995</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmfunc_8h_source.html#l08673">bm::block_find_rank()</a>, <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>, <a class="el" href="bmdef_8h_source.html#l00338">BM_ASSERT_THROW</a>, <a class="el" href="bmconst_8h_source.html#l00109">bm::id_max</a>, <a class="el" href="bmconst_8h_source.html#l00057">bm::set_block_mask</a>, <a class="el" href="bmconst_8h_source.html#l00056">bm::set_block_shift</a>, and <a class="el" href="bmconst_8h_source.html#l00055">bm::set_block_size</a>.</p>

</div>
</div>
<a id="ada8a47cb4a23e1402a7a6d728e35d50f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada8a47cb4a23e1402a7a6d728e35d50f">&#9670;&nbsp;</a></span>find_reverse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::find_reverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds last index of 1 bit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>- [out] index of the last found 1 bit </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if search returned result </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbm_1_1bvector.html#a9ab6964e14405327936d183a11dcd455" title="find first 1 bit in vector. Function may return 0 and this requires an extra check if bit 0 is actual...">get_first</a>, <a class="el" href="classbm_1_1bvector.html#a3a09e493d97f5a66b6ec4e14e04cf118" title="Finds the number of the next bit ON.">get_next</a>, <a class="el" href="classbm_1_1bvector.html#ab4da9b61aca4523c7523136e2db68aa8" title="Finds the number of the next bit ON and sets it to 0.">extract_next</a>, </dd>
<dd>
<a class="el" href="classbm_1_1bvector.html#a08093c98bb6dfe27708357801aae7280" title="Finds index of first 1 bit.">find</a>, <a class="el" href="classbm_1_1bvector.html#a8554bf7b4d276acc00cd31c87cc544ec" title="Find index of first bit different between this and the agr vector.">find_first_mismatch</a>, <a class="el" href="classbm_1_1bvector.html#a509670c79426e6388396c7720519f5c1" title="Finds dynamic range of bit-vector [first, last].">find_range</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="sample15_8cpp-example.html#a8">sample15.cpp</a>, and <a class="el" href="xsample09_8cpp-example.html#a33">xsample09.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l04694">4694</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmfunc_8h_source.html#l08431">bm::bit_find_last()</a>, <a class="el" href="bmdef_8h_source.html#l00191">BM_IS_GAP</a>, <a class="el" href="bmdef_8h_source.html#l00189">BMGAP_PTR</a>, <a class="el" href="bmdef_8h_source.html#l00158">FULL_BLOCK_FAKE_ADDR</a>, <a class="el" href="bmdef_8h_source.html#l00159">FULL_SUB_BLOCK_REAL_ADDR</a>, <a class="el" href="bmfunc_8h_source.html#l01630">bm::gap_find_last()</a>, <a class="el" href="bmconst_8h_source.html#l00081">bm::gap_max_bits</a>, and <a class="el" href="bmconst_8h_source.html#l00095">bm::set_sub_array_size</a>.</p>

<p class="reference">Referenced by <a class="el" href="xsample09_8cpp_source.html#l00294">access_bench2()</a>, <a class="el" href="xsample09_8cpp_source.html#l00319">access_bench3()</a>, <a class="el" href="bm_8h_source.html#l02499">bm::bvector&lt; Alloc &gt;::build_rs_index()</a>, <a class="el" href="bm_8h_source.html#l04139">bm::bvector&lt; Alloc &gt;::clear()</a>, <a class="el" href="bm_8h_source.html#l07809">bm::bvector&lt; Alloc &gt;::copy_range_no_check()</a>, <a class="el" href="bm_8h_source.html#l04922">bm::bvector&lt; Alloc &gt;::find_range()</a>, <a class="el" href="bm_8h_source.html#l04095">bm::bvector&lt; Alloc &gt;::keep()</a>, <a class="el" href="sample15_8cpp_source.html#l00062">main()</a>, and <a class="el" href="bm_8h_source.html#l02484">bm::bvector&lt; Alloc &gt;::sync_size()</a>.</p>

</div>
</div>
<a id="a65a5b7902932108922c56e4803e67ec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65a5b7902932108922c56e4803e67ec9">&#9670;&nbsp;</a></span>find_reverse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::find_reverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverse finds next(prev) index of 1 bit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>- index to search from </td></tr>
    <tr><td class="paramname">pos</td><td>- [out] found position index (undefined if method returns false) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if search returned result </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbm_1_1bvector.html#a9ab6964e14405327936d183a11dcd455" title="find first 1 bit in vector. Function may return 0 and this requires an extra check if bit 0 is actual...">get_first</a>, <a class="el" href="classbm_1_1bvector.html#a3a09e493d97f5a66b6ec4e14e04cf118" title="Finds the number of the next bit ON.">get_next</a>, <a class="el" href="classbm_1_1bvector.html#ab4da9b61aca4523c7523136e2db68aa8" title="Finds the number of the next bit ON and sets it to 0.">extract_next</a>, </dd>
<dd>
<a class="el" href="classbm_1_1bvector.html#a08093c98bb6dfe27708357801aae7280" title="Finds index of first 1 bit.">find</a>, <a class="el" href="classbm_1_1bvector.html#a8554bf7b4d276acc00cd31c87cc544ec" title="Find index of first bit different between this and the agr vector.">find_first_mismatch</a>, <a class="el" href="classbm_1_1bvector.html#a509670c79426e6388396c7720519f5c1" title="Finds dynamic range of bit-vector [first, last].">find_range</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l04751">4751</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmfunc_8h_source.html#l08431">bm::bit_find_last()</a>, <a class="el" href="bmfunc_8h_source.html#l06388">bm::block_find_reverse()</a>, <a class="el" href="bmdef_8h_source.html#l00191">BM_IS_GAP</a>, <a class="el" href="bmdef_8h_source.html#l00189">BMGAP_PTR</a>, <a class="el" href="bmdef_8h_source.html#l00158">FULL_BLOCK_FAKE_ADDR</a>, <a class="el" href="bmdef_8h_source.html#l00159">FULL_SUB_BLOCK_REAL_ADDR</a>, <a class="el" href="bmfunc_8h_source.html#l01630">bm::gap_find_last()</a>, <a class="el" href="bmconst_8h_source.html#l00081">bm::gap_max_bits</a>, <a class="el" href="bmfunc_8h_source.html#l00163">bm::get_block_coord()</a>, <a class="el" href="bmconst_8h_source.html#l00057">bm::set_block_mask</a>, <a class="el" href="bmconst_8h_source.html#l00056">bm::set_block_shift</a>, <a class="el" href="bmconst_8h_source.html#l00095">bm::set_sub_array_size</a>, and <a class="el" href="bm_8h_source.html#l01514">bm::bvector&lt; Alloc &gt;::test()</a>.</p>

</div>
</div>
<a id="a86b939f3aed555dc073e8c26e9efea71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86b939f3aed555dc073e8c26e9efea71">&#9670;&nbsp;</a></span>first()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector_1_1enumerator.html">enumerator</a> <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::first </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns enumerator pointing on the first non-zero bit. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="bv3vlogic_8cpp-example.html#a3">bv3vlogic.cpp</a>, <a class="el" href="bvsetalgebra_8cpp-example.html#a3">bvsetalgebra.cpp</a>, <a class="el" href="sample10_8cpp-example.html#a6">sample10.cpp</a>, <a class="el" href="sample11_8cpp-example.html#a32">sample11.cpp</a>, <a class="el" href="sample12_8cpp-example.html#a19">sample12.cpp</a>, <a class="el" href="sample16_8cpp-example.html#a7">sample16.cpp</a>, <a class="el" href="sample22_8cpp-example.html#a8">sample22.cpp</a>, <a class="el" href="sample5_8cpp-example.html#a4">sample5.cpp</a>, <a class="el" href="sample7_8cpp-example.html#a4">sample7.cpp</a>, <a class="el" href="sample8_8cpp-example.html#a5">sample8.cpp</a>, <a class="el" href="svsample04_8cpp-example.html#a8">svsample04.cpp</a>, <a class="el" href="svsample05_8cpp-example.html#a11">svsample05.cpp</a>, <a class="el" href="svsample06_8cpp-example.html#a20">svsample06.cpp</a>, <a class="el" href="xsample01_8cpp-example.html#a59">xsample01.cpp</a>, <a class="el" href="xsample02_8cpp-example.html#a24">xsample02.cpp</a>, <a class="el" href="xsample03_8cpp-example.html#a29">xsample03.cpp</a>, <a class="el" href="xsample04_8cpp-example.html#a41">xsample04.cpp</a>, and <a class="el" href="xsample07a_8cpp-example.html#a37">xsample07a.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01883">1883</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bm_8h_source.html#l01895">bm::bvector&lt; Alloc &gt;::get_enumerator()</a>.</p>

<p class="reference">Referenced by <a class="el" href="xsample01_8cpp_source.html#l00397">bv2delta()</a>, <a class="el" href="sample11_8cpp_source.html#l00269">bv_counted_enumerator()</a>, <a class="el" href="xsample07a_8cpp_source.html#l01374">compute_random_clusters()</a>, <a class="el" href="xsample01_8cpp_source.html#l00421">convert_bv2sv()</a>, <a class="el" href="xsample01_8cpp_source.html#l00367">convert_bv2vect()</a>, <a class="el" href="xsample07a_8cpp_source.html#l00208">CSequenceColl::deserialize_k_mers()</a>, <a class="el" href="xsample07a_8cpp_source.html#l00994">CSeqClusters::elect_leaders()</a>, <a class="el" href="xsample03_8cpp_source.html#l00292">generate_random_subset()</a>, <a class="el" href="sample5_8cpp_source.html#l00048">main()</a>, <a class="el" href="bvsetalgebra_8cpp_source.html#l00064">print_bvector()</a>, <a class="el" href="xsample02_8cpp_source.html#l00172">print_sorted()</a>, <a class="el" href="bv3vlogic_8cpp_source.html#l00055">PrintKleeneVector()</a>, <a class="el" href="xsample01_8cpp_source.html#l00555">speed_test_bv_index()</a>, <a class="el" href="xsample01_8cpp_source.html#l00614">speed_test_bvs_index()</a>, <a class="el" href="xsample01_8cpp_source.html#l00740">speed_test_sv_index()</a>, <a class="el" href="xsample01_8cpp_source.html#l00678">speed_test_vect_index()</a>, and <a class="el" href="xsample04_8cpp_source.html#l00344">DNA_FingerprintScanner::TranslateResults()</a>.</p>

</div>
</div>
<a id="aaf87e9eb001e03c8828c7a92d9ab4e90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf87e9eb001e03c8828c7a92d9ab4e90">&#9670;&nbsp;</a></span>flip() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector.html">bvector</a>&lt;Alloc&gt;&amp; <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::flip </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flips all bits. </p>
<dl class="section return"><dt>Returns</dt><dd>*this </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbm_1_1bvector.html#a27e95553f358ebebda6b521336682deb" title="Invert/NEG all bits It should be noted, invert is affected by size() if size is set - it only inverts...">invert</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01292">1292</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bm_8h_source.html#l03540">bm::bvector&lt; Alloc &gt;::invert()</a>.</p>

</div>
</div>
<a id="a8085be85fb9d94426c1b45010e282138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8085be85fb9d94426c1b45010e282138">&#9670;&nbsp;</a></span>flip() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector.html">bvector</a>&lt;Alloc&gt;&amp; <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::flip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flips bit n. </p>
<dl class="section return"><dt>Returns</dt><dd>*this </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="sample12_8cpp-example.html#a25">sample12.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01285">1285</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bm_8h_source.html#l04531">bm::bvector&lt; Alloc &gt;::inc()</a>.</p>

</div>
</div>
<a id="a6352dfd0b04f7d5541c47b5335706c1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6352dfd0b04f7d5541c47b5335706c1b">&#9670;&nbsp;</a></span>forget_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::forget_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Disables count cache. (deprecated). </p>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01494">1494</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="a9b20bfbb6f69d1a598cf8d1ef643616e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b20bfbb6f69d1a598cf8d1ef643616e">&#9670;&nbsp;</a></span>freeze()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::freeze</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Turn current vector to read-only (immutable vector). </p>
<p >After calling this method any modification (non-const methods) will cause undefined behavior (likely crash or assert)</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbm_1_1bvector.html#ab8dcdc659b4a912cb9e7478bf10f53ac" title="Returns true if vector is read-only.">is_ro</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="sample26_8cpp-example.html#a16">sample26.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l07841">7841</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmconst_8h_source.html#l00157">bm::BM_READONLY</a>, <a class="el" href="bm_8h_source.html#l01080">bm::bvector&lt; Alloc &gt;::is_ro()</a>, and <a class="el" href="bm_8h_source.html#l03956">bm::bvector&lt; Alloc &gt;::swap()</a>.</p>

<p class="reference">Referenced by <a class="el" href="sample26_8cpp_source.html#l00072">main()</a>.</p>

</div>
</div>
<a id="af2916625363afc9b7ba1d266b2228b9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2916625363afc9b7ba1d266b2228b9b">&#9670;&nbsp;</a></span>gap_block_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::gap_block_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">bm::gap_word_t</a> *&#160;</td>
          <td class="paramname"><em>gap_blk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#ac11e61368363493754cbe97b69a1ca71">block_idx_type</a>&#160;</td>
          <td class="paramname"><em>nblock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nbit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set bit in GAP block with GAP block length control </p>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l04494">4494</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmfunc_8h_source.html#l01566">bm::gap_length()</a>, <a class="el" href="bmfunc_8h_source.html#l01598">bm::gap_limit()</a>, and <a class="el" href="bmfunc_8h_source.html#l03164">bm::gap_set_value()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l04619">bm::bvector&lt; Alloc &gt;::and_bit_no_check()</a>, <a class="el" href="bm_8h_source.html#l04531">bm::bvector&lt; Alloc &gt;::inc()</a>, <a class="el" href="bm_8h_source.html#l04567">bm::bvector&lt; Alloc &gt;::set_bit_conditional_impl()</a>, and <a class="el" href="bm_8h_source.html#l04377">bm::bvector&lt; Alloc &gt;::set_bit_no_check()</a>.</p>

</div>
</div>
<a id="ae520c44dddc3f037bfb5ca51d3032dcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae520c44dddc3f037bfb5ca51d3032dcd">&#9670;&nbsp;</a></span>gap_block_set_no_ret()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::gap_block_set_no_ret </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">bm::gap_word_t</a> *&#160;</td>
          <td class="paramname"><em>gap_blk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#ac11e61368363493754cbe97b69a1ca71">block_idx_type</a>&#160;</td>
          <td class="paramname"><em>nblock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nbit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set bit in GAP block with GAP block length control </p>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l04513">4513</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmfunc_8h_source.html#l01566">bm::gap_length()</a>, <a class="el" href="bmfunc_8h_source.html#l01598">bm::gap_limit()</a>, and <a class="el" href="bmfunc_8h_source.html#l03164">bm::gap_set_value()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l04460">bm::bvector&lt; Alloc &gt;::clear_bit_no_check()</a>, <a class="el" href="bm_8h_source.html#l04342">bm::bvector&lt; Alloc &gt;::import_block()</a>, and <a class="el" href="bm_8h_source.html#l04426">bm::bvector&lt; Alloc &gt;::set_bit_no_check()</a>.</p>

</div>
</div>
<a id="ade78fa98c59c68aedb4fd71e7b274c5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade78fa98c59c68aedb4fd71e7b274c5f">&#9670;&nbsp;</a></span>get_allocator_pool()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector.html#a2c8990a2147fdc3e6094011e77e559e8">allocator_pool_type</a>* <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::get_allocator_pool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get curent allocator pool (if set) </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to the current pool or NULL </dd></dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01065">1065</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="af2553cf458874b088e0675e093289d89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2553cf458874b088e0675e093289d89">&#9670;&nbsp;</a></span>get_bit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::get_bit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns true if bit n is set and false is bit n is 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>- Index of the bit to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bit value (1 or 0) </dd></dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l03592">3592</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>, <a class="el" href="bmdef_8h_source.html#l00338">BM_ASSERT_THROW</a>, <a class="el" href="bmdef_8h_source.html#l00191">BM_IS_GAP</a>, <a class="el" href="bmdef_8h_source.html#l00189">BMGAP_PTR</a>, <a class="el" href="bmdef_8h_source.html#l00158">FULL_BLOCK_FAKE_ADDR</a>, <a class="el" href="bmfunc_8h_source.html#l01775">bm::gap_test_unr()</a>, <a class="el" href="bmfunc_8h_source.html#l00163">bm::get_block_coord()</a>, <a class="el" href="bmconst_8h_source.html#l00057">bm::set_block_mask</a>, <a class="el" href="bmconst_8h_source.html#l00056">bm::set_block_shift</a>, <a class="el" href="bmconst_8h_source.html#l00073">bm::set_word_mask</a>, and <a class="el" href="bmconst_8h_source.html#l00072">bm::set_word_shift</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l01034">bm::bvector&lt; Alloc &gt;::operator[]()</a>, and <a class="el" href="bm_8h_source.html#l01514">bm::bvector&lt; Alloc &gt;::test()</a>.</p>

</div>
</div>
<a id="a0fe9de075b14a63c8940ba462e3eca98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fe9de075b14a63c8940ba462e3eca98">&#9670;&nbsp;</a></span>get_blocks_manager() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector.html#a6fdfeafe05217c31cdc9140b7642b611">blocks_manager_type</a>&amp; <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::get_blocks_manager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get access to memory manager (internal) Use only if you are BitMagic library </p>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l02078">2078</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="a4a08b48003a0f25be9c148b942b1d85b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a08b48003a0f25be9c148b942b1d85b">&#9670;&nbsp;</a></span>get_blocks_manager() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classbm_1_1bvector.html#a6fdfeafe05217c31cdc9140b7642b611">blocks_manager_type</a>&amp; <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::get_blocks_manager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get access to memory manager (internal) Use only if you are BitMagic library </p>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l02070">2070</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l05901">bm::bvector&lt; Alloc &gt;::bit_and()</a>, <a class="el" href="bm_8h_source.html#l05689">bm::bvector&lt; Alloc &gt;::bit_or()</a>, <a class="el" href="bm_8h_source.html#l05996">bm::bvector&lt; Alloc &gt;::bit_or_and()</a>, <a class="el" href="bm_8h_source.html#l06113">bm::bvector&lt; Alloc &gt;::bit_sub()</a>, and <a class="el" href="bm_8h_source.html#l05788">bm::bvector&lt; Alloc &gt;::bit_xor()</a>.</p>

</div>
</div>
<a id="abae3a8b0367bcec9ea9b24b064e66dee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abae3a8b0367bcec9ea9b24b064e66dee">&#9670;&nbsp;</a></span>get_enumerator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector_1_1enumerator.html">enumerator</a> <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::get_enumerator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns enumerator pointing on specified or the next available bit. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="strsvsample06_8cpp-example.html#a17">strsvsample06.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01895">1895</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bm_8h_source.html#l00827">bm::bvector&lt; Alloc &gt;::enumerator</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l01883">bm::bvector&lt; Alloc &gt;::first()</a>, and <a class="el" href="strsvsample06_8cpp_source.html#l00047">main()</a>.</p>

</div>
</div>
<a id="a9ab6964e14405327936d183a11dcd455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ab6964e14405327936d183a11dcd455">&#9670;&nbsp;</a></span>get_first()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::get_first </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find first 1 bit in vector. Function may return 0 and this requires an extra check if bit 0 is actually set or bit-vector is empty </p>
<dl class="section return"><dt>Returns</dt><dd>Index of the first 1 bit, may return 0 </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbm_1_1bvector.html#a3a09e493d97f5a66b6ec4e14e04cf118" title="Finds the number of the next bit ON.">get_next</a>, <a class="el" href="classbm_1_1bvector.html#a08093c98bb6dfe27708357801aae7280" title="Finds index of first 1 bit.">find</a>, <a class="el" href="classbm_1_1bvector.html#ab4da9b61aca4523c7523136e2db68aa8" title="Finds the number of the next bit ON and sets it to 0.">extract_next</a>, <a class="el" href="classbm_1_1bvector.html#ada8a47cb4a23e1402a7a6d728e35d50f" title="Finds last index of 1 bit.">find_reverse</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="sample2_8cpp-example.html#a2">sample2.cpp</a>, and <a class="el" href="xsample07a_8cpp-example.html#a94">xsample07a.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01612">1612</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bm_8h_source.html#l05107">bm::bvector&lt; Alloc &gt;::check_or_next()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bmvmin_8h_source.html#l00340">bm::bvector_mini&lt; A &gt;::compare()</a>, <a class="el" href="sample2_8cpp_source.html#l00036">print_bvector()</a>, and <a class="el" href="xsample07a_8cpp_source.html#l00822">CSeqClusters::take_group()</a>.</p>

</div>
</div>
<a id="a615337f0db4c56d0cf1df85477c9fe41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a615337f0db4c56d0cf1df85477c9fe41">&#9670;&nbsp;</a></span>get_new_blocks_strat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bvector.html#gad0b87b3b7292383a864d27feaf1c9eff">strategy</a> <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::get_new_blocks_strat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns blocks allocation strategy. </p>
<dl class="section return"><dt>Returns</dt><dd>- Strategy code 0 - bitblocks allocation only. 1 - Blocks mutation mode (adaptive algorithm) </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbm_1_1bvector.html#a653ee052b297a49c35344704df67a452" title="Sets new blocks allocation strategy.">set_new_blocks_strat</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01932">1932</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l04619">bm::bvector&lt; Alloc &gt;::and_bit_no_check()</a>, <a class="el" href="bm_8h_source.html#l04460">bm::bvector&lt; Alloc &gt;::clear_bit_no_check()</a>, <a class="el" href="bm_8h_source.html#l04531">bm::bvector&lt; Alloc &gt;::inc()</a>, <a class="el" href="bm_8h_source.html#l05226">bm::bvector&lt; Alloc &gt;::insert()</a>, <a class="el" href="bm_8h_source.html#l04567">bm::bvector&lt; Alloc &gt;::set_bit_conditional_impl()</a>, and <a class="el" href="bm_8h_source.html#l04377">bm::bvector&lt; Alloc &gt;::set_bit_no_check()</a>.</p>

</div>
</div>
<a id="a3a09e493d97f5a66b6ec4e14e04cf118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a09e493d97f5a66b6ec4e14e04cf118">&#9670;&nbsp;</a></span>get_next()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacebm.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::get_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td>
          <td class="paramname"><em>prev</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the number of the next bit ON. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prev</td><td>- Index of the previously found bit. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index of the next bit which is ON or 0 if not found. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbm_1_1bvector.html#a9ab6964e14405327936d183a11dcd455" title="find first 1 bit in vector. Function may return 0 and this requires an extra check if bit 0 is actual...">get_first</a>, <a class="el" href="classbm_1_1bvector.html#a08093c98bb6dfe27708357801aae7280" title="Finds index of first 1 bit.">find</a>, <a class="el" href="classbm_1_1bvector.html#ab4da9b61aca4523c7523136e2db68aa8" title="Finds the number of the next bit ON and sets it to 0.">extract_next</a>, <a class="el" href="classbm_1_1bvector.html#ada8a47cb4a23e1402a7a6d728e35d50f" title="Finds last index of 1 bit.">find_reverse</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="sample2_8cpp-example.html#a3">sample2.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01621">1621</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bm_8h_source.html#l05107">bm::bvector&lt; Alloc &gt;::check_or_next()</a>, and <a class="el" href="bmconst_8h_source.html#l00109">bm::id_max</a>.</p>

<p class="reference">Referenced by <a class="el" href="bmvmin_8h_source.html#l00340">bm::bvector_mini&lt; A &gt;::compare()</a>, and <a class="el" href="sample2_8cpp_source.html#l00036">print_bvector()</a>.</p>

</div>
</div>
<a id="abc874cffc4cd09986dcb6b6f597bf05b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc874cffc4cd09986dcb6b6f597bf05b">&#9670;&nbsp;</a></span>import()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::import </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> *&#160;</td>
          <td class="paramname"><em>ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td>
          <td class="paramname"><em>ids_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bvector.html#ga04a7a7cda4bf04cd107e198b3b1e4ed8">bm::sort_order</a>&#160;</td>
          <td class="paramname"><em>sorted_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Import integers (set bits). </p>
<p >(Fast, no checks). </p>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l04235">4235</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>, <a class="el" href="bmconst_8h_source.html#l00205">bm::BM_SORTED</a>, <a class="el" href="bmfunc_8h_source.html#l09457">bm::idx_arr_block_lookup_u32()</a>, <a class="el" href="bmfunc_8h_source.html#l09431">bm::idx_arr_block_lookup_u64()</a>, <a class="el" href="bm_8h_source.html#l04342">bm::bvector&lt; Alloc &gt;::import_block()</a>, <a class="el" href="bm_8h_source.html#l01080">bm::bvector&lt; Alloc &gt;::is_ro()</a>, and <a class="el" href="bmconst_8h_source.html#l00056">bm::set_block_shift</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l04139">bm::bvector&lt; Alloc &gt;::clear()</a>, <a class="el" href="bm_8h_source.html#l00566">bm::bvector&lt; Alloc &gt;::bulk_insert_iterator::flush()</a>, <a class="el" href="bm_8h_source.html#l04095">bm::bvector&lt; Alloc &gt;::keep()</a>, and <a class="el" href="bm_8h_source.html#l00544">bm::bvector&lt; Alloc &gt;::bulk_insert_iterator::operator=()</a>.</p>

</div>
</div>
<a id="a04226053e3a2dfc46af6816f0bebf331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04226053e3a2dfc46af6816f0bebf331">&#9670;&nbsp;</a></span>import_block()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::import_block </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> *&#160;</td>
          <td class="paramname"><em>ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#ac11e61368363493754cbe97b69a1ca71">block_idx_type</a>&#160;</td>
          <td class="paramname"><em>nblock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td>
          <td class="paramname"><em>stop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l04342">4342</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>, <a class="el" href="bmdef_8h_source.html#l00191">BM_IS_GAP</a>, <a class="el" href="bmdef_8h_source.html#l00189">BMGAP_PTR</a>, <a class="el" href="bm_8h_source.html#l04513">bm::bvector&lt; Alloc &gt;::gap_block_set_no_ret()</a>, <a class="el" href="bmdef_8h_source.html#l00162">IS_FULL_BLOCK</a>, <a class="el" href="bmfunc_8h_source.html#l09520">bm::set_block_bits_u32()</a>, <a class="el" href="bmfunc_8h_source.html#l09490">bm::set_block_bits_u64()</a>, <a class="el" href="bmconst_8h_source.html#l00057">bm::set_block_mask</a>, <a class="el" href="bmconst_8h_source.html#l00055">bm::set_block_size</a>, and <a class="el" href="bmconst_8h_source.html#l00111">bm::set_total_blocks</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l04235">bm::bvector&lt; Alloc &gt;::import()</a>, and <a class="el" href="bm_8h_source.html#l04280">bm::bvector&lt; Alloc &gt;::import_sorted()</a>.</p>

</div>
</div>
<a id="a354bc2c3c91235c9034a92b0fa410765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a354bc2c3c91235c9034a92b0fa410765">&#9670;&nbsp;</a></span>import_sorted()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::import_sorted </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> *&#160;</td>
          <td class="paramname"><em>ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td>
          <td class="paramname"><em>ids_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Import sorted integers (set bits). </p>
<p >(Fast, no checks). </p>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l04280">4280</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>, <a class="el" href="bmfunc_8h_source.html#l00163">bm::get_block_coord()</a>, <a class="el" href="bmconst_8h_source.html#l00109">bm::id_max</a>, <a class="el" href="bmfunc_8h_source.html#l09457">bm::idx_arr_block_lookup_u32()</a>, <a class="el" href="bmfunc_8h_source.html#l09431">bm::idx_arr_block_lookup_u64()</a>, <a class="el" href="bm_8h_source.html#l04342">bm::bvector&lt; Alloc &gt;::import_block()</a>, <a class="el" href="bmconst_8h_source.html#l00057">bm::set_block_mask</a>, and <a class="el" href="bmconst_8h_source.html#l00056">bm::set_block_shift</a>.</p>

</div>
</div>
<a id="afef7a91140cfeb7e28698f8bbda2bdd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afef7a91140cfeb7e28698f8bbda2bdd6">&#9670;&nbsp;</a></span>inc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::inc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increment the specified element. </p>
<p >Bit increment rules: 0 + 1 = 1 (no carry over) 1 + 1 = 0 (with carry over returned)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>- index of the bit to be set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if carry over created (1+1) </dd></dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l04531">4531</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>, <a class="el" href="bmdef_8h_source.html#l00191">BM_IS_GAP</a>, <a class="el" href="bmdef_8h_source.html#l00189">BMGAP_PTR</a>, <a class="el" href="bm_8h_source.html#l04494">bm::bvector&lt; Alloc &gt;::gap_block_set()</a>, <a class="el" href="bmfunc_8h_source.html#l01775">bm::gap_test_unr()</a>, <a class="el" href="bm_8h_source.html#l01932">bm::bvector&lt; Alloc &gt;::get_new_blocks_strat()</a>, <a class="el" href="bm_8h_source.html#l01080">bm::bvector&lt; Alloc &gt;::is_ro()</a>, <a class="el" href="bmdef_8h_source.html#l00161">IS_VALID_ADDR</a>, <a class="el" href="bmconst_8h_source.html#l00057">bm::set_block_mask</a>, <a class="el" href="bmconst_8h_source.html#l00056">bm::set_block_shift</a>, <a class="el" href="bmconst_8h_source.html#l00073">bm::set_word_mask</a>, and <a class="el" href="bmconst_8h_source.html#l00072">bm::set_word_shift</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l01285">bm::bvector&lt; Alloc &gt;::flip()</a>.</p>

</div>
</div>
<a id="aaceb8d31d9da05f977de5c6a6cd62e24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaceb8d31d9da05f977de5c6a6cd62e24">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::init</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicit post-construction initialization. Must be caled to make sure safe use of *_no_check() methods. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="sample12_8cpp-example.html#a12">sample12.cpp</a>, <a class="el" href="svsample06_8cpp-example.html#a15">svsample06.cpp</a>, and <a class="el" href="xsample03_8cpp-example.html#a20">xsample03.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l02291">2291</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>, and <a class="el" href="bm_8h_source.html#l01080">bm::bvector&lt; Alloc &gt;::is_ro()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l02499">bm::bvector&lt; Alloc &gt;::build_rs_index()</a>, <a class="el" href="bm_8h_source.html#l00487">bm::bvector&lt; Alloc &gt;::bulk_insert_iterator::bulk_insert_iterator()</a>, <a class="el" href="sample12_8cpp_source.html#l00128">bv_set_bit_no_check_test()</a>, <a class="el" href="bm_8h_source.html#l00970">bm::bvector&lt; Alloc &gt;::bvector()</a>, <a class="el" href="bmbmatrix_8h_source.html#l01040">bm::basic_bmatrix&lt; BV &gt;::construct_bvector()</a>, <a class="el" href="bm_8h_source.html#l04048">bm::bvector&lt; Alloc &gt;::fill_alloc_digest()</a>, <a class="el" href="bm_8h_source.html#l00395">bm::bvector&lt; Alloc &gt;::insert_iterator::insert_iterator()</a>, <a class="el" href="xsample03_8cpp_source.html#l00218">load_snp_report()</a>, <a class="el" href="sample12_8cpp_source.html#l00189">main()</a>, <a class="el" href="xsample03_8cpp_source.html#l00349">run_benchmark()</a>, and <a class="el" href="svsample06_8cpp_source.html#l00106">vector_search()</a>.</p>

</div>
</div>
<a id="a3aa18488051520338d0787c4867d944d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aa18488051520338d0787c4867d944d">&#9670;&nbsp;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert bit into specified position All the vector content after insert position is shifted right. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>- index of the bit to insert </td></tr>
    <tr><td class="paramname">value</td><td>- insert value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Carry over bit value (1 or 0) </dd></dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l05226">5226</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmfunc_8h_source.html#l05542">bm::bit_block_insert()</a>, <a class="el" href="bmfunc_8h_source.html#l05668">bm::bit_block_shift_r1_unr()</a>, <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>, <a class="el" href="bmdef_8h_source.html#l00338">BM_ASSERT_THROW</a>, <a class="el" href="bmdef_8h_source.html#l00191">BM_IS_GAP</a>, <a class="el" href="bmdef_8h_source.html#l00189">BMGAP_PTR</a>, <a class="el" href="bmdef_8h_source.html#l00158">FULL_BLOCK_FAKE_ADDR</a>, <a class="el" href="bmfunc_8h_source.html#l03457">bm::gap_insert()</a>, <a class="el" href="bmfunc_8h_source.html#l01598">bm::gap_limit()</a>, <a class="el" href="bmconst_8h_source.html#l00081">bm::gap_max_bits</a>, <a class="el" href="bmfunc_8h_source.html#l03404">bm::gap_shift_r1()</a>, <a class="el" href="bmfunc_8h_source.html#l00163">bm::get_block_coord()</a>, <a class="el" href="bm_8h_source.html#l01932">bm::bvector&lt; Alloc &gt;::get_new_blocks_strat()</a>, <a class="el" href="bmconst_8h_source.html#l00109">bm::id_max</a>, <a class="el" href="bmdef_8h_source.html#l00162">IS_FULL_BLOCK</a>, <a class="el" href="bm_8h_source.html#l01080">bm::bvector&lt; Alloc &gt;::is_ro()</a>, <a class="el" href="bmdef_8h_source.html#l00161">IS_VALID_ADDR</a>, <a class="el" href="bm_8h_source.html#l04167">bm::bvector&lt; Alloc &gt;::set()</a>, <a class="el" href="bm_8h_source.html#l04426">bm::bvector&lt; Alloc &gt;::set_bit_no_check()</a>, <a class="el" href="bmconst_8h_source.html#l00057">bm::set_block_mask</a>, <a class="el" href="bmconst_8h_source.html#l00056">bm::set_block_shift</a>, <a class="el" href="bmconst_8h_source.html#l00055">bm::set_block_size</a>, <a class="el" href="bmconst_8h_source.html#l00095">bm::set_sub_array_size</a>, <a class="el" href="bmconst_8h_source.html#l00110">bm::set_top_array_size</a>, <a class="el" href="bmconst_8h_source.html#l00111">bm::set_total_blocks</a>, and <a class="el" href="bm_8h_source.html#l00659">bm::bvector&lt; Alloc &gt;::enumerator::value()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l05206">bm::bvector&lt; Alloc &gt;::shift_right()</a>.</p>

</div>
</div>
<a id="a6fbb5c0bd6f4b05712ee7701dcd1fe1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fbb5c0bd6f4b05712ee7701dcd1fe1e">&#9670;&nbsp;</a></span>inserter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector_1_1insert__iterator.html">insert_iterator</a> <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::inserter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Function erturns insert iterator for this bitvector </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="bv3vlogic_8cpp-example.html#a13">bv3vlogic.cpp</a>, <a class="el" href="sample18_8cpp-example.html#a3">sample18.cpp</a>, <a class="el" href="sample8_8cpp-example.html#a9">sample8.cpp</a>, and <a class="el" href="xsample04a_8cpp-example.html#a18">xsample04a.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01299">1299</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="xsample04a_8cpp_source.html#l00160">DNA_FingerprintScanner::Build()</a>, <a class="el" href="sample8_8cpp_source.html#l00066">main()</a>, and <a class="el" href="bv3vlogic_8cpp_source.html#l00117">Set3VL_ValueDemo2()</a>.</p>

</div>
</div>
<a id="a27e95553f358ebebda6b521336682deb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27e95553f358ebebda6b521336682deb">&#9670;&nbsp;</a></span>invert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp; <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::invert</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invert/NEG all bits It should be noted, invert is affected by <a class="el" href="classbm_1_1bvector.html#a2f4d04c5a506faa42a6ce36dfc6c445b" title="Returns bvector&#39;s capacity (number of bits it can store)">size()</a> if size is set - it only inverts [0..size-1] bits. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="bvsetalgebra_8cpp-example.html#a50">bvsetalgebra.cpp</a>, and <a class="el" href="strsvsample06_8cpp-example.html#a15">strsvsample06.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l03540">3540</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmfunc_8h_source.html#l06014">bm::bit_invert()</a>, <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>, <a class="el" href="bmdef_8h_source.html#l00191">BM_IS_GAP</a>, <a class="el" href="bmdef_8h_source.html#l00189">BMGAP_PTR</a>, <a class="el" href="bmdef_8h_source.html#l00158">FULL_BLOCK_FAKE_ADDR</a>, <a class="el" href="bmfunc_8h_source.html#l04577">bm::gap_invert()</a>, <a class="el" href="bmconst_8h_source.html#l00109">bm::id_max</a>, <a class="el" href="bmdef_8h_source.html#l00162">IS_FULL_BLOCK</a>, <a class="el" href="bm_8h_source.html#l01080">bm::bvector&lt; Alloc &gt;::is_ro()</a>, <a class="el" href="bm_8h_source.html#l04426">bm::bvector&lt; Alloc &gt;::set_bit_no_check()</a>, <a class="el" href="bmconst_8h_source.html#l00095">bm::set_sub_array_size</a>, and <a class="el" href="bmconst_8h_source.html#l00110">bm::set_top_array_size</a>.</p>

<p class="reference">Referenced by <a class="el" href="bvsetalgebra_8cpp_source.html#l00603">DemoINV()</a>, <a class="el" href="bm_8h_source.html#l01292">bm::bvector&lt; Alloc &gt;::flip()</a>, <a class="el" href="strsvsample06_8cpp_source.html#l00047">main()</a>, <a class="el" href="bm_8h_source.html#l01052">bm::bvector&lt; Alloc &gt;::operator~()</a>, and <a class="el" href="bmsparsevec__algo_8h_source.html#l00347">bm::sparse_vector_find_mismatch()</a>.</p>

</div>
</div>
<a id="a7d36a1f08ff5c39c55b6bbdfe6251001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d36a1f08ff5c39c55b6bbdfe6251001">&#9670;&nbsp;</a></span>is_all_one_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::is_all_one_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if all bits in the range are 1s (saturated interval) Function uses closed interval [left, right]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>- index of first bit start checking </td></tr>
    <tr><td class="paramname">right</td><td>- index of last bit</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all bits are 1, false otherwise </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbm_1_1bvector.html#a530f12c9a00799ecbe9abd276a7ae619" title="Returns true if any bits in the range are 1s (non-empty interval) Function uses closed interval [left...">any_range</a>, <a class="el" href="classbm_1_1bvector.html#a99395aaa8ab689455054bda9b261de60" title="Returns count of 1 bits in the given range [left..right] Uses rank-select index to accelerate the sea...">count_range</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l03329">3329</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmfunc_8h_source.html#l06064">bm::block_is_all_one_range()</a>, <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>, <a class="el" href="bmfunc_8h_source.html#l08796">bm::check_block_one()</a>, <a class="el" href="bmdef_8h_source.html#l00158">FULL_BLOCK_FAKE_ADDR</a>, <a class="el" href="bmconst_8h_source.html#l00081">bm::gap_max_bits</a>, <a class="el" href="bmfunc_8h_source.html#l00163">bm::get_block_coord()</a>, <a class="el" href="bmconst_8h_source.html#l00109">bm::id_max</a>, <a class="el" href="bmconst_8h_source.html#l00057">bm::set_block_mask</a>, <a class="el" href="bmconst_8h_source.html#l00056">bm::set_block_shift</a>, <a class="el" href="bmconst_8h_source.html#l00095">bm::set_sub_array_size</a>, <a class="el" href="bm_8h_source.html#l01514">bm::bvector&lt; Alloc &gt;::test()</a>, and <a class="el" href="bmutil_8h_source.html#l00536">bm::xor_swap()</a>.</p>

<p class="reference">Referenced by <a class="el" href="sample22_8cpp_source.html#l00072">main()</a>.</p>

</div>
</div>
<a id="a3641cc5dd36f35bd38e9a63701037e0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3641cc5dd36f35bd38e9a63701037e0d">&#9670;&nbsp;</a></span>is_init()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::is_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if bvector is initialized at all. </p>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01995">1995</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

</div>
</div>
<a id="ab8dcdc659b4a912cb9e7478bf10f53ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8dcdc659b4a912cb9e7478bf10f53ac">&#9670;&nbsp;</a></span>is_ro()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::is_ro </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if vector is read-only. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="sample26_8cpp-example.html#a17">sample26.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01080">1080</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l04619">bm::bvector&lt; Alloc &gt;::and_bit_no_check()</a>, <a class="el" href="bm_8h_source.html#l01814">bm::bvector&lt; Alloc &gt;::bit_and()</a>, <a class="el" href="bm_8h_source.html#l01802">bm::bvector&lt; Alloc &gt;::bit_or()</a>, <a class="el" href="bm_8h_source.html#l05996">bm::bvector&lt; Alloc &gt;::bit_or_and()</a>, <a class="el" href="bm_8h_source.html#l01837">bm::bvector&lt; Alloc &gt;::bit_sub()</a>, <a class="el" href="bm_8h_source.html#l01826">bm::bvector&lt; Alloc &gt;::bit_xor()</a>, <a class="el" href="bm_8h_source.html#l03968">bm::bvector&lt; Alloc &gt;::calc_stat()</a>, <a class="el" href="bm_8h_source.html#l05191">bm::bvector&lt; Alloc &gt;::check_or_next_extract()</a>, <a class="el" href="bm_8h_source.html#l04125">bm::bvector&lt; Alloc &gt;::clear()</a>, <a class="el" href="bm_8h_source.html#l04460">bm::bvector&lt; Alloc &gt;::clear_bit_no_check()</a>, <a class="el" href="bm_8h_source.html#l02301">bm::bvector&lt; Alloc &gt;::copy()</a>, <a class="el" href="bm_8h_source.html#l05429">bm::bvector&lt; Alloc &gt;::erase()</a>, <a class="el" href="bm_8h_source.html#l07841">bm::bvector&lt; Alloc &gt;::freeze()</a>, <a class="el" href="bm_8h_source.html#l04235">bm::bvector&lt; Alloc &gt;::import()</a>, <a class="el" href="bm_8h_source.html#l04531">bm::bvector&lt; Alloc &gt;::inc()</a>, <a class="el" href="bm_8h_source.html#l02291">bm::bvector&lt; Alloc &gt;::init()</a>, <a class="el" href="bm_8h_source.html#l05226">bm::bvector&lt; Alloc &gt;::insert()</a>, <a class="el" href="bm_8h_source.html#l03540">bm::bvector&lt; Alloc &gt;::invert()</a>, <a class="el" href="bm_8h_source.html#l04095">bm::bvector&lt; Alloc &gt;::keep()</a>, <a class="el" href="bm_8h_source.html#l02351">bm::bvector&lt; Alloc &gt;::keep_range()</a>, <a class="el" href="sample26_8cpp_source.html#l00072">main()</a>, <a class="el" href="bm_8h_source.html#l05599">bm::bvector&lt; Alloc &gt;::merge()</a>, <a class="el" href="bm_8h_source.html#l03625">bm::bvector&lt; Alloc &gt;::optimize()</a>, <a class="el" href="bm_8h_source.html#l03661">bm::bvector&lt; Alloc &gt;::optimize_range()</a>, <a class="el" href="bm_8h_source.html#l02461">bm::bvector&lt; Alloc &gt;::resize()</a>, <a class="el" href="bm_8h_source.html#l04078">bm::bvector&lt; Alloc &gt;::set()</a>, <a class="el" href="bm_8h_source.html#l04217">bm::bvector&lt; Alloc &gt;::set_bit()</a>, <a class="el" href="bm_8h_source.html#l04203">bm::bvector&lt; Alloc &gt;::set_bit_and()</a>, <a class="el" href="bm_8h_source.html#l04377">bm::bvector&lt; Alloc &gt;::set_bit_no_check()</a>, <a class="el" href="bm_8h_source.html#l03716">bm::bvector&lt; Alloc &gt;::set_gap_levels()</a>, <a class="el" href="bm_8h_source.html#l02366">bm::bvector&lt; Alloc &gt;::set_range()</a>, <a class="el" href="bm_8h_source.html#l05215">bm::bvector&lt; Alloc &gt;::shift_left()</a>, <a class="el" href="bm_8h_source.html#l05206">bm::bvector&lt; Alloc &gt;::shift_right()</a>, and <a class="el" href="bm_8h_source.html#l02484">bm::bvector&lt; Alloc &gt;::sync_size()</a>.</p>

</div>
</div>
<a id="ae79e966df54b3083fb14519f74a800af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae79e966df54b3083fb14519f74a800af">&#9670;&nbsp;</a></span>keep()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::keep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> *&#160;</td>
          <td class="paramname"><em>ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td>
          <td class="paramname"><em>ids_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bvector.html#ga04a7a7cda4bf04cd107e198b3b1e4ed8">bm::sort_order</a>&#160;</td>
          <td class="paramname"><em>so</em> = <code><a class="el" href="group__bvector.html#gga04a7a7cda4bf04cd107e198b3b1e4ed8a981e9b62bb43cc0388f268f1041f9293">bm::BM_UNKNOWN</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Keep list of bits in this bitset, others are cleared. </p>
<p >This is equivalent of AND (Set Intersect), argument set as an array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ids</td><td>- pointer on array of indexes to set </td></tr>
    <tr><td class="paramname">ids_size</td><td>- size of the input (ids) </td></tr>
    <tr><td class="paramname">so</td><td>- sort order (use BM_SORTED for faster load)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbm_1_1bvector.html#a52b4259a5cc4ebd8953832c696e24f02" title="Sets bit n if val is true, clears bit n if val is false.">set</a>, <a class="el" href="classbm_1_1bvector.html#ac6f13fa4ba188585e5c5d4e89843a44e" title="clear list of bits in this bitset">clear</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="bvsetalgebra_8cpp-example.html#a32">bvsetalgebra.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l04095">4095</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bm_8h_source.html#l05901">bm::bvector&lt; Alloc &gt;::bit_and()</a>, <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>, <a class="el" href="bm_8h_source.html#l04139">bm::bvector&lt; Alloc &gt;::clear()</a>, <a class="el" href="bm_8h_source.html#l04694">bm::bvector&lt; Alloc &gt;::find_reverse()</a>, <a class="el" href="bm_8h_source.html#l04235">bm::bvector&lt; Alloc &gt;::import()</a>, <a class="el" href="bm_8h_source.html#l01080">bm::bvector&lt; Alloc &gt;::is_ro()</a>, and <a class="el" href="bm_8h_source.html#l02461">bm::bvector&lt; Alloc &gt;::resize()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bvsetalgebra_8cpp_source.html#l00221">DemoAND()</a>.</p>

</div>
</div>
<a id="a7595276e924423bc734c4fd74113f1b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7595276e924423bc734c4fd74113f1b5">&#9670;&nbsp;</a></span>keep_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::keep_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets all bits to zero outside of the closed interval [left,right] Expected result: 00000...0[left, right]0....0000. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>- interval start </td></tr>
    <tr><td class="paramname">right</td><td>- interval end (closed interval)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbm_1_1bvector.html#aafb2ecaa1a55856533e6b4afbf788eae" title="Sets all bits in the specified closed interval [left,right] Interval must be inside the bvector&#39;s siz...">set_range</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l02351">2351</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>, <a class="el" href="bm_8h_source.html#l01080">bm::bvector&lt; Alloc &gt;::is_ro()</a>, and <a class="el" href="bmutil_8h_source.html#l00536">bm::xor_swap()</a>.</p>

<p class="reference">Referenced by <a class="el" href="sample22_8cpp_source.html#l00072">main()</a>.</p>

</div>
</div>
<a id="a237170e9f988319665bbcac2cd10e24e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a237170e9f988319665bbcac2cd10e24e">&#9670;&nbsp;</a></span>merge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bvect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge/move content from another vector. </p>
<p >Merge performs a logical OR operation, but the source vector is not immutable. Source content gets destroyed (memory moved) to create a union of two vectors. Merge operation can be more efficient than OR if argument is a temporary vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bvect</td><td>- [in, out] - source vector (NOT immutable) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="bvsetalgebra_8cpp-example.html#a15">bvsetalgebra.cpp</a>, <a class="el" href="xsample04a_8cpp-example.html#a25">xsample04a.cpp</a>, and <a class="el" href="xsample07a_8cpp-example.html#a71">xsample07a.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l05599">5599</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bm_8h_source.html#l05689">bm::bvector&lt; Alloc &gt;::bit_or()</a>, <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>, <a class="el" href="bm_8h_source.html#l06655">bm::bvector&lt; Alloc &gt;::combine_operation_block_or()</a>, <a class="el" href="bmdef_8h_source.html#l00158">FULL_BLOCK_FAKE_ADDR</a>, <a class="el" href="bm_8h_source.html#l01080">bm::bvector&lt; Alloc &gt;::is_ro()</a>, and <a class="el" href="bmconst_8h_source.html#l00095">bm::set_sub_array_size</a>.</p>

<p class="reference">Referenced by <a class="el" href="xsample07a_8cpp_source.html#l01220">CKMerAcc::add()</a>, <a class="el" href="bvsetalgebra_8cpp_source.html#l00096">DemoOR()</a>, <a class="el" href="xsample07a_8cpp_source.html#l00718">CSeqGroup::merge_member_sync()</a>, and <a class="el" href="xsample04a_8cpp_source.html#l00324">DNA_FingerprintScanner::MergeVector()</a>.</p>

</div>
</div>
<a id="af513c039068c4ef27494235a5f1aaf4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af513c039068c4ef27494235a5f1aaf4f">&#9670;&nbsp;</a></span>move_from()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::move_from </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bvect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move bvector content from another bvector. </p>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l02338">2338</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l00985">bm::bvector&lt; Alloc &gt;::operator=()</a>.</p>

</div>
</div>
<a id="ad6833053b4c459557138b02e8f0589db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6833053b4c459557138b02e8f0589db">&#9670;&nbsp;</a></span>none()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::none </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if no bits are set, otherwise returns false. </p>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01568">1568</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bm_8h_source.html#l02449">bm::bvector&lt; Alloc &gt;::any()</a>.</p>

</div>
</div>
<a id="ab97d916d8dae991a7d86fd8083b69061"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab97d916d8dae991a7d86fd8083b69061">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bv</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01050">1050</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bm_8h_source.html#l02029">bm::bvector&lt; Alloc &gt;::equal()</a>.</p>

</div>
</div>
<a id="a0fce12ee64a6011d6184277443f0bfcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fce12ee64a6011d6184277443f0bfcd">&#9670;&nbsp;</a></span>operator&amp;=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::operator&amp;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01040">1040</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bm_8h_source.html#l05901">bm::bvector&lt; Alloc &gt;::bit_and()</a>.</p>

</div>
</div>
<a id="a7ceab1a0111e47f2fe4c4421e44fd3e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ceab1a0111e47f2fe4c4421e44fd3e4">&#9670;&nbsp;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01043">1043</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bm_8h_source.html#l06113">bm::bvector&lt; Alloc &gt;::bit_sub()</a>.</p>

</div>
</div>
<a id="a33ba6bcb25602091aedbd01dcb831dcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33ba6bcb25602091aedbd01dcb831dcf">&#9670;&nbsp;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bv</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01045">1045</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bm_8h_source.html#l03734">bm::bvector&lt; Alloc &gt;::compare()</a>.</p>

</div>
</div>
<a id="a9e18cf38c1986e81c495ac10cc1e8c96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e18cf38c1986e81c495ac10cc1e8c96">&#9670;&nbsp;</a></span>operator&lt;=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bv</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01046">1046</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bm_8h_source.html#l03734">bm::bvector&lt; Alloc &gt;::compare()</a>.</p>

</div>
</div>
<a id="aa75a19006f39dddff108694a0a87dee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa75a19006f39dddff108694a0a87dee0">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector.html">bvector</a>&amp; <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>bvect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. </p>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l00985">985</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bm_8h_source.html#l02338">bm::bvector&lt; Alloc &gt;::move_from()</a>.</p>

</div>
</div>
<a id="a3ffde9962a72e85ad2e6da29b397882e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ffde9962a72e85ad2e6da29b397882e">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector.html">bvector</a>&amp; <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bvect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. </p>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l00950">950</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmconst_8h_source.html#l00156">bm::BM_UNDEFINED</a>, and <a class="el" href="bm_8h_source.html#l02301">bm::bvector&lt; Alloc &gt;::copy()</a>.</p>

</div>
</div>
<a id="a8de936ff88917bbc069045c36eabbf09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8de936ff88917bbc069045c36eabbf09">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bv</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01049">1049</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bm_8h_source.html#l02029">bm::bvector&lt; Alloc &gt;::equal()</a>.</p>

</div>
</div>
<a id="a493c937eedfa6e8ad1f2b381678075cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a493c937eedfa6e8ad1f2b381678075cd">&#9670;&nbsp;</a></span>operator&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bv</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01047">1047</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bm_8h_source.html#l03734">bm::bvector&lt; Alloc &gt;::compare()</a>.</p>

</div>
</div>
<a id="a9f5dfbe8e46c969d36ecbaf7261db03c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f5dfbe8e46c969d36ecbaf7261db03c">&#9670;&nbsp;</a></span>operator&gt;=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bv</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01048">1048</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bm_8h_source.html#l03734">bm::bvector&lt; Alloc &gt;::compare()</a>.</p>

</div>
</div>
<a id="a58994dceeabe24a90abfd2b434208c1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58994dceeabe24a90abfd2b434208c1b">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector_1_1reference.html">reference</a> <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01024">1024</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmconst_8h_source.html#l00109">bm::id_max</a>, and <a class="el" href="bm_8h_source.html#l02461">bm::bvector&lt; Alloc &gt;::resize()</a>.</p>

</div>
</div>
<a id="a3554686ee2878e6dcd13b047e8bc668c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3554686ee2878e6dcd13b047e8bc668c">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01034">1034</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>, and <a class="el" href="bm_8h_source.html#l03592">bm::bvector&lt; Alloc &gt;::get_bit()</a>.</p>

</div>
</div>
<a id="ac3adf4c9870b960d5dff4203074fc3d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3adf4c9870b960d5dff4203074fc3d7">&#9670;&nbsp;</a></span>operator^=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::operator^= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01041">1041</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bm_8h_source.html#l05788">bm::bvector&lt; Alloc &gt;::bit_xor()</a>.</p>

</div>
</div>
<a id="ac48cd211c038bdc186baeca30e42fa93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac48cd211c038bdc186baeca30e42fa93">&#9670;&nbsp;</a></span>operator|=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::operator|= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01042">1042</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bm_8h_source.html#l05689">bm::bvector&lt; Alloc &gt;::bit_or()</a>.</p>

</div>
</div>
<a id="a51687153e07d3be056aeb38ada237816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51687153e07d3be056aeb38ada237816">&#9670;&nbsp;</a></span>operator~()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector.html">bvector</a>&lt;Alloc&gt; <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::operator~ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01052">1052</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bm_8h_source.html#l03540">bm::bvector&lt; Alloc &gt;::invert()</a>.</p>

</div>
</div>
<a id="a622e6827d799a561e2f0db28f7ac19d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a622e6827d799a561e2f0db28f7ac19d2">&#9670;&nbsp;</a></span>optimize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::optimize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *&#160;</td>
          <td class="paramname"><em>temp_block</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a05f1e977cb5e6208838afc7e7b69e5f0">optmode</a>&#160;</td>
          <td class="paramname"><em>opt_mode</em> = <code><a class="el" href="classbm_1_1bvector.html#a05f1e977cb5e6208838afc7e7b69e5f0a99b64b2444e1a8b22a5e89b02dca6001">opt_compress</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbm_1_1bvector_1_1statistics.html">statistics</a> *&#160;</td>
          <td class="paramname"><em>stat</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optimize memory bitvector's memory allocation. </p>
<p >Function analyze all blocks in the bitvector, compresses blocks with a regular structure, frees some memory. This function is recommended after a bulk modification of the bitvector using set_bit, clear_bit or logical operations.</p>
<p >Optionally function can calculate vector post optimization statistics</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">temp_block</td><td>- externally allocated temp buffer for optimization <a class="el" href="bm_8h.html#ad9736d9521d713fa5d48859aa720bfdd">BM_DECLARE_TEMP_BLOCK(tb)</a> if NULL - it will allocated (and de-allocated upon exit) </td></tr>
    <tr><td class="paramname">opt_mode</td><td>- optimization level </td></tr>
    <tr><td class="paramname">stat</td><td>- statistics of memory consumption and serialization stat can also be computed by <a class="el" href="classbm_1_1bvector.html#af30532c371bfdc8e2ba02bc2115b004d" title="Calculates bitvector statistics.">calc_stat()</a> but it would require an extra pass</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbm_1_1bvector.html#a05f1e977cb5e6208838afc7e7b69e5f0" title="Optimization mode Every next level means additional checks (better compression vs time)">optmode</a>, <a class="el" href="classbm_1_1bvector.html#aaa2d954f42ea75520b8795066302daab" title="Optimize sizes of GAP blocks.">optimize_gap_size</a>, <a class="el" href="classbm_1_1bvector.html#af30532c371bfdc8e2ba02bc2115b004d" title="Calculates bitvector statistics.">calc_stat</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="bv3vlogic_8cpp-example.html#a10">bv3vlogic.cpp</a>, <a class="el" href="bvsetalgebra_8cpp-example.html#a9">bvsetalgebra.cpp</a>, <a class="el" href="inv_list_8cpp-example.html#a30">inv_list.cpp</a>, <a class="el" href="sample11_8cpp-example.html#a11">sample11.cpp</a>, <a class="el" href="sample14_8cpp-example.html#a10">sample14.cpp</a>, <a class="el" href="sample21_8cpp-example.html#a3">sample21.cpp</a>, <a class="el" href="sample23_8cpp-example.html#a6">sample23.cpp</a>, <a class="el" href="sample26_8cpp-example.html#a14">sample26.cpp</a>, <a class="el" href="sample3_8cpp-example.html#a15">sample3.cpp</a>, <a class="el" href="sample4_8cpp-example.html#a15">sample4.cpp</a>, <a class="el" href="xsample01_8cpp-example.html#a71">xsample01.cpp</a>, <a class="el" href="xsample07_8cpp-example.html#a71">xsample07.cpp</a>, and <a class="el" href="xsample07a_8cpp-example.html#a56">xsample07a.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l03625">3625</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>, <a class="el" href="bm_8h_source.html#l03968">bm::bvector&lt; Alloc &gt;::calc_stat()</a>, <a class="el" href="bmconst_8h_source.html#l00085">bm::gap_levels</a>, <a class="el" href="bmfunc_8h_source.html#l00064">bm::bv_statistics::gap_levels</a>, <a class="el" href="bm_8h_source.html#l01080">bm::bvector&lt; Alloc &gt;::is_ro()</a>, <a class="el" href="bmfunc_8h_source.html#l00061">bm::bv_statistics::max_serialize_mem</a>, <a class="el" href="bmfunc_8h_source.html#l00062">bm::bv_statistics::memory_used</a>, and <a class="el" href="bmfunc_8h_source.html#l00092">bm::bv_statistics::reset()</a>.</p>

<p class="reference">Referenced by <a class="el" href="xsample07a_8cpp_source.html#l00973">compute_seq_group_union()</a>, <a class="el" href="sample11_8cpp_source.html#l00059">generate_bvector()</a>, <a class="el" href="xsample07a_8cpp_source.html#l00561">generate_k_mers()</a>, <a class="el" href="bv3vlogic_8cpp_source.html#l00164">GenerateDemoVector()</a>, <a class="el" href="sample3_8cpp_source.html#l00074">main()</a>, <a class="el" href="bvsetalgebra_8cpp_source.html#l00077">make_BLOB()</a>, <a class="el" href="sample4_8cpp_source.html#l00078">serialize_bvector()</a>, <a class="el" href="bv3vlogic_8cpp_source.html#l00090">Set3VL_ValueDemo()</a>, <a class="el" href="bv3vlogic_8cpp_source.html#l00117">Set3VL_ValueDemo2()</a>, <a class="el" href="xsample01_8cpp_source.html#l00555">speed_test_bv_index()</a>, <a class="el" href="xsample01_8cpp_source.html#l00614">speed_test_bvs_index()</a>, <a class="el" href="xsample01_8cpp_source.html#l00740">speed_test_sv_index()</a>, <a class="el" href="xsample01_8cpp_source.html#l00678">speed_test_vect_index()</a>, and <a class="el" href="inv__list_8cpp_source.html#l00343">write_as_bvector()</a>.</p>

</div>
</div>
<a id="aaa2d954f42ea75520b8795066302daab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa2d954f42ea75520b8795066302daab">&#9670;&nbsp;</a></span>optimize_gap_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::optimize_gap_size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optimize sizes of GAP blocks. </p>
<p >This method runs an analysis to find optimal GAP levels for the specific vector. Current GAP compression algorithm uses several fixed GAP sizes. By default bvector uses some reasonable preset. </p>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l03690">3690</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bm_8h_source.html#l03968">bm::bvector&lt; Alloc &gt;::calc_stat()</a>, <a class="el" href="bmconst_8h_source.html#l00085">bm::gap_levels</a>, <a class="el" href="bmfunc_8h_source.html#l08846">bm::improve_gap_levels()</a>, and <a class="el" href="bm_8h_source.html#l03716">bm::bvector&lt; Alloc &gt;::set_gap_levels()</a>.</p>

</div>
</div>
<a id="ac8ebec3020f30fdd4f20cc96b7d211a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8ebec3020f30fdd4f20cc96b7d211a5">&#9670;&nbsp;</a></span>optimize_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::optimize_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacebm.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *&#160;</td>
          <td class="paramname"><em>temp_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a05f1e977cb5e6208838afc7e7b69e5f0">optmode</a>&#160;</td>
          <td class="paramname"><em>opt_mode</em> = <code><a class="el" href="classbm_1_1bvector.html#a05f1e977cb5e6208838afc7e7b69e5f0a99b64b2444e1a8b22a5e89b02dca6001">opt_compress</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Run partial vector optimization for the area [left..right] (specified in bit coordinates)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>- bit index to optimize from (approximate, rounded up to a nearest block) </td></tr>
    <tr><td class="paramname">right</td><td>- bit index to optimize to Please note that left and right define range in bit coordinates but later rounded to blocks </td></tr>
    <tr><td class="paramname">temp_block</td><td>- external scratch memory (MUST be pre-allocated) </td></tr>
    <tr><td class="paramname">opt_mode</td><td>- optimization level</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbm_1_1bvector.html#a622e6827d799a561e2f0db28f7ac19d2" title="Optimize memory bitvector&#39;s memory allocation.">optimize</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l03661">3661</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>, <a class="el" href="bmfunc_8h_source.html#l00163">bm::get_block_coord()</a>, <a class="el" href="bm_8h_source.html#l01080">bm::bvector&lt; Alloc &gt;::is_ro()</a>, and <a class="el" href="bmconst_8h_source.html#l00056">bm::set_block_shift</a>.</p>

</div>
</div>
<a id="a65b175606ea472e33b9b6af1f7b04ee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65b175606ea472e33b9b6af1f7b04ee7">&#9670;&nbsp;</a></span>rank()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::rank </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html#ac9ed62250af37ade811aaf20b7a8d9a2">rs_index_type</a> &amp;&#160;</td>
          <td class="paramname"><em>rs_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns rank of specified bit position (same as <a class="el" href="classbm_1_1bvector.html#ad3e0e88f17cc86b58e006186955c461b" title="Returns count of 1 bits (population) in [0..right] range.">count_to()</a>) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>- index of bit to rank </td></tr>
    <tr><td class="paramname">rs_idx</td><td>- rank-select index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>population count in the range [0..n] </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbm_1_1bvector.html#adfb63744a9d6039d9e8daa38cf21e3c6" title="compute running total of all blocks in bit vector (rank-select index)">build_rs_index</a> </dd>
<dd>
<a class="el" href="classbm_1_1bvector.html#a649167f4b128d053d6312a3a00114403" title="popcount in [0..right] range if test(right) == true">count_to_test</a>, <a class="el" href="classbm_1_1bvector.html#a7ded07c26c000250baf5215c29c3b602" title="select bit-vector position for the specified rank(bitcount)">select</a>, <a class="el" href="classbm_1_1bvector.html#a65b175606ea472e33b9b6af1f7b04ee7" title="Returns rank of specified bit position (same as count_to())">rank</a>, <a class="el" href="classbm_1_1bvector.html#abc7ead9fd4044f190d45946762a1011a" title="Returns rank corrceted by the requested border value (as -1)">rank_corrected</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01445">1445</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bm_8h_source.html#l03079">bm::bvector&lt; Alloc &gt;::count_to()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l07919">bm::bvector&lt; Alloc &gt;::enumerator::skip()</a>, and <a class="el" href="bm_8h_source.html#l00690">bm::bvector&lt; Alloc &gt;::enumerator::skip_to_rank()</a>.</p>

</div>
</div>
<a id="abc7ead9fd4044f190d45946762a1011a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc7ead9fd4044f190d45946762a1011a">&#9670;&nbsp;</a></span>rank_corrected()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt;::<a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::rank_corrected </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html#ac9ed62250af37ade811aaf20b7a8d9a2">rs_index_type</a> &amp;&#160;</td>
          <td class="paramname"><em>rs_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns rank corrceted by the requested border value (as -1) </p>
<p >This is rank function (bit-count) minus value of bit 'n' if bit-n is true function returns <a class="el" href="classbm_1_1bvector.html#a65b175606ea472e33b9b6af1f7b04ee7" title="Returns rank of specified bit position (same as count_to())">rank()</a>-1 if false returns <a class="el" href="classbm_1_1bvector.html#a65b175606ea472e33b9b6af1f7b04ee7" title="Returns rank of specified bit position (same as count_to())">rank()</a> faster than <a class="el" href="classbm_1_1bvector.html#a65b175606ea472e33b9b6af1f7b04ee7" title="Returns rank of specified bit position (same as count_to())">rank()</a> + <a class="el" href="classbm_1_1bvector.html#a16d902c3df4aa6aa88d8e137af4a4b9b" title="returns true if bit n is set and false is bit n is 0.">test()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>- index of bit to rank </td></tr>
    <tr><td class="paramname">rs_idx</td><td>- rank-select index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>population count in the range [0..n] corrected as -1 by the value of n </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbm_1_1bvector.html#adfb63744a9d6039d9e8daa38cf21e3c6" title="compute running total of all blocks in bit vector (rank-select index)">build_rs_index</a> </dd>
<dd>
<a class="el" href="classbm_1_1bvector.html#a649167f4b128d053d6312a3a00114403" title="popcount in [0..right] range if test(right) == true">count_to_test</a>, <a class="el" href="classbm_1_1bvector.html#a7ded07c26c000250baf5215c29c3b602" title="select bit-vector position for the specified rank(bitcount)">select</a>, <a class="el" href="classbm_1_1bvector.html#a65b175606ea472e33b9b6af1f7b04ee7" title="Returns rank of specified bit position (same as count_to())">rank</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l03188">3188</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>, <a class="el" href="bmdef_8h_source.html#l00191">BM_IS_GAP</a>, <a class="el" href="bmdef_8h_source.html#l00189">BMGAP_PTR</a>, <a class="el" href="bmdef_8h_source.html#l00158">FULL_BLOCK_FAKE_ADDR</a>, <a class="el" href="bmfunc_8h_source.html#l00163">bm::get_block_coord()</a>, <a class="el" href="bmconst_8h_source.html#l00109">bm::id_max</a>, <a class="el" href="bmconst_8h_source.html#l00057">bm::set_block_mask</a>, <a class="el" href="bmconst_8h_source.html#l00056">bm::set_block_shift</a>, <a class="el" href="bmconst_8h_source.html#l00073">bm::set_word_mask</a>, and <a class="el" href="bmconst_8h_source.html#l00072">bm::set_word_shift</a>.</p>

</div>
</div>
<a id="af491626f7200e6ab4e3c9e8d5f7d80fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af491626f7200e6ab4e3c9e8d5f7d80fb">&#9670;&nbsp;</a></span>recalc_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::recalc_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Recalculate bitcount (deprecated) </p>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01489">1489</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bm_8h_source.html#l02399">bm::bvector&lt; Alloc &gt;::count()</a>.</p>

</div>
</div>
<a id="aecf6a1e30257fa59d2a25908ad7b4d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecf6a1e30257fa59d2a25908ad7b4d4e">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector.html">bvector</a>&lt;Alloc&gt;&amp; <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears every bit in the bitvector. </p>
<dl class="section return"><dt>Returns</dt><dd>*this; </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="sample12_8cpp-example.html#a10">sample12.cpp</a>, and <a class="el" href="svsample06_8cpp-example.html#a13">svsample06.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01279">1279</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bm_8h_source.html#l04139">bm::bvector&lt; Alloc &gt;::clear()</a>.</p>

<p class="reference">Referenced by <a class="el" href="sample12_8cpp_source.html#l00098">bv_set_bit_test()</a>, and <a class="el" href="svsample06_8cpp_source.html#l00073">generate_test_set()</a>.</p>

</div>
</div>
<a id="a56b7573c759e51c8943cf95a82a5b9d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56b7573c759e51c8943cf95a82a5b9d6">&#9670;&nbsp;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td>
          <td class="paramname"><em>new_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change size of the bvector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_size</td><td>- new size in bits </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="bvsetalgebra_8cpp-example.html#a14">bvsetalgebra.cpp</a>, <a class="el" href="strsvsample06_8cpp-example.html#a13">strsvsample06.cpp</a>, <a class="el" href="xsample01_8cpp-example.html#a68">xsample01.cpp</a>, and <a class="el" href="xsample05_8cpp-example.html#a25">xsample05.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l02461">2461</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>, <a class="el" href="bm_8h_source.html#l01080">bm::bvector&lt; Alloc &gt;::is_ro()</a>, and <a class="el" href="bm_8h_source.html#l02366">bm::bvector&lt; Alloc &gt;::set_range()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l04139">bm::bvector&lt; Alloc &gt;::clear()</a>, <a class="el" href="xsample01_8cpp_source.html#l00421">convert_bv2sv()</a>, <a class="el" href="bm_8h_source.html#l02301">bm::bvector&lt; Alloc &gt;::copy()</a>, <a class="el" href="bvsetalgebra_8cpp_source.html#l00221">DemoAND()</a>, <a class="el" href="bvsetalgebra_8cpp_source.html#l00513">DemoAND_OR()</a>, <a class="el" href="bvsetalgebra_8cpp_source.html#l00603">DemoINV()</a>, <a class="el" href="bvsetalgebra_8cpp_source.html#l00096">DemoOR()</a>, <a class="el" href="bvsetalgebra_8cpp_source.html#l00401">DemoSUB()</a>, <a class="el" href="bvsetalgebra_8cpp_source.html#l00330">DemoXOR()</a>, <a class="el" href="bm_8h_source.html#l04095">bm::bvector&lt; Alloc &gt;::keep()</a>, <a class="el" href="strsvsample06_8cpp_source.html#l00047">main()</a>, <a class="el" href="bm_8h_source.html#l00414">bm::bvector&lt; Alloc &gt;::insert_iterator::operator=()</a>, <a class="el" href="bm_8h_source.html#l01024">bm::bvector&lt; Alloc &gt;::operator[]()</a>, <a class="el" href="xsample05_8cpp_source.html#l00270">pick_benchmark_set()</a>, <a class="el" href="bm_8h_source.html#l04217">bm::bvector&lt; Alloc &gt;::set_bit()</a>, <a class="el" href="bm_8h_source.html#l04189">bm::bvector&lt; Alloc &gt;::set_bit_conditional()</a>, <a class="el" href="bm_8h_source.html#l02366">bm::bvector&lt; Alloc &gt;::set_range()</a>, <a class="el" href="bmsparsevec__algo_8h_source.html#l00169">bm::sparse_vector_find_first_mismatch()</a>, <a class="el" href="bmsparsevec__algo_8h_source.html#l00347">bm::sparse_vector_find_mismatch()</a>, and <a class="el" href="bm_8h_source.html#l02484">bm::bvector&lt; Alloc &gt;::sync_size()</a>.</p>

</div>
</div>
<a id="a7ded07c26c000250baf5215c29c3b602"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ded07c26c000250baf5215c29c3b602">&#9670;&nbsp;</a></span>select()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::select </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td>
          <td class="paramname"><em>rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html#ac9ed62250af37ade811aaf20b7a8d9a2">rs_index_type</a> &amp;&#160;</td>
          <td class="paramname"><em>rs_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>select bit-vector position for the specified rank(bitcount) </p>
<p >Rank based search, counts number of 1s from specified position until finds the ranked position relative to start from position. Uses In other words: range population count between from and pos == rank.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rank</td><td>- rank to find (bitcount) </td></tr>
    <tr><td class="paramname">pos</td><td>- position with speciefied rank (relative to from position) [out] </td></tr>
    <tr><td class="paramname">rs_idx</td><td>- block count structure to accelerate rank search</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>running_count_blocks, <a class="el" href="classbm_1_1bvector.html#a9b2b0eb6ec338ab789ec6508cfab7ff0" title="Find bit-vector position for the specified rank(bitcount)">find_rank</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if requested rank was found </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="sample17_8cpp-example.html#a2">sample17.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l05066">5066</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmfunc_8h_source.html#l08673">bm::block_find_rank()</a>, <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>, <a class="el" href="bmdef_8h_source.html#l00158">FULL_BLOCK_FAKE_ADDR</a>, <a class="el" href="bmconst_8h_source.html#l00081">bm::gap_max_bits</a>, <a class="el" href="bmfunc_8h_source.html#l00163">bm::get_block_coord()</a>, and <a class="el" href="bmconst_8h_source.html#l00055">bm::set_block_size</a>.</p>

<p class="reference">Referenced by <a class="el" href="sample17_8cpp_source.html#l00036">main()</a>.</p>

</div>
</div>
<a id="a948743fdaf254dfc9d946b75c5e301a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a948743fdaf254dfc9d946b75c5e301a0">&#9670;&nbsp;</a></span>set() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp; <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::set</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets every bit in this bitset to 1. </p>
<dl class="section return"><dt>Returns</dt><dd>*this </dd></dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l04167">4167</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>, <a class="el" href="bm_8h_source.html#l01080">bm::bvector&lt; Alloc &gt;::is_ro()</a>, and <a class="el" href="bm_8h_source.html#l02366">bm::bvector&lt; Alloc &gt;::set_range()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l05226">bm::bvector&lt; Alloc &gt;::insert()</a>.</p>

</div>
</div>
<a id="ab48294badc50633015b10ce9b890772f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab48294badc50633015b10ce9b890772f">&#9670;&nbsp;</a></span>set() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> *&#160;</td>
          <td class="paramname"><em>ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td>
          <td class="paramname"><em>ids_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bvector.html#ga04a7a7cda4bf04cd107e198b3b1e4ed8">bm::sort_order</a>&#160;</td>
          <td class="paramname"><em>so</em> = <code><a class="el" href="group__bvector.html#gga04a7a7cda4bf04cd107e198b3b1e4ed8a981e9b62bb43cc0388f268f1041f9293">bm::BM_UNKNOWN</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set list of bits in this bitset to 1. </p>
<p >Method implements optimized bulk setting of multiple bits at once. The best results are achieved when the imput comes sorted. This is equivalent of OR (Set Union), argument set as an array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ids</td><td>- pointer on array of indexes to set </td></tr>
    <tr><td class="paramname">ids_size</td><td>- size of the input (ids) </td></tr>
    <tr><td class="paramname">so</td><td>- sort order (use BM_SORTED for faster load)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbm_1_1bvector.html#ae79e966df54b3083fb14519f74a800af" title="Keep list of bits in this bitset, others are cleared.">keep</a>, <a class="el" href="classbm_1_1bvector.html#ac6f13fa4ba188585e5c5d4e89843a44e" title="clear list of bits in this bitset">clear</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l04078">4078</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>, <a class="el" href="bm_8h_source.html#l01080">bm::bvector&lt; Alloc &gt;::is_ro()</a>, and <a class="el" href="bm_8h_source.html#l02484">bm::bvector&lt; Alloc &gt;::sync_size()</a>.</p>

</div>
</div>
<a id="a52b4259a5cc4ebd8953832c696e24f02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52b4259a5cc4ebd8953832c696e24f02">&#9670;&nbsp;</a></span>set() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp; <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>val</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets bit n if val is true, clears bit n if val is false. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>- index of the bit to be set </td></tr>
    <tr><td class="paramname">val</td><td>- new bit value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="bvsample01_64_8cpp-example.html#a3">bvsample01_64.cpp</a>, <a class="el" href="bvsetalgebra_8cpp-example.html#a19">bvsetalgebra.cpp</a>, <a class="el" href="inv_list_8cpp-example.html#a28">inv_list.cpp</a>, <a class="el" href="sample10_8cpp-example.html#a3">sample10.cpp</a>, <a class="el" href="sample11_8cpp-example.html#a8">sample11.cpp</a>, <a class="el" href="sample12_8cpp-example.html#a17">sample12.cpp</a>, <a class="el" href="sample14_8cpp-example.html#a3">sample14.cpp</a>, <a class="el" href="sample15_8cpp-example.html#a3">sample15.cpp</a>, <a class="el" href="sample2_8cpp-example.html#a5">sample2.cpp</a>, <a class="el" href="sample26_8cpp-example.html#a3">sample26.cpp</a>, <a class="el" href="svsample07a_8cpp-example.html#a21">svsample07a.cpp</a>, <a class="el" href="svsample08_8cpp-example.html#a14">svsample08.cpp</a>, <a class="el" href="xsample05_8cpp-example.html#a27">xsample05.cpp</a>, and <a class="el" href="xsample07a_8cpp-example.html#a63">xsample07a.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l04178">4178</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>, <a class="el" href="bm_8h_source.html#l01080">bm::bvector&lt; Alloc &gt;::is_ro()</a>, and <a class="el" href="bm_8h_source.html#l04217">bm::bvector&lt; Alloc &gt;::set_bit()</a>.</p>

<p class="reference">Referenced by <a class="el" href="xsample07a_8cpp_source.html#l01220">CKMerAcc::add()</a>, <a class="el" href="sample12_8cpp_source.html#l00172">bvector_bulk_set_test()</a>, <a class="el" href="xsample07a_8cpp_source.html#l00731">CSeqGroup::clear_member()</a>, <a class="el" href="xsample07a_8cpp_source.html#l00689">CSeqGroup::CSeqGroup()</a>, <a class="el" href="bvsetalgebra_8cpp_source.html#l00096">DemoOR()</a>, <a class="el" href="xsample07a_8cpp_source.html#l00994">CSeqClusters::elect_leaders()</a>, <a class="el" href="sample14_8cpp_source.html#l00046">fill_bvector()</a>, <a class="el" href="sample11_8cpp_source.html#l00059">generate_bvector()</a>, <a class="el" href="bvsample01__64_8cpp_source.html#l00051">main()</a>, <a class="el" href="xsample05_8cpp_source.html#l00270">pick_benchmark_set()</a>, <a class="el" href="xsample05_8cpp_source.html#l00318">run_benchmark()</a>, and <a class="el" href="inv__list_8cpp_source.html#l00343">write_as_bvector()</a>.</p>

</div>
</div>
<a id="a5caf8104ebf999f36fc1f812aaff0bd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5caf8104ebf999f36fc1f812aaff0bd5">&#9670;&nbsp;</a></span>set_allocator_pool()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::set_allocator_pool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a2c8990a2147fdc3e6094011e77e559e8">allocator_pool_type</a> *&#160;</td>
          <td class="paramname"><em>pool_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set allocator pool for local (non-th readed) memory cyclic(lots of alloc-free ops) opertations. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="xsample07a_8cpp-example.html#a123">xsample07a.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01060">1060</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="xsample07a_8cpp_source.html#l01245">assign_to_best_cluster()</a>, and <a class="el" href="xsample07a_8cpp_source.html#l01315">assign_to_best_cluster_union()</a>.</p>

</div>
</div>
<a id="a6dfc9af9e9041405cbd29394121c4eb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dfc9af9e9041405cbd29394121c4eb6">&#9670;&nbsp;</a></span>set_bit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::set_bit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>val</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets bit n. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>- index of the bit to be set. </td></tr>
    <tr><td class="paramname">val</td><td>- new bit value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if bit was changed </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="sample12_8cpp-example.html#a9">sample12.cpp</a>, <a class="el" href="sample3_8cpp-example.html#a3">sample3.cpp</a>, <a class="el" href="sample4_8cpp-example.html#a3">sample4.cpp</a>, and <a class="el" href="xsample01_8cpp-example.html#a41">xsample01.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l04217">4217</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>, <a class="el" href="bmdef_8h_source.html#l00338">BM_ASSERT_THROW</a>, <a class="el" href="bmconst_8h_source.html#l00109">bm::id_max</a>, <a class="el" href="bm_8h_source.html#l01080">bm::bvector&lt; Alloc &gt;::is_ro()</a>, <a class="el" href="bm_8h_source.html#l02461">bm::bvector&lt; Alloc &gt;::resize()</a>, and <a class="el" href="bm_8h_source.html#l04426">bm::bvector&lt; Alloc &gt;::set_bit_no_check()</a>.</p>

<p class="reference">Referenced by <a class="el" href="sample12_8cpp_source.html#l00098">bv_set_bit_test()</a>, <a class="el" href="bm_8h_source.html#l01259">bm::bvector&lt; Alloc &gt;::clear_bit()</a>, <a class="el" href="sample3_8cpp_source.html#l00048">fill_bvector()</a>, <a class="el" href="xsample01_8cpp_source.html#l00219">generate_random_vector()</a>, and <a class="el" href="bm_8h_source.html#l04178">bm::bvector&lt; Alloc &gt;::set()</a>.</p>

</div>
</div>
<a id="a2ad7f4b32fd00b9f267db403d13fd53a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ad7f4b32fd00b9f267db403d13fd53a">&#9670;&nbsp;</a></span>set_bit_and()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::set_bit_and </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>val</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets bit n using bit AND with the provided value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>- index of the bit to be set. </td></tr>
    <tr><td class="paramname">val</td><td>- new bit value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if bit was changed </dd></dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l04203">4203</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bm_8h_source.html#l04619">bm::bvector&lt; Alloc &gt;::and_bit_no_check()</a>, <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>, <a class="el" href="bmdef_8h_source.html#l00338">BM_ASSERT_THROW</a>, and <a class="el" href="bm_8h_source.html#l01080">bm::bvector&lt; Alloc &gt;::is_ro()</a>.</p>

</div>
</div>
<a id="ad93c93b81d5d1de52571c156fb3142a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad93c93b81d5d1de52571c156fb3142a8">&#9670;&nbsp;</a></span>set_bit_conditional()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::set_bit_conditional </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>condition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets bit n only if current value equals the condition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>- index of the bit to be set. </td></tr>
    <tr><td class="paramname">val</td><td>- new bit value </td></tr>
    <tr><td class="paramname">condition</td><td>- expected current value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if bit was changed </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="sample12_8cpp-example.html#a22">sample12.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l04189">4189</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmconst_8h_source.html#l00109">bm::id_max</a>, <a class="el" href="bm_8h_source.html#l02461">bm::bvector&lt; Alloc &gt;::resize()</a>, and <a class="el" href="bm_8h_source.html#l04567">bm::bvector&lt; Alloc &gt;::set_bit_conditional_impl()</a>.</p>

</div>
</div>
<a id="a34e3997ef4b9c81aab8fccab4c79e00f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34e3997ef4b9c81aab8fccab4c79e00f">&#9670;&nbsp;</a></span>set_bit_conditional_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::set_bit_conditional_impl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>condition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l04567">4567</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00189">BMGAP_PTR</a>, <a class="el" href="bm_8h_source.html#l04494">bm::bvector&lt; Alloc &gt;::gap_block_set()</a>, <a class="el" href="bm_8h_source.html#l01932">bm::bvector&lt; Alloc &gt;::get_new_blocks_strat()</a>, <a class="el" href="bmdef_8h_source.html#l00161">IS_VALID_ADDR</a>, <a class="el" href="bmconst_8h_source.html#l00057">bm::set_block_mask</a>, <a class="el" href="bmconst_8h_source.html#l00056">bm::set_block_shift</a>, <a class="el" href="bmconst_8h_source.html#l00073">bm::set_word_mask</a>, and <a class="el" href="bmconst_8h_source.html#l00072">bm::set_word_shift</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l04189">bm::bvector&lt; Alloc &gt;::set_bit_conditional()</a>.</p>

</div>
</div>
<a id="aff4c0900eed72eaccff6f5804e33ce97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff4c0900eed72eaccff6f5804e33ce97">&#9670;&nbsp;</a></span>set_bit_no_check() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::set_bit_no_check </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set bit without checking preconditions (size, etc) </p>
<p >Fast set bit method, without safety net. Make sure you call <a class="el" href="classbm_1_1bvector.html#aaceb8d31d9da05f977de5c6a6cd62e24" title="Explicit post-construction initialization. Must be caled to make sure safe use of *_no_check() method...">bvector&lt;&gt;::init()</a> before setting bits with this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>- bit number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="sample12_8cpp-example.html#a13">sample12.cpp</a>, <a class="el" href="svsample06_8cpp-example.html#a16">svsample06.cpp</a>, <a class="el" href="xsample03_8cpp-example.html#a22">xsample03.cpp</a>, and <a class="el" href="xsample07a_8cpp-example.html#a68">xsample07a.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l04426">4426</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>, <a class="el" href="bmdef_8h_source.html#l00338">BM_ASSERT_THROW</a>, <a class="el" href="bmdef_8h_source.html#l00189">BMGAP_PTR</a>, <a class="el" href="bm_8h_source.html#l04513">bm::bvector&lt; Alloc &gt;::gap_block_set_no_ret()</a>, <a class="el" href="bm_8h_source.html#l01932">bm::bvector&lt; Alloc &gt;::get_new_blocks_strat()</a>, <a class="el" href="bmconst_8h_source.html#l00109">bm::id_max</a>, <a class="el" href="bm_8h_source.html#l01080">bm::bvector&lt; Alloc &gt;::is_ro()</a>, <a class="el" href="bmdef_8h_source.html#l00161">IS_VALID_ADDR</a>, <a class="el" href="bmconst_8h_source.html#l00057">bm::set_block_mask</a>, <a class="el" href="bmconst_8h_source.html#l00056">bm::set_block_shift</a>, <a class="el" href="bmconst_8h_source.html#l00073">bm::set_word_mask</a>, and <a class="el" href="bmconst_8h_source.html#l00072">bm::set_word_shift</a>.</p>

<p class="reference">Referenced by <a class="el" href="xsample07a_8cpp_source.html#l00705">CSeqGroup::add_member()</a>, <a class="el" href="xsample07a_8cpp_source.html#l00711">CSeqGroup::add_member_sync()</a>, <a class="el" href="bm_8h_source.html#l02499">bm::bvector&lt; Alloc &gt;::build_rs_index()</a>, <a class="el" href="sample12_8cpp_source.html#l00128">bv_set_bit_no_check_test()</a>, <a class="el" href="bm_8h_source.html#l00970">bm::bvector&lt; Alloc &gt;::bvector()</a>, <a class="el" href="bm_8h_source.html#l05429">bm::bvector&lt; Alloc &gt;::erase()</a>, <a class="el" href="bm_8h_source.html#l04048">bm::bvector&lt; Alloc &gt;::fill_alloc_digest()</a>, <a class="el" href="bm_8h_source.html#l05226">bm::bvector&lt; Alloc &gt;::insert()</a>, <a class="el" href="bm_8h_source.html#l03540">bm::bvector&lt; Alloc &gt;::invert()</a>, <a class="el" href="xsample03_8cpp_source.html#l00218">load_snp_report()</a>, <a class="el" href="sample12_8cpp_source.html#l00189">main()</a>, <a class="el" href="bm_8h_source.html#l00414">bm::bvector&lt; Alloc &gt;::insert_iterator::operator=()</a>, <a class="el" href="xsample03_8cpp_source.html#l00349">run_benchmark()</a>, <a class="el" href="bm_8h_source.html#l04217">bm::bvector&lt; Alloc &gt;::set_bit()</a>, and <a class="el" href="svsample06_8cpp_source.html#l00106">vector_search()</a>.</p>

</div>
</div>
<a id="aab4aa312f9de74d4256790680ac5b663"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab4aa312f9de74d4256790680ac5b663">&#9670;&nbsp;</a></span>set_bit_no_check() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::set_bit_no_check </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set specified bit without checking preconditions (size, etc) </p>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l04377">4377</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>, <a class="el" href="bmdef_8h_source.html#l00338">BM_ASSERT_THROW</a>, <a class="el" href="bmdef_8h_source.html#l00189">BMGAP_PTR</a>, <a class="el" href="bm_8h_source.html#l04494">bm::bvector&lt; Alloc &gt;::gap_block_set()</a>, <a class="el" href="bm_8h_source.html#l01932">bm::bvector&lt; Alloc &gt;::get_new_blocks_strat()</a>, <a class="el" href="bmconst_8h_source.html#l00109">bm::id_max</a>, <a class="el" href="bm_8h_source.html#l01080">bm::bvector&lt; Alloc &gt;::is_ro()</a>, <a class="el" href="bmdef_8h_source.html#l00161">IS_VALID_ADDR</a>, <a class="el" href="bmconst_8h_source.html#l00057">bm::set_block_mask</a>, <a class="el" href="bmconst_8h_source.html#l00056">bm::set_block_shift</a>, <a class="el" href="bmconst_8h_source.html#l00073">bm::set_word_mask</a>, and <a class="el" href="bmconst_8h_source.html#l00072">bm::set_word_shift</a>.</p>

</div>
</div>
<a id="a14f9b220fec8e7b65e4e5ed2832af96b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14f9b220fec8e7b65e4e5ed2832af96b">&#9670;&nbsp;</a></span>set_gap_levels()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::set_gap_levels </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacebm.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *&#160;</td>
          <td class="paramname"><em>glevel_len</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets new GAP lengths table. All GAP blocks will be reallocated to match the new scheme. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">glevel_len</td><td>- pointer on C-style array keeping GAP block sizes. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l03716">3716</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>, <a class="el" href="bmfunc_8h_source.html#l01859">bm::for_each_nzblock()</a>, and <a class="el" href="bm_8h_source.html#l01080">bm::bvector&lt; Alloc &gt;::is_ro()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l03690">bm::bvector&lt; Alloc &gt;::optimize_gap_size()</a>.</p>

</div>
</div>
<a id="a653ee052b297a49c35344704df67a452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a653ee052b297a49c35344704df67a452">&#9670;&nbsp;</a></span>set_new_blocks_strat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::set_new_blocks_strat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bvector.html#gad0b87b3b7292383a864d27feaf1c9eff">strategy</a>&#160;</td>
          <td class="paramname"><em>strat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets new blocks allocation strategy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strat</td><td>- Strategy code 0 - bitblocks allocation only. 1 - Blocks mutation mode (adaptive algorithm) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="sample3_8cpp-example.html#a13">sample3.cpp</a>, and <a class="el" href="sample4_8cpp-example.html#a17">sample4.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01924">1924</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="sample3_8cpp_source.html#l00074">main()</a>.</p>

</div>
</div>
<a id="aafb2ecaa1a55856533e6b4afbf788eae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafb2ecaa1a55856533e6b4afbf788eae">&#9670;&nbsp;</a></span>set_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp; <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::set_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets all bits in the specified closed interval [left,right] Interval must be inside the bvector's size. This method DOES NOT resize vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>- interval start </td></tr>
    <tr><td class="paramname">right</td><td>- interval end (closed interval) </td></tr>
    <tr><td class="paramname">value</td><td>- value to set interval in</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbm_1_1bvector.html#a81d21e99befe6e54a0fb33c0778cf1f0" title="Sets all bits to zero in the specified closed interval [left,right] Interval must be inside the bvect...">clear_range</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="sample11_8cpp-example.html#a9">sample11.cpp</a>, <a class="el" href="sample12_8cpp-example.html#a23">sample12.cpp</a>, <a class="el" href="sample23_8cpp-example.html#a5">sample23.cpp</a>, <a class="el" href="strsvsample05_8cpp-example.html#a19">strsvsample05.cpp</a>, <a class="el" href="strsvsample07_8cpp-example.html#a15">strsvsample07.cpp</a>, <a class="el" href="xsample07a_8cpp-example.html#a127">xsample07a.cpp</a>, and <a class="el" href="xsample08_8cpp-example.html#a21">xsample08.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l02366">2366</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>, <a class="el" href="bmdef_8h_source.html#l00338">BM_ASSERT_THROW</a>, <a class="el" href="bmconst_8h_source.html#l00109">bm::id_max</a>, <a class="el" href="bm_8h_source.html#l01080">bm::bvector&lt; Alloc &gt;::is_ro()</a>, <a class="el" href="bm_8h_source.html#l02461">bm::bvector&lt; Alloc &gt;::resize()</a>, <a class="el" href="bm_8h_source.html#l02366">bm::bvector&lt; Alloc &gt;::set_range()</a>, and <a class="el" href="bm_8h_source.html#l00659">bm::bvector&lt; Alloc &gt;::enumerator::value()</a>.</p>

<p class="reference">Referenced by <a class="el" href="xsample08_8cpp_source.html#l00169">add_object()</a>, <a class="el" href="sample11_8cpp_source.html#l00239">bv_count_and()</a>, <a class="el" href="bm_8h_source.html#l01228">bm::bvector&lt; Alloc &gt;::clear_range()</a>, <a class="el" href="bm_8h_source.html#l06533">bm::bvector&lt; Alloc &gt;::combine_operation()</a>, <a class="el" href="xsample07a_8cpp_source.html#l01420">compute_jaccard_clusters()</a>, <a class="el" href="sample11_8cpp_source.html#l00059">generate_bvector()</a>, <a class="el" href="sample22_8cpp_source.html#l00072">main()</a>, <a class="el" href="bm_8h_source.html#l02461">bm::bvector&lt; Alloc &gt;::resize()</a>, <a class="el" href="bm_8h_source.html#l04167">bm::bvector&lt; Alloc &gt;::set()</a>, and <a class="el" href="bm_8h_source.html#l02366">bm::bvector&lt; Alloc &gt;::set_range()</a>.</p>

</div>
</div>
<a id="a9730694fb531221dcde1b685a0b2e4b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9730694fb531221dcde1b685a0b2e4b1">&#9670;&nbsp;</a></span>shift_left()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::shift_left</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shift left by 1 bit, fill with zero return carry out. </p>
<dl class="section return"><dt>Returns</dt><dd>Carry over bit value (1 or 0) </dd></dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l05215">5215</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>, <a class="el" href="bm_8h_source.html#l05429">bm::bvector&lt; Alloc &gt;::erase()</a>, <a class="el" href="bm_8h_source.html#l01080">bm::bvector&lt; Alloc &gt;::is_ro()</a>, and <a class="el" href="bm_8h_source.html#l01514">bm::bvector&lt; Alloc &gt;::test()</a>.</p>

</div>
</div>
<a id="aacf96380ec223d52340a60ec57c8bdbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacf96380ec223d52340a60ec57c8bdbd">&#9670;&nbsp;</a></span>shift_right()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::shift_right</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shift right by 1 bit, fill with zero return carry out. </p>
<dl class="section return"><dt>Returns</dt><dd>Carry over bit value (1 or 0) </dd></dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l05206">5206</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>, <a class="el" href="bm_8h_source.html#l05226">bm::bvector&lt; Alloc &gt;::insert()</a>, and <a class="el" href="bm_8h_source.html#l01080">bm::bvector&lt; Alloc &gt;::is_ro()</a>.</p>

<p class="reference">Referenced by <a class="el" href="xsample04_8cpp_source.html#l00250">DNA_FingerprintScanner::Find()</a>.</p>

</div>
</div>
<a id="a2f4d04c5a506faa42a6ce36dfc6c445b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f4d04c5a506faa42a6ce36dfc6c445b">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a> <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns bvector's capacity (number of bits it can store) </p>
<p >return current size of the vector (bits) </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="bvsetalgebra_8cpp-example.html#a5">bvsetalgebra.cpp</a>, and <a class="el" href="xsample05_8cpp-example.html#a29">xsample05.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01312">1312</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l02301">bm::bvector&lt; Alloc &gt;::copy()</a>, <a class="el" href="xsample07a_8cpp_source.html#l00561">generate_k_mers()</a>, <a class="el" href="bm_8h_source.html#l00414">bm::bvector&lt; Alloc &gt;::insert_iterator::operator=()</a>, <a class="el" href="bvsetalgebra_8cpp_source.html#l00064">print_bvector()</a>, <a class="el" href="xsample05_8cpp_source.html#l00318">run_benchmark()</a>, and <a class="el" href="bmsparsevec__algo_8h_source.html#l00347">bm::sparse_vector_find_mismatch()</a>.</p>

</div>
</div>
<a id="a9764b5a36f4b012d1e4b4dbef4e85d0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9764b5a36f4b012d1e4b4dbef4e85d0e">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html">bvector</a>&lt; Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bvect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exchanges content of bv and this bvector. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="sample12_8cpp-example.html#a26">sample12.cpp</a>, <a class="el" href="sample26_8cpp-example.html#a19">sample26.cpp</a>, and <a class="el" href="xsample07a_8cpp-example.html#a95">xsample07a.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l03956">3956</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmutil_8h_source.html#l00536">bm::xor_swap()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l07841">bm::bvector&lt; Alloc &gt;::freeze()</a>, <a class="el" href="sample12_8cpp_source.html#l00189">main()</a>, and <a class="el" href="xsample07a_8cpp_source.html#l00822">CSeqClusters::take_group()</a>.</p>

</div>
</div>
<a id="a4c6c213804cd440ce15ede3d374f0c69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c6c213804cd440ce15ede3d374f0c69">&#9670;&nbsp;</a></span>sync_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::sync_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Syncronize size if it got extended due to bulk import. </p>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l02484">2484</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bmdef_8h_source.html#l00139">BM_ASSERT</a>, <a class="el" href="bm_8h_source.html#l04694">bm::bvector&lt; Alloc &gt;::find_reverse()</a>, <a class="el" href="bmconst_8h_source.html#l00109">bm::id_max</a>, <a class="el" href="bm_8h_source.html#l01080">bm::bvector&lt; Alloc &gt;::is_ro()</a>, and <a class="el" href="bm_8h_source.html#l02461">bm::bvector&lt; Alloc &gt;::resize()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l00566">bm::bvector&lt; Alloc &gt;::bulk_insert_iterator::flush()</a>, and <a class="el" href="bm_8h_source.html#l04078">bm::bvector&lt; Alloc &gt;::set()</a>.</p>

</div>
</div>
<a id="a16d902c3df4aa6aa88d8e137af4a4b9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16d902c3df4aa6aa88d8e137af4a4b9b">&#9670;&nbsp;</a></span>test()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbm_1_1bvector.html">bm::bvector</a>&lt; Alloc &gt;::test </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns true if bit n is set and false is bit n is 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>- Index of the bit to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bit value (1 or 0) </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="bv3vlogic_8cpp-example.html#a5">bv3vlogic.cpp</a>, <a class="el" href="sample15_8cpp-example.html#a7">sample15.cpp</a>, <a class="el" href="sample18a_8cpp-example.html#a4">sample18a.cpp</a>, <a class="el" href="svsample06_8cpp-example.html#a30">svsample06.cpp</a>, <a class="el" href="svsample07a_8cpp-example.html#a20">svsample07a.cpp</a>, <a class="el" href="xsample03_8cpp-example.html#a21">xsample03.cpp</a>, <a class="el" href="xsample05_8cpp-example.html#a26">xsample05.cpp</a>, and <a class="el" href="xsample07a_8cpp-example.html#a110">xsample07a.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bm_8h_source.html#l01514">1514</a> of file <a class="el" href="bm_8h_source.html">bm.h</a>.</p>

<p class="reference">References <a class="el" href="bm_8h_source.html#l03592">bm::bvector&lt; Alloc &gt;::get_bit()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bm_8h_source.html#l03413">bm::bvector&lt; Alloc &gt;::any_range()</a>, <a class="el" href="xsample07a_8cpp_source.html#l01102">compute_group()</a>, <a class="el" href="bm_8h_source.html#l03521">bm::bvector&lt; Alloc &gt;::count_range_no_check()</a>, <a class="el" href="xsample07a_8cpp_source.html#l00994">CSeqClusters::elect_leaders()</a>, <a class="el" href="bm_8h_source.html#l05429">bm::bvector&lt; Alloc &gt;::erase()</a>, <a class="el" href="bm_8h_source.html#l04751">bm::bvector&lt; Alloc &gt;::find_reverse()</a>, <a class="el" href="bm_8h_source.html#l03329">bm::bvector&lt; Alloc &gt;::is_all_one_range()</a>, <a class="el" href="xsample03_8cpp_source.html#l00218">load_snp_report()</a>, <a class="el" href="sample15_8cpp_source.html#l00062">main()</a>, <a class="el" href="xsample05_8cpp_source.html#l00270">pick_benchmark_set()</a>, <a class="el" href="bv3vlogic_8cpp_source.html#l00055">PrintKleeneVector()</a>, and <a class="el" href="bm_8h_source.html#l05215">bm::bvector&lt; Alloc &gt;::shift_left()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="bm_8h_source.html">bm.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
