<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>BitMagic-C++: strsvsample07.cpp</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">BitMagic-C++
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle"><div class="title">strsvsample07.cpp</div></div>
</div><!--header-->
<div class="contents">
<p >Succinct container scanner search using pipeline to run thousands of searches faster one by one scans. scanner::pipeline uses variuous cache and algorithmic optimization techniques to run bulk searches faster.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbm_1_1str__sparse__vector.html" title="succinct sparse vector for strings with compression using bit-slicing ( transposition) method">bm::str_sparse_vector</a> </dd>
<dd>
<a class="el" href="classbm_1_1sparse__vector__scanner.html" title="algorithms for sparse_vector scan/search">bm::sparse_vector_scanner</a> </dd>
<dd>
<a class="el" href="classbm_1_1sparse__vector__scanner_1_1pipeline.html" title="Pipeline to run multiple searches against a particular SV faster using cache optimizations.">bm::sparse_vector_scanner::pipeline</a></dd></dl>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">Copyright(c) 2002-2021 Anatoliy Kuznetsov(anatoliy_kuznetsov at yahoo.com)</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></div>
<div class="line"><span class="comment">you may not use this file except in compliance with the License.</span></div>
<div class="line"><span class="comment">You may obtain a copy of the License at</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">    http://www.apache.org/licenses/LICENSE-2.0</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">Unless required by applicable law or agreed to in writing, software</span></div>
<div class="line"><span class="comment">distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></div>
<div class="line"><span class="comment">WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></div>
<div class="line"><span class="comment">See the License for the specific language governing permissions and</span></div>
<div class="line"><span class="comment">limitations under the License.</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">For more information please visit:  http://bitmagic.io</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/** \example strsvsample07.cpp</span></div>
<div class="line"><span class="comment">    Succinct container scanner search using pipeline to run thousands of searches faster</span></div>
<div class="line"><span class="comment">    one by one scans. scanner::pipeline uses variuous cache and algorithmic optimization techniques</span></div>
<div class="line"><span class="comment">    to run bulk searches faster.</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  \sa bm::str_sparse_vector</span></div>
<div class="line"><span class="comment">  \sa bm::sparse_vector_scanner</span></div>
<div class="line"><span class="comment">  \sa bm::sparse_vector_scanner::pipeline</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/*! \file strsvsample07.cpp</span></div>
<div class="line"><span class="comment">    \brief Example: Succinct container for strings, bulk search using scanner pipeline</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;thread&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="bm_8h.html">bm.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="bmstrsparsevec_8h.html">bmstrsparsevec.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="bmsparsevec__algo_8h.html">bmsparsevec_algo.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="bmtimer_8h.html">bmtimer.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;bmdbg.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="bmundef_8h.html">bmundef.h</a>&quot;</span> <span class="comment">/* clear the pre-proc defines from BM */</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>std;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a name="_a0"></a><a class="code" href="classbm_1_1bvector.html">bm::bvector&lt;&gt;</a> <a name="a1"></a><a class="code" href="strsvsample07_8cpp.html#a4ca03dfc387c36e69ea916426572acdc">bvector_type</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a name="_a2"></a><a class="code" href="classbm_1_1str__sparse__vector.html">bm::str_sparse_vector&lt;char, bvector_type, 8&gt;</a> <a name="a3"></a><a class="code" href="strsvsample07_8cpp.html#a9c3818587377fbf0eafdbe4f905f9406">str_sv_type</a>;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">    Test data generation.</span></div>
<div class="line"><span class="comment">    max_coll - defines the number of string variants</span></div>
<div class="line"><span class="comment">    repeat_factor - how often strings should be duplicated (to simulate the compressable collections),</span></div>
<div class="line"><span class="comment">            higher repeat_factor produces more compressable vector.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">static</span></div>
<div class="line"><span class="keywordtype">void</span> <a name="a4"></a><a class="code" href="strsvsample07_8cpp.html#a5a81baf07bde4113df7e7a1752757535">GenerateTestData</a>(std::vector&lt;string&gt;&amp; str_coll,</div>
<div class="line">                      <a class="code" href="classbm_1_1str__sparse__vector.html">str_sv_type</a>&amp;      str_sv,</div>
<div class="line">                      <span class="keywordtype">unsigned</span> max_coll = 8000000,</div>
<div class="line">                      <span class="keywordtype">unsigned</span> repeat_factor=10)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// use back inserter to fill in succinct vector (it is faster than push_back)</span></div>
<div class="line">    <span class="keyword">auto</span> bi(str_sv.<a name="a5"></a><a class="code" href="classbm_1_1str__sparse__vector.html#ac04560240a3807c8d6be9f6f1bc03f6b">get_back_inserter</a>());</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">string</span> str;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 10; i &lt; max_coll; i+= (rand()&amp;0xF))</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">switch</span> (i &amp; 0xF)</div>
<div class="line">        {</div>
<div class="line">        <span class="keywordflow">case</span> 0: str = <span class="stringliteral">&quot;AB&quot;</span>; <span class="keywordflow">break</span>;</div>
<div class="line">        <span class="keywordflow">case</span> 1: str = <span class="stringliteral">&quot;GTx&quot;</span>; <span class="keywordflow">break</span>;</div>
<div class="line">        <span class="keywordflow">case</span> 2: str = <span class="stringliteral">&quot;cnv&quot;</span>; <span class="keywordflow">break</span>;</div>
<div class="line">        <span class="keywordflow">default</span>: str = <span class="stringliteral">&quot;AbY11&quot;</span>; <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">        str.append(to_string(i));</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> k = 0; k &lt; repeat_factor; ++k)</div>
<div class="line">        {</div>
<div class="line">            str_coll.emplace_back(str);</div>
<div class="line">            bi = str; <span class="comment">// feed into SV back-inserter</span></div>
<div class="line">        }</div>
<div class="line">    } <span class="comment">// for i</span></div>
<div class="line">    bi.flush();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> <a name="a6"></a><a class="code" href="strsvsample07_8cpp.html#aa592d3fbead57ca8423ac5caaccada07">is_diag</a> = <span class="keyword">true</span>; <span class="comment">///&lt; Flag to print the SV diagnostics</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/// Rudimentary cmd-args parser</span></div>
<div class="line"><span class="comment"></span><span class="keyword">static</span></div>
<div class="line"><span class="keywordtype">void</span> <a name="a7"></a><a class="code" href="strsvsample07_8cpp.html#a48a104c6721732cbc3da3080ffc0b4c9">parse_args</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; argc; ++i)</div>
<div class="line">    {</div>
<div class="line">        std::string arg = argv[i];</div>
<div class="line">        <span class="keywordflow">if</span> (arg == <span class="stringliteral">&quot;-nodiag&quot;</span>)</div>
<div class="line">        {</div>
<div class="line">            <a class="code" href="strsvsample07_8cpp.html#aa592d3fbead57ca8423ac5caaccada07">is_diag</a> = <span class="keyword">false</span>;</div>
<div class="line">            <span class="keywordflow">continue</span>;</div>
<div class="line">        }</div>
<div class="line">    } <span class="comment">// for i</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a name="a8"></a><a class="code" href="strsvsample07_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="strsvsample07_8cpp.html#a48a104c6721732cbc3da3080ffc0b4c9">parse_args</a>(argc, argv); </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">        std::vector&lt;string&gt; str_coll;</div>
<div class="line">        <a class="code" href="classbm_1_1str__sparse__vector.html">str_sv_type</a> str_sv0(<a name="a9"></a><a class="code" href="group__bvector.html#ggab0835910831729c806840cd5c8f40b2ba095db184b37a1341cbbbf813a70aed79">bm::use_null</a>); <span class="comment">// sparse-succinct vector</span></div>
<div class="line"> </div>
<div class="line">        cout &lt;&lt; <span class="stringliteral">&quot;Generating the test data... &quot;</span> &lt;&lt; flush;</div>
<div class="line">        <a class="code" href="strsvsample07_8cpp.html#a5a81baf07bde4113df7e7a1752757535">GenerateTestData</a>(str_coll, str_sv0);</div>
<div class="line">        <a class="code" href="classbm_1_1str__sparse__vector.html">str_sv_type</a> str_sv1(str_sv0); <span class="comment">// make a copy of the original vector</span></div>
<div class="line"> </div>
<div class="line">        cout &lt;&lt; <span class="stringliteral">&quot;OK&quot;</span> &lt;&lt; endl;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">        {</div>
<div class="line">            cout &lt;&lt; <span class="stringliteral">&quot;Remapping the data to create compressed vector &quot;</span> &lt;&lt; flush;</div>
<div class="line">            <a name="a10"></a><a class="code" href="bm_8h.html#ad9736d9521d713fa5d48859aa720bfdd">BM_DECLARE_TEMP_BLOCK</a>(tb)</div>
<div class="line">            <span class="comment">// apply char frequency remapping compression</span></div>
<div class="line">            <span class="comment">// (should not modify after that)</span></div>
<div class="line">            str_sv0.remap();</div>
<div class="line">            str_sv0.optimize(tb); <span class="comment">// optimize the succinct vector</span></div>
<div class="line"> </div>
<div class="line">            cout &lt;&lt; <span class="stringliteral">&quot;OK&quot;</span> &lt;&lt; endl;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// we have two succinct vectors str_sv0 (remapped and optimized)</span></div>
<div class="line">        <span class="comment">// and str_sv1 - original after construction</span></div>
<div class="line">        <span class="comment">//  - print statistics to take a look into details</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (<a class="code" href="strsvsample07_8cpp.html#aa592d3fbead57ca8423ac5caaccada07">is_diag</a>)</div>
<div class="line">        {</div>
<div class="line">            cout &lt;&lt; <span class="stringliteral">&quot;\nStatistics on generated SV:&quot;</span> &lt;&lt; endl;</div>
<div class="line">            bm::print_svector_stat(cout, str_sv1);</div>
<div class="line">            <span class="comment">// diagnostics print to see the details of succinct structures</span></div>
<div class="line">            cout &lt;&lt; <span class="stringliteral">&quot;\nStatistics on remapped/optimized SV:&quot;</span> &lt;&lt; endl;</div>
<div class="line">            bm::print_svector_stat(cout, str_sv0);</div>
<div class="line">            cout &lt;&lt; endl &lt;&lt; endl;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// create a random sampling of strings to search</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="keywordtype">unsigned</span> test_runs = 10000;</div>
<div class="line">        std::vector&lt;string&gt; str_test_coll;</div>
<div class="line">        <span class="keywordflow">for</span> (<a class="code" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">bvector_type::size_type</a> i = 0; i &lt; test_runs; ++i)</div>
<div class="line">        {</div>
<div class="line">            <a class="code" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">bvector_type::size_type</a> idx = (unsigned) rand() % test_runs;</div>
<div class="line">            <span class="keywordflow">if</span> (idx &gt;= test_runs)</div>
<div class="line">                idx = test_runs/2;</div>
<div class="line">            str_test_coll.push_back(str_coll[idx]);</div>
<div class="line">        }</div>
<div class="line">        assert(str_test_coll.size() == test_runs);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// -------------------------------------------------------------</span></div>
<div class="line"> </div>
<div class="line">        std::vector&lt;unique_ptr&lt;bvector_type&gt; &gt; res_vec1;</div>
<div class="line">        <a name="_a11"></a><a class="code" href="classbm_1_1sparse__vector__scanner.html">bm::sparse_vector_scanner&lt;str_sv_type&gt;</a> scanner;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">        cout &lt;&lt; <span class="stringliteral">&quot;Running benchmark tests..&quot;</span> &lt;&lt; endl;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> pass = 0; pass &lt; 2; pass++)</div>
<div class="line">        {</div>
<div class="line">            cout &lt;&lt; <span class="stringliteral">&quot;PASS = &quot;</span> &lt;&lt; pass &lt;&lt; ((pass==0) ? <span class="stringliteral">&quot; -- remap/optimized&quot;</span> : <span class="stringliteral">&quot; -- NOT remapped&quot;</span>) &lt;&lt; endl;</div>
<div class="line"> </div>
<div class="line">            res_vec1.resize(0);</div>
<div class="line">            <span class="keyword">const</span> <a class="code" href="classbm_1_1str__sparse__vector.html">str_sv_type</a>* str_sv = (pass==0) ? &amp;str_sv0 : &amp;str_sv1;</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// Run experiment 1, search sparse vector in a loop one-by-one</span></div>
<div class="line">            <span class="comment">// This is not a slow method, scanner uses various optimizations</span></div>
<div class="line">            <span class="comment">// (SIMD, &quot;search space prunning&quot; to be efficient)</span></div>
<div class="line">            {</div>
<div class="line">                <a name="_a12"></a><a class="code" href="classbm_1_1chrono__taker.html">bm::chrono_taker</a> tt(cout, <span class="stringliteral">&quot;scanner&lt;&gt;::find_eq_str()&quot;</span>, test_runs);</div>
<div class="line"> </div>
<div class="line">                <span class="keywordflow">for</span> (<a class="code" href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">bvector_type::size_type</a> i = 0; i &lt; test_runs; ++i)</div>
<div class="line">                {</div>
<div class="line">                    <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; str = str_test_coll[i];</div>
<div class="line">                    unique_ptr&lt;bvector_type&gt; bv_res(<span class="keyword">new</span> <a class="code" href="classbm_1_1bvector.html">bvector_type</a>);</div>
<div class="line">                    scanner.<a name="a13"></a><a class="code" href="classbm_1_1sparse__vector__scanner.html#af84dcafdb4ee0eb1673b93bb52c72631">find_eq_str</a>(*str_sv, str.c_str(), *bv_res);</div>
<div class="line">                    res_vec1.emplace_back(unique_ptr&lt;bvector_type&gt;(bv_res.release()));</div>
<div class="line">                } <span class="comment">// for</span></div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// There is a faster way to do the same.</span></div>
<div class="line">            <span class="comment">// if we know a bulk of our searches upfront we can use pipeline</span></div>
<div class="line">            <span class="comment">// schedule to run the search group.</span></div>
<div class="line">            <span class="comment">// Scanner pipeline will anayse the set and try to build a more</span></div>
<div class="line">            <span class="comment">// optimal search plan, taking into account CPU cache optimization,</span></div>
<div class="line">            <span class="comment">// resuse of compressed bit-blocks (inetrnal details) and other</span></div>
<div class="line">            <span class="comment">// factors between the search data set items and the sparce vector</span></div>
<div class="line">            <span class="comment">//</span></div>
<div class="line"> </div>
<div class="line">            <span class="comment">// pipeline object to run the bulk search</span></div>
<div class="line">            <span class="comment">//</span></div>
<div class="line">            <a name="_a14"></a><a class="code" href="classbm_1_1sparse__vector__scanner_1_1pipeline.html">bm::sparse_vector_scanner&lt;str_sv_type&gt;::pipeline</a>&lt;&gt; pipe1(*str_sv);</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// batch_size instructs how many search to run at once</span></div>
<div class="line">            <span class="comment">// batch_size=0 and this parameter will be identified automatically</span></div>
<div class="line">            <span class="comment">//</span></div>
<div class="line">            <span class="comment">// batch size essentially depends on CPU cache size and it is</span></div>
<div class="line">            <span class="comment">// sometimes difficult to determine without trying.</span></div>
<div class="line">            <span class="comment">// batch_size=0 will try to use euristics for CPU L2 = 256KB,</span></div>
<div class="line">            <span class="comment">// it may be &quot;good enough&quot;, but for best results it is best</span></div>
<div class="line">            <span class="comment">// to run trial runs with typical values may be (2 to 20)</span></div>
<div class="line">            <span class="comment">//</span></div>
<div class="line">            pipe1.options().batch_size = test_runs;</div>
<div class="line">            {</div>
<div class="line">                <a class="code" href="classbm_1_1chrono__taker.html">bm::chrono_taker</a> tt(cout, <span class="stringliteral">&quot;scanner::pipeline find_eq_str()&quot;</span>, test_runs);</div>
<div class="line"> </div>
<div class="line">                <span class="comment">// add all the search items to the pipeline</span></div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; test_runs; ++i)</div>
<div class="line">                {</div>
<div class="line">                    <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; str = str_test_coll[i];</div>
<div class="line">                    pipe1.add(str.c_str());</div>
<div class="line">                }</div>
<div class="line">                pipe1.complete(); <span class="comment">// finish the pipeline construction with this call</span></div>
<div class="line"> </div>
<div class="line">                scanner.<a class="code" href="classbm_1_1sparse__vector__scanner.html#af84dcafdb4ee0eb1673b93bb52c72631">find_eq_str</a>(pipe1); <span class="comment">// run the search</span></div>
<div class="line"> </div>
<div class="line">                <span class="comment">// at this point we have the results (in the pipeline object itself)</span></div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// This example sets the search range for only a part of</span></div>
<div class="line">            <span class="comment">// the sv vector using the mask bit-vector.</span></div>
<div class="line">            <span class="comment">// Since mask vector narrows down the search space - it is faster</span></div>
<div class="line">            <span class="comment">//</span></div>
<div class="line">            <a class="code" href="classbm_1_1bvector.html">bm::bvector&lt;&gt;</a> bv_mask;</div>
<div class="line">            bv_mask.<a name="a15"></a><a class="code" href="classbm_1_1bvector.html#aafb2ecaa1a55856533e6b4afbf788eae">set_range</a>(0, str_sv-&gt;<a name="a16"></a><a class="code" href="classbm_1_1str__sparse__vector.html#a3a699904075820c3418e4372ab76b398">size</a>()/3); <span class="comment">// only first 1/3 of elements will be searched</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">            <span class="comment">// scanner is configured to support result vectors AND search masking</span></div>
<div class="line">            <span class="comment">//</span></div>
<div class="line">            <span class="keyword">typedef</span> <a name="_a17"></a><a class="code" href="structbm_1_1agg__run__options.html">bm::agg_run_options&lt;true, false, true&gt;</a> scanner_custom_mask_opt;</div>
<div class="line">            <a class="code" href="classbm_1_1sparse__vector__scanner_1_1pipeline.html">bm::sparse_vector_scanner&lt;str_sv_type&gt;::pipeline</a>&lt;scanner_custom_mask_opt&gt; pipe1_and(*str_sv);</div>
<div class="line"> </div>
<div class="line">            pipe1_and.set_search_mask(&amp;bv_mask); <span class="comment">// associate search mask with the pipeline</span></div>
<div class="line">            pipe1_and.options().batch_size = test_runs;</div>
<div class="line"> </div>
<div class="line">            {</div>
<div class="line">                <a class="code" href="classbm_1_1chrono__taker.html">bm::chrono_taker</a> tt(cout, <span class="stringliteral">&quot;scanner::pipeline+MASK find_eq_str()&quot;</span>, test_runs);</div>
<div class="line"> </div>
<div class="line">                <span class="comment">// add all the search items to the pipeline</span></div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; test_runs; ++i)</div>
<div class="line">                {</div>
<div class="line">                    <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; str = str_test_coll[i];</div>
<div class="line">                    pipe1_and.add(str.c_str()); <span class="comment">// this will search within defined mask</span></div>
<div class="line">                }</div>
<div class="line">                pipe1_and.complete();</div>
<div class="line">                scanner.<a class="code" href="classbm_1_1sparse__vector__scanner.html#af84dcafdb4ee0eb1673b93bb52c72631">find_eq_str</a>(pipe1_and); <span class="comment">// run the search</span></div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">            <span class="comment">// This variant would build the same pipeline but configure</span></div>
<div class="line">            <span class="comment">// it differently using pipe2.options()</span></div>
<div class="line">            <span class="comment">//</span></div>
<div class="line">            <span class="comment">// The idea here is that sometimes we don&#39;t actually need the result</span></div>
<div class="line">            <span class="comment">// vectors, but only need population count from this</span></div>
<div class="line">            <span class="comment">// pipeline can be configured to do that without actually</span></div>
<div class="line">            <span class="comment">// materializing result bit-vectors</span></div>
<div class="line">            <span class="comment">//</span></div>
<div class="line"> </div>
<div class="line">            <span class="comment">// pipeline configuration passed via template parameter</span></div>
<div class="line">            <span class="comment">// instructs to drop results and provide only counts</span></div>
<div class="line"> </div>
<div class="line">            <a class="code" href="classbm_1_1sparse__vector__scanner_1_1pipeline.html">bm::sparse_vector_scanner&lt;str_sv_type&gt;::pipeline</a>&lt;<a class="code" href="structbm_1_1agg__run__options.html">bm::agg_opt_only_counts</a>&gt; pipe2(*str_sv);</div>
<div class="line">            pipe1.options().batch_size = test_runs;</div>
<div class="line"> </div>
<div class="line">            {</div>
<div class="line">                <a class="code" href="classbm_1_1chrono__taker.html">bm::chrono_taker</a> tt(cout, <span class="stringliteral">&quot;scanner::pipeline find_eq_str()-count()&quot;</span>, test_runs);</div>
<div class="line"> </div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; test_runs; ++i)</div>
<div class="line">                {</div>
<div class="line">                    <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; str = str_test_coll[i];</div>
<div class="line">                    pipe2.add(str.c_str());</div>
<div class="line">                }</div>
<div class="line">                pipe2.complete(); <span class="comment">// finish the pipeline construction with this call</span></div>
<div class="line"> </div>
<div class="line">                scanner.<a class="code" href="classbm_1_1sparse__vector__scanner.html#af84dcafdb4ee0eb1673b93bb52c72631">find_eq_str</a>(pipe2); <span class="comment">// run the search pipeline</span></div>
<div class="line"> </div>
<div class="line">                <span class="comment">// at this point we have the population count</span></div>
<div class="line">                <span class="comment">// ... see below how to use it</span></div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// results from two pileline runs are ready at this point</span></div>
<div class="line">            <span class="comment">// we now get access to it</span></div>
<div class="line">            <span class="comment">//</span></div>
<div class="line"> </div>
<div class="line">            <a class="code" href="classbm_1_1bvector.html">bvector_type</a> bv_or_total;</div>
<div class="line"> </div>
<div class="line">            {</div>
<div class="line">                <span class="comment">// please note that returned buffer results vectors are NOT STL</span></div>
<div class="line">                <span class="comment">// vector&lt;&gt; type, but a thin wrapper over C style objects</span></div>
<div class="line">                <span class="comment">// (for the reasons of portability)</span></div>
<div class="line">                <span class="comment">//</span></div>
<div class="line">                <span class="keyword">auto</span>&amp; res_vect = pipe1.get_bv_res_vector(); <span class="comment">// results from pipeline 1</span></div>
<div class="line">                <span class="keyword">auto</span>&amp; res_vect_and = pipe1_and.get_bv_res_vector();</div>
<div class="line">                <span class="keyword">auto</span>&amp; cnt_vect = pipe2.get_bv_count_vector(); <span class="comment">// counts from pileine 2</span></div>
<div class="line"> </div>
<div class="line">                assert(res_vect.size() == cnt_vect.size());</div>
<div class="line"> </div>
<div class="line">                <span class="comment">// iterate over results, run some checks...</span></div>
<div class="line">                <span class="keywordtype">size_t</span> res_sz = res_vect.size();</div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; res_sz; ++i)</div>
<div class="line">                {</div>
<div class="line">                    <span class="keyword">const</span> <a class="code" href="classbm_1_1bvector.html">bvector_type</a>* bv1 = res_vec1[i].get();</div>
<div class="line">                    assert(bv1);</div>
<div class="line">                    <span class="keyword">const</span> <a class="code" href="classbm_1_1bvector.html">bvector_type</a>* bv = res_vect[i];</div>
<div class="line">                    assert(bv);</div>
<div class="line">                    <span class="keywordtype">bool</span> match = bv1-&gt;<a name="a18"></a><a class="code" href="classbm_1_1bvector.html#a23a267a48a594836e6a2f1d08a4166f3">equal</a>(*bv); <span class="comment">// quick check</span></div>
<div class="line">                    assert(match);</div>
<div class="line"> </div>
<div class="line">                    <span class="keyword">auto</span> c = cnt_vect[i];</div>
<div class="line">                    <span class="keyword">auto</span> cnt = bv-&gt;<a name="a19"></a><a class="code" href="classbm_1_1bvector.html#a3009ba9b116f13f4933a48641f3a695d">count</a>();</div>
<div class="line">                    (void)cnt; (void)c; <span class="comment">// to silence unused warnings (relese)</span></div>
<div class="line">                    assert(cnt == c); <span class="comment">// check if counts match</span></div>
<div class="line"> </div>
<div class="line">                    bv_or_total |= *bv; <span class="comment">// accumulate OR</span></div>
<div class="line">                    {</div>
<div class="line">                    <span class="keyword">auto</span> c_and = <a name="a20"></a><a class="code" href="group__setalgo.html#ga5fb1131811b7b834dfc56a3874667a65">bm::count_and</a>(*bv, bv_mask);</div>
<div class="line">                    <span class="keyword">const</span> <a class="code" href="classbm_1_1bvector.html">bvector_type</a>* bv_and = res_vect_and[i];</div>
<div class="line">                    <span class="keywordflow">if</span> (bv_and)</div>
<div class="line">                    {</div>
<div class="line">                        <span class="keyword">auto</span> c1 = bv_and-&gt;<a class="code" href="classbm_1_1bvector.html#a3009ba9b116f13f4933a48641f3a695d">count</a>();</div>
<div class="line">                        assert(c1 == c_and); (void)c1; (void)c_and;</div>
<div class="line">                        <a class="code" href="classbm_1_1bvector.html">bvector_type</a> bv_m;</div>
<div class="line">                        bv_m.<a name="a21"></a><a class="code" href="classbm_1_1bvector.html#a37c1ccb4755c61450311918ad3330aa6">bit_and</a>(*bv1, bv_mask);</div>
<div class="line">                        match = bv_and-&gt;<a class="code" href="classbm_1_1bvector.html#a23a267a48a594836e6a2f1d08a4166f3">equal</a>(bv_m);</div>
<div class="line">                        assert(match);</div>
<div class="line">                    }</div>
<div class="line">                    <span class="keywordflow">else</span></div>
<div class="line">                    {</div>
<div class="line">                        assert(!c_and);</div>
<div class="line">                    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// Here we define a csutom pipeline run policy which disables</span></div>
<div class="line">            <span class="comment">// both intermediate results and population counting for it...</span></div>
<div class="line">            <span class="comment">//</span></div>
<div class="line">            <span class="comment">// instead it aggregates the results into one UNION ALL (OR) vector</span></div>
<div class="line">            <span class="comment">// which simulates a huge</span></div>
<div class="line">            <span class="comment">// field1 IN (&#39;value1&#39;, &#39;value2&#39;, &#39;value3&#39;, .... ) SQL expression</span></div>
<div class="line">            <span class="comment">//</span></div>
<div class="line"> </div>
<div class="line">            <span class="keyword">typedef</span> <a class="code" href="structbm_1_1agg__run__options.html">bm::agg_run_options&lt;false, false&gt;</a> scanner_custom_opt;</div>
<div class="line">            <a class="code" href="classbm_1_1sparse__vector__scanner_1_1pipeline.html">bm::sparse_vector_scanner&lt;str_sv_type&gt;::pipeline</a>&lt;scanner_custom_opt&gt; pipe3(*str_sv);</div>
<div class="line">            pipe1.options().batch_size = test_runs;</div>
<div class="line"> </div>
<div class="line">            <a class="code" href="classbm_1_1bvector.html">bvector_type</a> bv_or;</div>
<div class="line">            pipe3.set_or_target(&amp;bv_or); <span class="comment">// Assign OR aggregation target</span></div>
<div class="line"> </div>
<div class="line">            {</div>
<div class="line">                <a class="code" href="classbm_1_1chrono__taker.html">bm::chrono_taker</a> tt(cout, <span class="stringliteral">&quot;scanner::pipeline find_eq_str()-OR()&quot;</span>, test_runs);</div>
<div class="line"> </div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; test_runs; ++i)</div>
<div class="line">                {</div>
<div class="line">                    <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; str = str_test_coll[i];</div>
<div class="line">                    pipe3.add(str.c_str());</div>
<div class="line">                }</div>
<div class="line">                pipe3.complete(); <span class="comment">// finish the pipeline construction with this call</span></div>
<div class="line"> </div>
<div class="line">                scanner.<a class="code" href="classbm_1_1sparse__vector__scanner.html#af84dcafdb4ee0eb1673b93bb52c72631">find_eq_str</a>(pipe3); <span class="comment">// run the search pipeline</span></div>
<div class="line">            }</div>
<div class="line">            <span class="keywordtype">bool</span> match = bv_or.<a class="code" href="classbm_1_1bvector.html#a23a267a48a594836e6a2f1d08a4166f3">equal</a>(bv_or_total);</div>
<div class="line">            <span class="keywordflow">if</span> (!match)</div>
<div class="line">            {</div>
<div class="line">                cerr &lt;&lt; <span class="stringliteral">&quot;OR vector mismatch!&quot;</span> &lt;&lt; endl;</div>
<div class="line">                exit(1);</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">            cout &lt;&lt; endl;</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// second pass will run the same benchmarks, only using original</span></div>
<div class="line">            <span class="comment">// non-remapped vector to see the effects of additional compression</span></div>
<div class="line">            <span class="comment">// on performance of scanner searches</span></div>
<div class="line"> </div>
<div class="line">        } <span class="comment">// for pass</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">catch</span>(std::exception&amp; ex)</div>
<div class="line">    {</div>
<div class="line">        std::cerr &lt;&lt; ex.what() &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="ttc" id="abm_8h_html"><div class="ttname"><a href="bm_8h.html">bm.h</a></div><div class="ttdoc">Compressed bit-vector bvector&lt;&gt; container, set algebraic methods, traversal iterators.</div></div>
<div class="ttc" id="abm_8h_html_ad9736d9521d713fa5d48859aa720bfdd"><div class="ttname"><a href="bm_8h.html#ad9736d9521d713fa5d48859aa720bfdd">BM_DECLARE_TEMP_BLOCK</a></div><div class="ttdeci">#define BM_DECLARE_TEMP_BLOCK(x)</div><div class="ttdef"><b>Definition:</b> <a href="bm_8h_source.html#l00047">bm.h:47</a></div></div>
<div class="ttc" id="abmsparsevec__algo_8h_html"><div class="ttname"><a href="bmsparsevec__algo_8h.html">bmsparsevec_algo.h</a></div><div class="ttdoc">Algorithms for bm::sparse_vector.</div></div>
<div class="ttc" id="abmstrsparsevec_8h_html"><div class="ttname"><a href="bmstrsparsevec_8h.html">bmstrsparsevec.h</a></div><div class="ttdoc">string sparse vector based on bit-transposed matrix</div></div>
<div class="ttc" id="abmtimer_8h_html"><div class="ttname"><a href="bmtimer_8h.html">bmtimer.h</a></div><div class="ttdoc">Timing utilities for benchmarking (internal)</div></div>
<div class="ttc" id="abmundef_8h_html"><div class="ttname"><a href="bmundef_8h.html">bmundef.h</a></div><div class="ttdoc">pre-processor un-defines to avoid global space pollution (internal)</div></div>
<div class="ttc" id="aclassbm_1_1bvector_html"><div class="ttname"><a href="classbm_1_1bvector.html">bm::bvector</a></div><div class="ttdoc">Bitvector Bit-vector container with runtime compression of bits.</div><div class="ttdef"><b>Definition:</b> <a href="bm_8h_source.html#l00114">bm.h:115</a></div></div>
<div class="ttc" id="aclassbm_1_1bvector_html_a23a267a48a594836e6a2f1d08a4166f3"><div class="ttname"><a href="classbm_1_1bvector.html#a23a267a48a594836e6a2f1d08a4166f3">bm::bvector::equal</a></div><div class="ttdeci">bool equal(const bvector&lt; Alloc &gt; &amp;bvect) const BMNOEXCEPT</div><div class="ttdoc">Equal comparison with an agr bit-vector.</div><div class="ttdef"><b>Definition:</b> <a href="bm_8h_source.html#l02029">bm.h:2029</a></div></div>
<div class="ttc" id="aclassbm_1_1bvector_html_a3009ba9b116f13f4933a48641f3a695d"><div class="ttname"><a href="classbm_1_1bvector.html#a3009ba9b116f13f4933a48641f3a695d">bm::bvector::count</a></div><div class="ttdeci">size_type count() const BMNOEXCEPT</div><div class="ttdoc">population count (count of ON bits)</div><div class="ttdef"><b>Definition:</b> <a href="bm_8h_source.html#l02399">bm.h:2399</a></div></div>
<div class="ttc" id="aclassbm_1_1bvector_html_a37c1ccb4755c61450311918ad3330aa6"><div class="ttname"><a href="classbm_1_1bvector.html#a37c1ccb4755c61450311918ad3330aa6">bm::bvector::bit_and</a></div><div class="ttdeci">bm::bvector&lt; Alloc &gt; &amp; bit_and(const bm::bvector&lt; Alloc &gt; &amp;bv1, const bm::bvector&lt; Alloc &gt; &amp;bv2, typename bm::bvector&lt; Alloc &gt;::optmode opt_mode=opt_none)</div><div class="ttdoc">3-operand AND : this := bv1 AND bv2</div><div class="ttdef"><b>Definition:</b> <a href="bm_8h_source.html#l05901">bm.h:5901</a></div></div>
<div class="ttc" id="aclassbm_1_1bvector_html_a7fea809653a2792c84fd10c92b5c47c4"><div class="ttname"><a href="classbm_1_1bvector.html#a7fea809653a2792c84fd10c92b5c47c4">bm::bvector::size_type</a></div><div class="ttdeci">bvector_size_type size_type</div><div class="ttdef"><b>Definition:</b> <a href="bm_8h_source.html#l00121">bm.h:121</a></div></div>
<div class="ttc" id="aclassbm_1_1bvector_html_aafb2ecaa1a55856533e6b4afbf788eae"><div class="ttname"><a href="classbm_1_1bvector.html#aafb2ecaa1a55856533e6b4afbf788eae">bm::bvector::set_range</a></div><div class="ttdeci">bvector&lt; Alloc &gt; &amp; set_range(size_type left, size_type right, bool value=true)</div><div class="ttdoc">Sets all bits in the specified closed interval [left,right] Interval must be inside the bvector's siz...</div><div class="ttdef"><b>Definition:</b> <a href="bm_8h_source.html#l02366">bm.h:2366</a></div></div>
<div class="ttc" id="aclassbm_1_1chrono__taker_html"><div class="ttname"><a href="classbm_1_1chrono__taker.html">bm::chrono_taker</a></div><div class="ttdoc">Utility class to collect performance measurements and statistics.</div><div class="ttdef"><b>Definition:</b> <a href="bmtimer_8h_source.html#l00040">bmtimer.h:41</a></div></div>
<div class="ttc" id="aclassbm_1_1sparse__vector__scanner_1_1pipeline_html"><div class="ttname"><a href="classbm_1_1sparse__vector__scanner_1_1pipeline.html">bm::sparse_vector_scanner::pipeline</a></div><div class="ttdoc">Pipeline to run multiple searches against a particular SV faster using cache optimizations.</div><div class="ttdef"><b>Definition:</b> <a href="bmsparsevec__algo_8h_source.html#l00537">bmsparsevec_algo.h:538</a></div></div>
<div class="ttc" id="aclassbm_1_1sparse__vector__scanner_html"><div class="ttname"><a href="classbm_1_1sparse__vector__scanner.html">bm::sparse_vector_scanner</a></div><div class="ttdoc">algorithms for sparse_vector scan/search</div><div class="ttdef"><b>Definition:</b> <a href="bmsparsevec__algo_8h_source.html#l00499">bmsparsevec_algo.h:500</a></div></div>
<div class="ttc" id="aclassbm_1_1sparse__vector__scanner_html_af84dcafdb4ee0eb1673b93bb52c72631"><div class="ttname"><a href="classbm_1_1sparse__vector__scanner.html#af84dcafdb4ee0eb1673b93bb52c72631">bm::sparse_vector_scanner::find_eq_str</a></div><div class="ttdeci">bool find_eq_str(const SV &amp;sv, const value_type *str, bvector_type &amp;bv_out)</div><div class="ttdoc">find sparse vector elements (string)</div></div>
<div class="ttc" id="aclassbm_1_1str__sparse__vector_html"><div class="ttname"><a href="classbm_1_1str__sparse__vector.html">bm::str_sparse_vector</a></div><div class="ttdoc">succinct sparse vector for strings with compression using bit-slicing ( transposition) method</div><div class="ttdef"><b>Definition:</b> <a href="bmstrsparsevec_8h_source.html#l00065">bmstrsparsevec.h:66</a></div></div>
<div class="ttc" id="aclassbm_1_1str__sparse__vector_html_a3a699904075820c3418e4372ab76b398"><div class="ttname"><a href="classbm_1_1str__sparse__vector.html#a3a699904075820c3418e4372ab76b398">bm::str_sparse_vector::size</a></div><div class="ttdeci">size_type size() const</div><div class="ttdoc">return size of the vector</div><div class="ttdef"><b>Definition:</b> <a href="bmstrsparsevec_8h_source.html#l00776">bmstrsparsevec.h:776</a></div></div>
<div class="ttc" id="aclassbm_1_1str__sparse__vector_html_ac04560240a3807c8d6be9f6f1bc03f6b"><div class="ttname"><a href="classbm_1_1str__sparse__vector.html#ac04560240a3807c8d6be9f6f1bc03f6b">bm::str_sparse_vector::get_back_inserter</a></div><div class="ttdeci">back_insert_iterator get_back_inserter()</div><div class="ttdoc">Provide back insert iterator Back insert iterator implements buffered insertion, which is faster,...</div><div class="ttdef"><b>Definition:</b> <a href="bmstrsparsevec_8h_source.html#l00877">bmstrsparsevec.h:877</a></div></div>
<div class="ttc" id="agroup__bvector_html_ggab0835910831729c806840cd5c8f40b2ba095db184b37a1341cbbbf813a70aed79"><div class="ttname"><a href="group__bvector.html#ggab0835910831729c806840cd5c8f40b2ba095db184b37a1341cbbbf813a70aed79">bm::use_null</a></div><div class="ttdeci">@ use_null</div><div class="ttdoc">support &quot;non-assigned&quot; or &quot;NULL&quot; logic</div><div class="ttdef"><b>Definition:</b> <a href="bmconst_8h_source.html#l00229">bmconst.h:229</a></div></div>
<div class="ttc" id="agroup__setalgo_html_ga5fb1131811b7b834dfc56a3874667a65"><div class="ttname"><a href="group__setalgo.html#ga5fb1131811b7b834dfc56a3874667a65">bm::count_and</a></div><div class="ttdeci">BV::size_type count_and(const BV &amp;bv1, const BV &amp;bv2) BMNOEXCEPT</div><div class="ttdoc">Computes bitcount of AND operation of two bitsets.</div><div class="ttdef"><b>Definition:</b> <a href="bmalgo_8h_source.html#l00049">bmalgo.h:49</a></div></div>
<div class="ttc" id="astrsvsample07_8cpp_html_a0ddf1224851353fc92bfbff6f499fa97"><div class="ttname"><a href="strsvsample07_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97">main</a></div><div class="ttdeci">int main(int argc, char *argv[])</div><div class="ttdef"><b>Definition:</b> <a href="strsvsample07_8cpp_source.html#l00111">strsvsample07.cpp:111</a></div></div>
<div class="ttc" id="astrsvsample07_8cpp_html_a48a104c6721732cbc3da3080ffc0b4c9"><div class="ttname"><a href="strsvsample07_8cpp.html#a48a104c6721732cbc3da3080ffc0b4c9">parse_args</a></div><div class="ttdeci">static void parse_args(int argc, char *argv[])</div><div class="ttdoc">Rudimentary cmd-args parser.</div><div class="ttdef"><b>Definition:</b> <a href="strsvsample07_8cpp_source.html#l00095">strsvsample07.cpp:95</a></div></div>
<div class="ttc" id="astrsvsample07_8cpp_html_a4ca03dfc387c36e69ea916426572acdc"><div class="ttname"><a href="strsvsample07_8cpp.html#a4ca03dfc387c36e69ea916426572acdc">bvector_type</a></div><div class="ttdeci">bm::bvector bvector_type</div><div class="ttdef"><b>Definition:</b> <a href="strsvsample07_8cpp_source.html#l00051">strsvsample07.cpp:51</a></div></div>
<div class="ttc" id="astrsvsample07_8cpp_html_a5a81baf07bde4113df7e7a1752757535"><div class="ttname"><a href="strsvsample07_8cpp.html#a5a81baf07bde4113df7e7a1752757535">GenerateTestData</a></div><div class="ttdeci">static void GenerateTestData(std::vector&lt; string &gt; &amp;str_coll, str_sv_type &amp;str_sv, unsigned max_coll=8000000, unsigned repeat_factor=10)</div><div class="ttdoc">Test data generation.</div><div class="ttdef"><b>Definition:</b> <a href="strsvsample07_8cpp_source.html#l00062">strsvsample07.cpp:62</a></div></div>
<div class="ttc" id="astrsvsample07_8cpp_html_a9c3818587377fbf0eafdbe4f905f9406"><div class="ttname"><a href="strsvsample07_8cpp.html#a9c3818587377fbf0eafdbe4f905f9406">str_sv_type</a></div><div class="ttdeci">bm::str_sparse_vector&lt; char, bvector_type, 8 &gt; str_sv_type</div><div class="ttdef"><b>Definition:</b> <a href="strsvsample07_8cpp_source.html#l00052">strsvsample07.cpp:52</a></div></div>
<div class="ttc" id="astrsvsample07_8cpp_html_aa592d3fbead57ca8423ac5caaccada07"><div class="ttname"><a href="strsvsample07_8cpp.html#aa592d3fbead57ca8423ac5caaccada07">is_diag</a></div><div class="ttdeci">bool is_diag</div><div class="ttdoc">Flag to print the SV diagnostics.</div><div class="ttdef"><b>Definition:</b> <a href="strsvsample07_8cpp_source.html#l00091">strsvsample07.cpp:91</a></div></div>
<div class="ttc" id="astructbm_1_1agg__run__options_html"><div class="ttname"><a href="structbm_1_1agg__run__options.html">bm::agg_run_options</a></div><div class="ttdoc">Aggregation options to control execution Default settings are to support only result bit-vector filte...</div><div class="ttdef"><b>Definition:</b> <a href="bmaggregator_8h_source.html#l00065">bmaggregator.h:66</a></div></div>
</div><!-- fragment --> </div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
